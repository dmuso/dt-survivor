{"id":"dt-survivor-0as","title":"Track per-level statistics (time, kills, XP)","description":"Track gameplay statistics for each game level to display on the level complete screen.\n\n## Context\nThe GameLevel resource in dt-survivor-ahu tracks total kills and kills_this_level. This task adds comprehensive per-level statistics tracking including time taken and XP gained.\n\n## Implementation\n\n### Resource Definition (src/game/resources.rs)\n```rust\n/// Statistics for the current level\n#[derive(Resource, Debug, Default)]\npub struct LevelStats {\n    /// Time elapsed in current level (seconds)\n    pub time_elapsed: f32,\n    /// Enemies killed in current level\n    pub enemies_killed: u32,\n    /// XP gained in current level\n    pub xp_gained: u32,\n    /// Timestamp when level started\n    pub level_start_time: f32,\n}\n\nimpl LevelStats {\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Reset stats for a new level\n    pub fn reset(\u0026mut self, current_time: f32) {\n        self.time_elapsed = 0.0;\n        self.enemies_killed = 0;\n        self.xp_gained = 0;\n        self.level_start_time = current_time;\n    }\n\n    /// Record an enemy kill\n    pub fn record_kill(\u0026mut self) {\n        self.enemies_killed += 1;\n    }\n\n    /// Record XP gained\n    pub fn record_xp(\u0026mut self, amount: u32) {\n        self.xp_gained += amount;\n    }\n\n    /// Update elapsed time\n    pub fn update_time(\u0026mut self, current_time: f32) {\n        self.time_elapsed = current_time - self.level_start_time;\n    }\n\n    /// Format time as MM:SS\n    pub fn formatted_time(\u0026self) -\u003e String {\n        let minutes = (self.time_elapsed / 60.0) as u32;\n        let seconds = (self.time_elapsed % 60.0) as u32;\n        format!(\"{:02}:{:02}\", minutes, seconds)\n    }\n}\n```\n\n### System Implementation (src/game/systems.rs)\n```rust\n/// Update level time tracking\npub fn update_level_time_system(\n    time: Res\u003cTime\u003e,\n    mut level_stats: ResMut\u003cLevelStats\u003e,\n) {\n    level_stats.time_elapsed += time.delta_secs();\n}\n\n/// Track enemy kills for level stats\npub fn track_level_kills_system(\n    mut death_events: MessageReader\u003cEnemyDeathEvent\u003e,\n    mut level_stats: ResMut\u003cLevelStats\u003e,\n) {\n    for _ in death_events.read() {\n        level_stats.record_kill();\n    }\n}\n\n/// Track XP gained for level stats\npub fn track_level_xp_system(\n    mut effect_events: MessageReader\u003cItemEffectEvent\u003e,\n    orb_query: Query\u003c\u0026ExperienceOrb\u003e,\n    mut level_stats: ResMut\u003cLevelStats\u003e,\n) {\n    for event in effect_events.read() {\n        if let ItemData::Experience = event.item_data {\n            if let Ok(orb) = orb_query.get(event.source_entity) {\n                level_stats.record_xp(orb.value);\n            }\n        }\n    }\n}\n\n/// Reset level stats when starting a new level\npub fn reset_level_stats_system(\n    mut level_stats: ResMut\u003cLevelStats\u003e,\n    time: Res\u003cTime\u003e,\n) {\n    level_stats.reset(time.elapsed_secs());\n}\n```\n\n### Plugin Registration (src/game/plugin.rs)\n```rust\napp\n    .init_resource::\u003cLevelStats\u003e()\n    .add_systems(OnEnter(GameState::InGame), reset_level_stats_system)\n    .add_systems(\n        Update,\n        (\n            update_level_time_system,\n            track_level_kills_system,\n            track_level_xp_system,\n        )\n            .in_set(GameSet::Effects)\n            .run_if(in_state(GameState::InGame)),\n    );\n```\n\n## ECS Pattern\n```rust\n// Query level stats for display\nfn display_stats(level_stats: Res\u003cLevelStats\u003e) {\n    println!(\"Time: {}\", level_stats.formatted_time());\n    println!(\"Kills: {}\", level_stats.enemies_killed);\n    println!(\"XP: {}\", level_stats.xp_gained);\n}\n```\n\n## Acceptance Criteria\n- [ ] LevelStats resource tracks time_elapsed, enemies_killed, xp_gained\n- [ ] Time updates every frame during InGame state\n- [ ] Kills increment on EnemyDeathEvent\n- [ ] XP increments on experience orb collection\n- [ ] Stats reset when entering new level\n- [ ] formatted_time() returns MM:SS format\n- [ ] Unit tests for LevelStats methods\n- [ ] Unit tests for reset behavior\n\n## Test Requirements\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn level_stats_starts_at_zero() {\n        let stats = LevelStats::new();\n        assert_eq!(stats.time_elapsed, 0.0);\n        assert_eq!(stats.enemies_killed, 0);\n        assert_eq!(stats.xp_gained, 0);\n    }\n\n    #[test]\n    fn level_stats_records_kills() {\n        let mut stats = LevelStats::new();\n        stats.record_kill();\n        stats.record_kill();\n        assert_eq!(stats.enemies_killed, 2);\n    }\n\n    #[test]\n    fn level_stats_records_xp() {\n        let mut stats = LevelStats::new();\n        stats.record_xp(50);\n        stats.record_xp(25);\n        assert_eq!(stats.xp_gained, 75);\n    }\n\n    #[test]\n    fn level_stats_formats_time_correctly() {\n        let mut stats = LevelStats::new();\n        stats.time_elapsed = 125.0; // 2:05\n        assert_eq!(stats.formatted_time(), \"02:05\");\n    }\n\n    #[test]\n    fn level_stats_resets_correctly() {\n        let mut stats = LevelStats::new();\n        stats.enemies_killed = 10;\n        stats.xp_gained = 500;\n        stats.time_elapsed = 60.0;\n        stats.reset(100.0);\n        assert_eq!(stats.enemies_killed, 0);\n        assert_eq!(stats.xp_gained, 0);\n        assert_eq!(stats.time_elapsed, 0.0);\n        assert_eq!(stats.level_start_time, 100.0);\n    }\n}\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-30T10:34:05.337308+11:00","updated_at":"2025-12-30T11:43:28.580549+11:00","closed_at":"2025-12-30T11:43:28.580549+11:00","dependencies":[{"issue_id":"dt-survivor-0as","depends_on_id":"dt-survivor-aiy","type":"blocks","created_at":"2025-12-30T10:35:04.69698+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-0as","depends_on_id":"dt-survivor-ahu","type":"blocks","created_at":"2025-12-30T10:35:04.772049+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-0oz","title":"Implement Black Spiral Spell (Dark)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Black Spiral\n- **Element**: Dark\n- **Behavior**: Rotating vortex of dark energy pulls enemies inward. Creates a swirling vortex at a target location that continuously pulls nearby enemies toward its center while dealing damage over time. Excellent for crowd control and grouping enemies.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct BlackSpiral {\n    pub center: Vec3,\n    pub pull_radius: f32,       // Radius within which enemies are pulled\n    pub pull_strength: f32,     // Force applied toward center\n    pub damage_rate: f32,       // Damage per second to enemies in radius\n    pub duration: Timer,\n    pub rotation_angle: f32,    // Current rotation for visual effect\n}\n```\n\n### Systems\n- `spawn_black_spiral` - Creates vortex entity at target location\n- `update_black_spiral` - Tick duration, update rotation angle for visual\n- `black_spiral_pull` - Apply pull force to enemies within radius\n- `black_spiral_damage` - Deal damage over time to enemies in radius\n- `cleanup_black_spiral` - Despawn vortex when duration expires\n\n### File Location\n`src/spells/dark/black_spiral.rs`\n\n## Visual Design\n- Swirling dark purple/black vortex effect\n- Rotating spiral arms of shadow energy\n- Particle effects being pulled into center\n- Dark ground distortion effect beneath vortex\n\n## Acceptance Criteria\n- [ ] BlackSpiral component with pull_radius, pull_strength, damage_rate, and duration\n- [ ] Vortex spawns at designated target location\n- [ ] Enemies within pull_radius are pulled toward center\n- [ ] Pull strength decreases with distance from center (or constant - design choice)\n- [ ] Enemies in radius take damage_rate damage per second\n- [ ] Visual vortex rotates continuously\n- [ ] Spell integrates with 5-slot active spell system\n\n## Required Tests\n- [ ] Test vortex spawns at correct location\n- [ ] Test enemies within radius are pulled toward center\n- [ ] Test enemies outside radius are unaffected\n- [ ] Test pull strength applies correct force\n- [ ] Test damage applies per second correctly\n- [ ] Test vortex expires after duration\n- [ ] Test multiple enemies can be pulled simultaneously\n- [ ] Test vortex cleanup removes all associated entities","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:18:52.299099+11:00","updated_at":"2026-01-02T09:48:52.367379+11:00","closed_at":"2026-01-02T09:48:52.367379+11:00","dependencies":[{"issue_id":"dt-survivor-0oz","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:18:58.978843+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-0ql","title":"Convert player and rock spawning from Sprite to Mesh3d cubes","description":"# Task: Player and Rock 3D Spawning\n\n## Context\nDT Survivor is migrating from 2D to 3D. The player and decorative rocks currently use `Sprite::from_color()` and need to be converted to 3D cube meshes. This task depends on GameMeshes/GameMaterials resources being available.\n\n## Current Implementation\n**Player** (`src/game/systems.rs:43-56`):\n```rust\ncommands.spawn((\n    Sprite::from_color(Color::srgb(0.0, 1.0, 0.0), Vec2::new(20.0, 20.0)),\n    Transform::from_translation(Vec3::new(0.0, 0.0, 1.0)),\n    Player { speed: 200.0, regen_rate: 1.0, pickup_radius: 50.0 },\n    Health::new(100.0),\n    PlayerExperience { current: 0, level: 1 },\n));\n```\n\n**Rocks** (`src/game/systems.rs:60-68`):\n```rust\ncommands.spawn((\n    Sprite::from_color(Color::srgb(0.5, 0.5, 0.5), Vec2::new(size, size)),\n    Transform::from_translation(Vec3::new(x, y, 0.0)),\n    Rock,\n));\n```\n\n## Required Changes\n\n### 1. Update Player Spawning\n```rust\ncommands.spawn((\n    Mesh3d(game_meshes.player.clone()),\n    MeshMaterial3d(game_materials.player.clone()),\n    Transform::from_translation(Vec3::new(0.0, 0.5, 0.0)), // Y=0.5 sits on ground\n    Player { speed: 200.0, regen_rate: 1.0, pickup_radius: 50.0 },\n    Health::new(100.0),\n    PlayerExperience { current: 0, level: 1 },\n));\n```\n\n### 2. Update Rock Spawning\n```rust\nfor _ in 0..15 {\n    let x = rng.gen_range(-40.0..40.0);  // Adjusted for 3D scale\n    let z = rng.gen_range(-30.0..30.0);  // Note: Y becomes Z\n    commands.spawn((\n        Mesh3d(game_meshes.rock.clone()),\n        MeshMaterial3d(game_materials.rock.clone()),\n        Transform::from_translation(Vec3::new(x, 0.25, z)), // Y=0.25 (half height)\n        Rock,\n    ));\n}\n```\n\n### 3. Update System Signature\nAdd resource parameters to access shared meshes/materials:\n```rust\npub fn setup_game(\n    mut commands: Commands,\n    camera_query: Query\u003cEntity, With\u003cCamera\u003e\u003e,\n    game_meshes: Res\u003cGameMeshes\u003e,\n    game_materials: Res\u003cGameMaterials\u003e,\n) { ... }\n```\n\n## Testing Requirements\n- Unit test: Player spawns with Mesh3d component\n- Unit test: Player spawns with MeshMaterial3d component\n- Unit test: Player transform Y position is 0.5 (sitting on ground)\n- Unit test: Rocks spawn with Mesh3d component\n- Unit test: Rocks spawn on XZ plane (Y=0.25)\n- Unit test: Rocks no longer use Z for layering\n- Update existing player spawn tests for 3D components\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] Player renders as green 3D cube\n- [ ] Player positioned at Y=0.5 (half cube height above ground)\n- [ ] Rocks render as grey 3D cubes\n- [ ] Rocks positioned on XZ plane with appropriate Y offset\n- [ ] Rock spawn range adjusted for 3D world scale\n- [ ] No Sprite components remain in player/rock spawning\n- [ ] All existing player tests updated and passing\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:46:31.034521+11:00","updated_at":"2025-12-28T10:07:49.036083+11:00","closed_at":"2025-12-28T10:07:49.036083+11:00","dependencies":[{"issue_id":"dt-survivor-0ql","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.307103+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-0ql","depends_on_id":"dt-survivor-ggr","type":"blocks","created_at":"2025-12-28T09:50:35.29717+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-0rl","title":"Create SpellType Enum with 64 Variants","description":"## Context\n\nPart of the spells system refactoring for dt-survivor. This defines all 64 spell types across the 8 elements (8 spells per element).\n\n## Implementation Details\n\n### SpellType Enum Definition\n- File: src/spell/spell_type.rs (new file)\n- 64 variants total, 8 per element\n- Each spell variant stores its metadata directly\n\n### Methods to Implement\n```rust\nimpl SpellType {\n    /// Unique identifier for the spell\n    pub fn id(\u0026self) -\u003e u32\n\n    /// Element this spell belongs to\n    pub fn element(\u0026self) -\u003e Element\n\n    /// Display name of the spell\n    pub fn name(\u0026self) -\u003e \u0026'static str\n\n    /// Flavor description text\n    pub fn description(\u0026self) -\u003e \u0026'static str\n\n    /// Base damage before modifiers\n    pub fn base_damage(\u0026self) -\u003e f32\n\n    /// Shots per second\n    pub fn fire_rate(\u0026self) -\u003e f32\n}\n```\n\n### Spell Organization by Element\nEach element has 8 spells. Reference the game design CSV for:\n- Fire spells: Fireball, Flame Lance, Inferno, etc.\n- Frost spells: Ice Shard, Blizzard, Frozen Ray, etc.\n- Poison spells: Venom Bolt, Plague Cloud, etc.\n- Lightning spells: Spark, Chain Lightning, etc.\n- Light spells: Holy Beam, Radiance, etc.\n- Dark spells: Shadow Bolt, Void Rift, etc.\n- Chaos spells: Wild Magic, Entropy, etc.\n- Psychic spells: Mind Blast, Telekinesis, etc.\n\n### Drop Rate Weighting\n- All spells have equal weight (1.0) for drop rate\n- Drop rate calculations handled elsewhere\n\n### Data Storage\n- All metadata stored in code, not external files\n- Use const arrays or match expressions for efficiency\n- No CSV parsing at runtime\n\n## ECS Patterns\n\n- Use `#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]`\n- Follow type-safe enum pattern from AGENTS.md\n- Export via spell module's mod.rs\n\n## Acceptance Criteria\n\n- [ ] SpellType enum with exactly 64 variants\n- [ ] 8 spells per element\n- [ ] id() returns unique identifier for each spell\n- [ ] element() returns correct Element for each spell\n- [ ] name() returns display name\n- [ ] description() returns flavor text\n- [ ] base_damage() returns damage value\n- [ ] fire_rate() returns shots per second\n- [ ] All metadata stored in code\n\n## Required Tests\n\n- Test all 64 variants exist (exhaustive match)\n- Test each spell returns correct element\n- Test id() returns unique values for each spell\n- Test metadata access (name, description, damage, fire_rate)\n- Test element grouping (8 spells per element)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-01T21:04:54.508536+11:00","updated_at":"2026-01-01T22:45:55.503067+11:00","closed_at":"2026-01-01T22:45:55.503067+11:00","dependencies":[{"issue_id":"dt-survivor-0rl","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:04:59.436613+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-0rl","depends_on_id":"dt-survivor-g0j","type":"blocks","created_at":"2026-01-01T21:07:31.306697+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-0rl","depends_on_id":"dt-survivor-2pj","type":"blocks","created_at":"2026-01-01T21:07:31.419162+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-0ty","title":"Implement Fracture Spell (Chaos)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Fracture\n- **Element**: Chaos\n- **Behavior**: Damage causes enemies to split into unstable fragments. On kill, the enemy splits into 2-3 smaller hostile fragments that are weaker versions of the original enemy.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct FractureEffect;  // Marker for enemies affected by fracture\n\n#[derive(Component)]\npub struct FracturedEnemy {\n    pub is_fragment: bool,\n    pub fragment_health: f32,\n    pub fragment_damage_multiplier: f32,\n    pub fragment_scale: f32,\n}\n```\n\n### Systems\n- `apply_fracture_effect` - Mark enemies hit by fracture spell\n- `fracture_on_death` - When marked enemy dies, spawn fragments\n- `spawn_fragment_enemies` - Create smaller enemy copies\n- `update_fragment_behavior` - Fragments have modified stats/behavior\n- `cleanup_fragments` - Fragments despawn after short lifetime or on death\n\n### File Location\n`src/spells/chaos/fracture.rs`\n\n## Visual Design\n- Fracture hit: magenta cracks appear on enemy\n- Death split: shattering effect with pink/purple energy\n- Fragments: smaller, glitchy versions of original enemy\n- Fragments have unstable flickering/distortion effect\n- Fragment death: smaller explosion, no further splitting\n\n## Acceptance Criteria\n- [ ] Fracture effect marks enemies when hit\n- [ ] Marked enemies split into 2-3 fragments on death\n- [ ] Fragments are visually smaller (scaled down)\n- [ ] Fragments have reduced health compared to original\n- [ ] Fragments deal reduced damage\n- [ ] Fragments cannot further fracture (no infinite splitting)\n- [ ] Fragment kills award XP and contribute to score\n\n## Required Tests\n- `test_fracture_marks_enemy_on_hit` - Effect application\n- `test_fractured_enemy_splits_on_death` - Split mechanic works\n- `test_fragment_count_is_random_2_to_3` - Correct number spawned\n- `test_fragment_has_reduced_health` - Stats are scaled\n- `test_fragment_has_reduced_damage` - Damage multiplier applied\n- `test_fragment_is_visually_smaller` - Scale is applied\n- `test_fragment_cannot_fracture_again` - No infinite recursion\n- `test_fragment_death_awards_xp` - Rewards work correctly","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:18:14.552488+11:00","updated_at":"2026-01-02T08:48:09.979976+11:00","closed_at":"2026-01-02T08:48:09.979976+11:00","dependencies":[{"issue_id":"dt-survivor-0ty","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:18:20.00535+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-1a7","title":"Create combat module structure","description":"Create src/combat/ module with mod.rs, components.rs, events.rs, systems.rs, plugin.rs. This is the foundation for unified combat handling. Files: src/combat/mod.rs (with re-exports), src/lib.rs (add pub mod combat).","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T17:40:28.385295+11:00","updated_at":"2025-12-25T17:55:30.171884+11:00","closed_at":"2025-12-25T17:55:30.171884+11:00","dependencies":[{"issue_id":"dt-survivor-1a7","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:40:45.617448+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-1ac","title":"Whisper 3D conversion blocked - document requirements","description":"The whisper module 3D conversion (dt-survivor-rfz) requires extensive changes:\n\n1. Remove bevy_lit 2D dependencies (PointLight2d -\u003e PointLight)\n2. Convert Mesh2d/MeshMaterial2d to Mesh3d/MeshMaterial3d\n3. Replace custom additive materials with StandardMaterial+emissive\n4. Convert XY coordinates to XZ for ground plane\n5. Update bevy_hanabi particle axes (Z-\u003eY)\n6. Update ~1800 lines of code and tests\n\nThis task should be done after other 3D conversions are complete to have working patterns to follow.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-28T10:40:41.14733+11:00","updated_at":"2025-12-28T10:41:47.946497+11:00","closed_at":"2025-12-28T10:41:47.946497+11:00","dependencies":[{"issue_id":"dt-survivor-1ac","depends_on_id":"dt-survivor-rfz","type":"discovered-from","created_at":"2025-12-28T10:40:41.148443+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-1br","title":"Create Attunement Selection Modal UI","description":"## Context\nPart of the spells system refactoring (epic: dt-survivor-jdd). When the player starts a new game, they must select their Whisper attunement element. This modal presents 8 element options in a circular arrangement.\n\n## Implementation Details\n\n### Files to Create\n- `src/ui/attunement.rs` - New module for attunement selection UI\n\n### State Flow\n1. Game starts → `GameState::AttunementSelect`\n2. Modal displays 8 element buttons\n3. Player clicks an element\n4. Set `WhisperAttunement.element` to selected element\n5. Transition to `GameState::InGame`\n\n### UI Layout\n- Full-screen dark semi-transparent overlay\n- 8 element buttons arranged in a circle (45° apart)\n- Each button contains:\n  - Element icon (or colored circle)\n  - Element color as background/border\n  - Element name text below icon\n  - Hover state: highlight/scale effect\n- Center text: \"Choose Your Attunement\"\n\n### ECS Components to Create\n```rust\n#[derive(Component)]\npub struct AttunementScreen;  // Root marker for cleanup\n\n#[derive(Component)]\npub struct AttunementOption {\n    pub element: Element,\n}\n\n#[derive(Component)]\npub struct AttunementOverlay;  // Dark background overlay\n```\n\n### Systems to Implement\n```rust\n// OnEnter(GameState::AttunementSelect)\npub fn setup_attunement_screen(mut commands: Commands, ...) { }\n\n// OnExit(GameState::AttunementSelect)\npub fn cleanup_attunement_screen(query: Query\u003cEntity, With\u003cAttunementScreen\u003e\u003e, mut commands: Commands) { }\n\n// Update, run_if(in_state(GameState::AttunementSelect))\npub fn handle_attunement_selection(\n    interaction_query: Query\u003c(\u0026Interaction, \u0026AttunementOption), Changed\u003cInteraction\u003e\u003e,\n    mut attunement: ResMut\u003cWhisperAttunement\u003e,\n    mut next_state: ResMut\u003cNextState\u003cGameState\u003e\u003e,\n) { }\n```\n\n### Bevy UI Patterns\n- Use `NodeBundle` with `position_type: Absolute` for overlay\n- Circular layout: calculate positions with sin/cos for 8 buttons\n- `Interaction` component for hover/click detection\n- `BackgroundColor` changes on hover\n\n## Acceptance Criteria\n- [ ] Screen spawns when entering AttunementSelect state\n- [ ] 8 element buttons visible in circular arrangement\n- [ ] Each button shows correct element color and name\n- [ ] Hover effect visible on button interaction\n- [ ] Clicking button sets WhisperAttunement.element\n- [ ] State transitions to InGame after selection\n- [ ] All entities cleaned up on state exit\n\n## Required Automated Tests\n- Test screen spawns correct number of buttons (8)\n- Test each button has correct Element variant\n- Test clicking button sets WhisperAttunement correctly\n- Test state transitions from AttunementSelect to InGame\n- Test cleanup removes all AttunementScreen entities","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-01T21:04:33.570514+11:00","updated_at":"2026-01-01T23:14:54.59261+11:00","closed_at":"2026-01-01T23:14:54.59261+11:00","dependencies":[{"issue_id":"dt-survivor-1br","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:04:38.715796+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-1j2","title":"Create movement systems","description":"Create src/movement/systems.rs with: apply_velocity (updates Transform from Velocity), apply_knockback (applies and decays knockback). Move player_movement from game/systems.rs, enemy_movement_system from enemies/systems.rs. Include tests.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T17:41:29.59513+11:00","updated_at":"2025-12-25T19:26:55.753582+11:00","closed_at":"2025-12-25T19:26:55.753582+11:00","dependencies":[{"issue_id":"dt-survivor-1j2","depends_on_id":"dt-survivor-e9f","type":"blocks","created_at":"2025-12-25T17:41:45.262226+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-1j2","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:41:45.958906+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-1qz","title":"Implement XP orb levels with value scaling and colors","description":"Add Level component to XP orbs with value scaling based on level. Higher level enemies drop higher level XP orbs.\n\n## Context\nCurrent XP orbs in src/loot/systems.rs spawn with ItemData::Experience and random value (5-15 XP). The ExperienceOrb component in src/experience/components.rs has a value field. Loot spawning reacts to EnemyDeathEvent.\n\n## Implementation\n\n### Updated Loot Drop System (src/loot/systems.rs)\n```rust\n/// XP value scaling by level\npub fn xp_value_for_level(level: u8) -\u003e u32 {\n    match level {\n        1 =\u003e 5,    // Common: 5 XP\n        2 =\u003e 15,   // Uncommon: 15 XP\n        3 =\u003e 35,   // Rare: 35 XP\n        4 =\u003e 75,   // Epic: 75 XP\n        _ =\u003e 150,  // Legendary: 150 XP\n    }\n}\n\n/// Determine XP orb level based on enemy level\nfn select_xp_level(enemy_level: u8, rng: \u0026mut impl Rng) -\u003e u8 {\n    // Higher enemy levels have better chance of dropping higher level orbs\n    // Enemy level acts as minimum possible orb level with chance for better\n    let base_level = enemy_level;\n    \n    // Roll for potential upgrade (20% chance per level above base, up to level 5)\n    let mut orb_level = base_level;\n    while orb_level \u003c 5 \u0026\u0026 rng.gen_bool(0.2) {\n        orb_level += 1;\n    }\n    orb_level\n}\n\npub fn loot_drop_system(\n    mut commands: Commands,\n    mut death_events: MessageReader\u003cEnemyDeathEvent\u003e,\n    enemy_query: Query\u003c\u0026Level, With\u003cEnemy\u003e\u003e,\n    xp_materials: Res\u003cXpOrbMaterials\u003e,\n    // ... other params ...\n) {\n    for event in death_events.read() {\n        let enemy_level = enemy_query.get(event.entity)\n            .map(|l| l.value())\n            .unwrap_or(1);\n        \n        // Spawn XP orbs\n        let orb_count = rng.gen_range(1..=3);\n        for i in 0..orb_count {\n            let orb_level = select_xp_level(enemy_level, \u0026mut rng);\n            let xp_value = xp_value_for_level(orb_level);\n            \n            commands.spawn((\n                DroppedItem {\n                    item_data: ItemData::Experience,\n                    // ... other fields ...\n                },\n                ExperienceOrb {\n                    value: xp_value,\n                    velocity: Vec2::ZERO,\n                },\n                Level::new(orb_level),\n                Mesh3d(game_meshes.xp_orb.clone()),\n                MeshMaterial3d(xp_materials.for_level(orb_level)),\n                // ... transform, etc ...\n            ));\n        }\n    }\n}\n```\n\n### XP Orb Materials Resource\n```rust\n/// Materials for each XP orb rarity level\n#[derive(Resource)]\npub struct XpOrbMaterials {\n    pub common: Handle\u003cStandardMaterial\u003e,      // Grey\n    pub uncommon: Handle\u003cStandardMaterial\u003e,    // Green\n    pub rare: Handle\u003cStandardMaterial\u003e,        // Blue\n    pub epic: Handle\u003cStandardMaterial\u003e,        // Purple\n    pub legendary: Handle\u003cStandardMaterial\u003e,   // Gold with emissive\n}\n\nimpl XpOrbMaterials {\n    pub fn new(materials: \u0026mut Assets\u003cStandardMaterial\u003e) -\u003e Self {\n        Self {\n            common: materials.add(StandardMaterial {\n                base_color: Color::srgb(0.6, 0.6, 0.6),\n                emissive: LinearRgba::new(0.6, 0.6, 0.6, 0.0) * 0.5,\n                ..default()\n            }),\n            uncommon: materials.add(StandardMaterial {\n                base_color: Color::srgb(0.0, 0.8, 0.2),\n                emissive: LinearRgba::new(0.0, 0.8, 0.2, 0.0) * 0.5,\n                ..default()\n            }),\n            rare: materials.add(StandardMaterial {\n                base_color: Color::srgb(0.2, 0.4, 1.0),\n                emissive: LinearRgba::new(0.2, 0.4, 1.0, 0.0) * 1.0,\n                ..default()\n            }),\n            epic: materials.add(StandardMaterial {\n                base_color: Color::srgb(0.6, 0.2, 0.8),\n                emissive: LinearRgba::new(0.6, 0.2, 0.8, 0.0) * 1.5,\n                ..default()\n            }),\n            legendary: materials.add(StandardMaterial {\n                base_color: Color::srgb(1.0, 0.84, 0.0),\n                emissive: LinearRgba::new(1.0, 0.84, 0.0, 0.0) * 3.0,\n                ..default()\n            }),\n        }\n    }\n\n    pub fn for_level(\u0026self, level: u8) -\u003e Handle\u003cStandardMaterial\u003e {\n        match level {\n            1 =\u003e self.common.clone(),\n            2 =\u003e self.uncommon.clone(),\n            3 =\u003e self.rare.clone(),\n            4 =\u003e self.epic.clone(),\n            _ =\u003e self.legendary.clone(),\n        }\n    }\n}\n```\n\n### Update Experience Orb Collection (src/experience/systems.rs)\n```rust\npub fn experience_orb_collection_system(\n    // ... existing params ...\n) {\n    for event in effect_events.read() {\n        if let ItemData::Experience = event.item_data {\n            // Value already set on ExperienceOrb component\n            // No changes needed to collection logic\n        }\n    }\n}\n```\n\n## XP Value Table\n| Level | Rarity    | XP Value | Enemy Level Drop Chance |\n|-------|-----------|----------|-------------------------|\n| 1     | Common    | 5        | All enemies             |\n| 2     | Uncommon  | 15       | Level 2+ enemies        |\n| 3     | Rare      | 35       | Level 3+ enemies        |\n| 4     | Epic      | 75       | Level 4+ enemies        |\n| 5     | Legendary | 150      | Level 5 enemies (+luck) |\n\n## ECS Pattern\n```rust\n// Query for XP orbs by level\nfn process_xp_orbs(\n    query: Query\u003c(\u0026Level, \u0026ExperienceOrb, \u0026Transform)\u003e,\n) {\n    for (level, orb, transform) in query.iter() {\n        // Level determines visual, orb.value determines XP gained\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] XP orbs spawn with Level component (1-5)\n- [ ] XP value scales with level (5, 15, 35, 75, 150)\n- [ ] Higher level enemies drop higher level orbs\n- [ ] XpOrbMaterials resource created with 5 distinct colors\n- [ ] Each orb level has appropriate emissive glow\n- [ ] Legendary orbs have strongest glow effect\n- [ ] Unit tests for xp_value_for_level function\n- [ ] Unit tests for select_xp_level probability\n\n## Test Requirements\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn xp_value_increases_with_level() {\n        assert_eq!(xp_value_for_level(1), 5);\n        assert_eq!(xp_value_for_level(2), 15);\n        assert_eq!(xp_value_for_level(5), 150);\n    }\n\n    #[test]\n    fn select_xp_level_respects_enemy_level_minimum() {\n        let mut rng = rand::thread_rng();\n        for _ in 0..100 {\n            let orb_level = select_xp_level(3, \u0026mut rng);\n            assert!(orb_level \u003e= 3); // Can't drop below enemy level\n        }\n    }\n}\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-30T09:42:58.202254+11:00","updated_at":"2025-12-30T11:10:03.131021+11:00","closed_at":"2025-12-30T11:10:03.131021+11:00","dependencies":[{"issue_id":"dt-survivor-1qz","depends_on_id":"dt-survivor-3l7","type":"blocks","created_at":"2025-12-30T09:45:07.190069+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-1qz","depends_on_id":"dt-survivor-wvj","type":"blocks","created_at":"2025-12-30T09:45:07.26487+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-1qz","depends_on_id":"dt-survivor-aiy","type":"parent-child","created_at":"2025-12-30T09:45:19.340073+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-1wg","title":"Create DamageEvent and DeathEvent","description":"Create combat events in src/combat/events.rs: DamageEvent { target: Entity, amount: f32, source: Option\u003cEntity\u003e }, DeathEvent { entity: Entity, position: Vec3, entity_type: EntityType }. Move existing EnemyDeathEvent logic to use these unified events.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T17:40:28.612206+11:00","updated_at":"2025-12-25T17:58:22.468784+11:00","closed_at":"2025-12-25T17:58:22.468784+11:00","dependencies":[{"issue_id":"dt-survivor-1wg","depends_on_id":"dt-survivor-1a7","type":"blocks","created_at":"2025-12-25T17:40:45.118858+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-1wg","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:40:45.776952+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-20o","title":"Implement Glacial Pulse Spell (Frost)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Glacial Pulse\n- **Element**: Frost\n- **Behavior**: A chilling wave that expands outward from the player, slowing and weakening enemies it hits. Similar to Fire Nova but with frost-themed debuff effects. Applies both Slowed (reduced movement) and Weakened (reduced damage output) debuffs to affected enemies.\n\n## ECS Implementation\n\n### Components to Create\n- `GlacialPulseWave { radius: f32, max_radius: f32, expansion_speed: f32 }` - The expanding wave entity\n- `SlowedDebuff { duration: f32, speed_multiplier: f32 }` - Shared debuff component (may already exist from Frostbolt)\n- `WeakenedDebuff { duration: f32, damage_multiplier: f32 }` - Reduces enemy damage output\n- `GlacialPulseHit` - Marker to track which enemies were already hit by this pulse\n\n### Systems Needed\n- `spawn_glacial_pulse` - Creates expanding wave centered on player position\n- `update_glacial_pulse` - Expands wave radius over time\n- `glacial_pulse_enemy_collision` - Detects enemies within wave radius, applies debuffs\n- `cleanup_glacial_pulse` - Despawns wave when max radius reached\n- `apply_weakened_debuff` - Reduces enemy damage output (shared system)\n- `tick_weakened_debuff` - Decrements duration and removes expired debuffs\n\n### File Location\n`src/spells/frost/glacial_pulse.rs`\n\n## Visual Design\n- Expanding ring of icy mist in ice blue/cyan color\n- Ice crystal particles along the wave edge\n- Frost floor texture briefly visible as wave passes\n- Enemies hit get frost overlay and visible \"weakened\" indicator\n\n## Acceptance Criteria\n- [ ] Glacial Pulse spawns at player position and expands outward\n- [ ] Wave expands at configured speed until max radius\n- [ ] Enemies hit by wave take configured damage\n- [ ] Slowed debuff is applied to enemies hit (reduced movement speed)\n- [ ] Weakened debuff is applied to enemies hit (reduced damage output)\n- [ ] Each enemy is only hit once per pulse (not continuously as wave expands)\n- [ ] Wave despawns after reaching max radius\n\n## Required Tests\n- [ ] Test glacial_pulse spawns at player position with correct initial radius\n- [ ] Test wave radius expands over time at configured speed\n- [ ] Test wave despawns when max_radius is reached\n- [ ] Test enemies within wave radius take damage\n- [ ] Test SlowedDebuff is applied to hit enemies\n- [ ] Test WeakenedDebuff is applied to hit enemies\n- [ ] Test enemy is only damaged once per pulse instance\n- [ ] Test debuffs have correct duration and multiplier values","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:11:15.413188+11:00","updated_at":"2026-01-02T02:11:21.327969+11:00","closed_at":"2026-01-02T02:11:21.327969+11:00","dependencies":[{"issue_id":"dt-survivor-20o","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:11:21.053835+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-27i","title":"Implement Inferno Pulse Spell (Fire)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Inferno Pulse\n- **Element**: Fire\n- **Behavior**: Periodic fiery shockwaves radiate from the caster. While equipped, automatically pulses every X seconds. Each pulse is a damage nova centered on the player, damaging all enemies within pulse radius.\n\n## ECS Implementation\n\n### Components\n- `InfernoPulse { pulse_timer: Timer, pulse_radius: f32, damage: f32 }` - Player component tracking pulse cooldown and stats\n- `InfernoPulseWave { radius: f32, max_radius: f32 }` - Visual-only expanding ring (similar to FireNova but instant damage)\n\n### Systems\n- `equip_inferno_pulse` - Adds InfernoPulse component to player when spell equipped\n- `tick_inferno_pulse` - Decrements pulse_timer, triggers pulse when ready\n- `trigger_inferno_pulse` - On timer complete: damages all enemies in radius, spawns visual wave, resets timer\n- `animate_pulse_wave` - Expands visual wave for feedback (no additional damage)\n- `unequip_inferno_pulse` - Removes InfernoPulse when spell unequipped\n\n### File Location\n`src/spells/fire/inferno_pulse.rs`\n\n## Visual Design\n- Instant orange-red circular shockwave expanding from player\n- Brief screen flash at pulse moment\n- Enemies hit show fire damage indicator\n- Subtle ground ripple effect at player feet between pulses (charging visual)\n\n## Acceptance Criteria\n- [ ] Pulse triggers automatically at configured interval\n- [ ] All enemies within pulse_radius take damage on pulse\n- [ ] Pulse is centered on current player position\n- [ ] Visual shockwave expands from player on pulse\n- [ ] Timer resets after each pulse\n- [ ] Spell deactivates cleanly when unequipped\n- [ ] No manual input required (passive/automatic)\n\n## Required Tests\n- `test_inferno_pulse_equipped` - Verify InfernoPulse added when spell equipped\n- `test_inferno_pulse_timer_ticks` - Verify timer counts down each frame\n- `test_inferno_pulse_triggers_on_timer` - Verify pulse fires when timer completes\n- `test_inferno_pulse_damages_enemies_in_radius` - Verify all nearby enemies take damage\n- `test_inferno_pulse_ignores_enemies_outside_radius` - Verify far enemies unaffected\n- `test_inferno_pulse_timer_resets` - Verify timer restarts after pulse\n- `test_inferno_pulse_unequipped` - Verify component removed on unequip\n- `test_inferno_pulse_visual_spawns` - Verify wave entity created on pulse","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:12:10.118824+11:00","updated_at":"2026-01-02T03:34:03.620514+11:00","closed_at":"2026-01-02T03:34:03.620514+11:00","dependencies":[{"issue_id":"dt-survivor-27i","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:12:15.903366+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-2pj","title":"Rename Weapon to Spell Components","description":"## Context\n\nPart of the spells system refactoring for dt-survivor. This renames the weapon system to the spell system to reflect the magical combat theme.\n\n## Implementation Details\n\n### Directory and File Changes\n- Rename `src/weapon/` directory to `src/spell/`\n- Update `lib.rs` to import `spell` module instead of `weapon`\n\n### Component Renames\n- `Weapon` component → `Spell` component\n- `WeaponType` enum → `SpellType` enum\n\n### New Fields on Spell Component\n- `element: Element` - The elemental type of the spell\n- `name: String` - Display name of the spell\n- `description: String` - Flavor text description\n\n### Import Updates Required\nAll files importing from `crate::weapon` must be updated:\n- src/pistol/\n- src/laser/\n- src/rocket_launcher/\n- src/bullets/\n- src/inventory/\n- src/loot/\n- src/ui/\n- src/game/\n- Any other modules referencing weapons\n\n### prelude.rs Updates\n- Remove `WeaponType` export\n- Add `SpellType` export\n- Add `Spell` component export\n\n## ECS Patterns\n\n- Follow existing component patterns in the codebase\n- Maintain plugin composition structure\n- Use `#[derive(Component)]` with appropriate traits\n\n## Acceptance Criteria\n\n- [ ] src/weapon/ renamed to src/spell/\n- [ ] Weapon component renamed to Spell with new fields\n- [ ] WeaponType enum renamed to SpellType\n- [ ] All imports updated across codebase\n- [ ] prelude.rs exports updated\n- [ ] All existing tests pass after rename\n- [ ] No references to 'weapon' remain (except git history)\n\n## Required Tests\n\n- Test Spell component creation with all fields\n- Test element field access\n- Test name and description field access\n- Verify existing weapon-related tests still pass under new names","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-01T21:04:30.281033+11:00","updated_at":"2026-01-01T22:23:00.251545+11:00","closed_at":"2026-01-01T22:23:00.251545+11:00","dependencies":[{"issue_id":"dt-survivor-2pj","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:04:36.265053+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-2pj","depends_on_id":"dt-survivor-g0j","type":"blocks","created_at":"2026-01-01T21:07:26.739585+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-30g","title":"Implement Dominate Spell (Psychic)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Dominate\n- **Element**: Psychic\n- **Behavior**: Temporarily turns enemies against each other. Target enemy becomes an ally for a brief duration, attacking other enemies before the effect wears off.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct DominateEffect {\n    pub range: f32,\n    pub duration: f32,\n}\n\n#[derive(Component)]\npub struct DominatedEnemy {\n    pub duration: Timer,\n    pub original_behavior: EnemyBehavior,  // Store to restore later\n}\n\n#[derive(Clone)]\npub struct EnemyBehavior {\n    pub target: TargetType,\n    pub aggression: f32,\n}\n```\n\n### Systems Needed\n1. `cast_dominate` - Find and dominate nearest enemy\n2. `update_dominated_enemies` - Track duration, handle attacks\n3. `dominated_enemy_targeting` - Override AI to attack other enemies\n4. `cleanup_dominate` - Restore original behavior when expired\n\n### File Location\n`src/spells/psychic/dominate.rs`\n\n## Visual Design\n- Dominated enemy has pink/magenta aura\n- Swirling violet mind-control particles around head\n- Eyes glow with psychic energy\n- Effect pulses faster as duration nears end\n\n## Acceptance Criteria\n- [ ] Dominate targets the nearest enemy within range\n- [ ] Dominated enemy stops attacking player\n- [ ] Dominated enemy attacks other enemies\n- [ ] Effect expires after configured duration\n- [ ] Original behavior restored after domination ends\n- [ ] Visual clearly indicates dominated state\n- [ ] Integrates with spell cooldown system\n\n## Required Tests\n1. `test_dominate_targets_nearest_enemy` - Verify targeting\n2. `test_dominated_enemy_ignores_player` - No player attacks\n3. `test_dominated_enemy_attacks_others` - Attacks other enemies\n4. `test_dominate_duration_expires` - Timer works correctly\n5. `test_dominate_restores_behavior` - Original state restored\n6. `test_dominate_no_valid_target` - Behavior with no enemies\n7. `test_dominate_range_limit` - Only affects enemies in range\n8. `test_dominated_enemy_damage_to_enemies` - Damage actually applied","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:16:54.58853+11:00","updated_at":"2026-01-02T06:45:54.829915+11:00","closed_at":"2026-01-02T06:45:54.829915+11:00","dependencies":[{"issue_id":"dt-survivor-30g","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:17:00.987372+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-3ji","title":"Create InventoryBag Resource (30 Slots)","description":"## Context\n\nPart of the spells system refactoring for dt-survivor. The InventoryBag provides 30 storage slots for spells that are not currently equipped in the active SpellList. Players can swap spells between the bag and active slots.\n\n## Implementation Details\n\n### File Location\n- Create: src/inventory/bag.rs (new file)\n- Update: src/inventory/mod.rs to export bag module\n\n### InventoryBag Struct\n```rust\nconst BAG_SIZE: usize = 30;\n\n#[derive(Resource)]\npub struct InventoryBag {\n    slots: [Option\u003cSpell\u003e; BAG_SIZE],\n}\n```\n\n### Methods to Implement\n```rust\nimpl InventoryBag {\n    /// Add spell to first empty slot, returns slot index or None if full\n    pub fn add(\u0026mut self, spell: Spell) -\u003e Option\u003cusize\u003e\n\n    /// Remove spell from specific slot, returns removed spell\n    pub fn remove(\u0026mut self, slot: usize) -\u003e Option\u003cSpell\u003e\n\n    /// Find slot containing specific spell type\n    pub fn find_spell(\u0026self, spell_type: SpellType) -\u003e Option\u003cusize\u003e\n\n    /// Get spell at slot (for leveling up)\n    pub fn get_spell(\u0026self, slot: usize) -\u003e Option\u003c\u0026Spell\u003e\n\n    /// Get mutable spell at slot (for leveling up)\n    pub fn get_spell_mut(\u0026mut self, slot: usize) -\u003e Option\u003c\u0026mut Spell\u003e\n\n    /// Check if bag is full (no empty slots)\n    pub fn is_full(\u0026self) -\u003e bool\n\n    /// Count of spells currently in bag\n    pub fn count(\u0026self) -\u003e usize\n\n    /// Find first empty slot\n    pub fn find_empty_slot(\u0026self) -\u003e Option\u003cusize\u003e\n\n    /// Iterate over all spells with their slot indices\n    pub fn iter(\u0026self) -\u003e impl Iterator\u003cItem = (usize, \u0026Spell)\u003e\n}\n\nimpl Default for InventoryBag {\n    fn default() -\u003e Self {\n        Self {\n            slots: [const { None }; BAG_SIZE],\n        }\n    }\n}\n```\n\n### Integration\n- InventoryBag works alongside SpellList\n- When SpellList is full, new pickups go to bag\n- UI will display bag contents in inventory screen\n\n## ECS Patterns\n\n- Use `#[derive(Resource)]` with manual Default impl\n- Follow resource pattern from other inventory resources\n- Register in inventory plugin\n\n## Acceptance Criteria\n\n- [ ] InventoryBag struct with 30 slots\n- [ ] add() finds empty slot and adds spell\n- [ ] remove() removes and returns spell from slot\n- [ ] find_spell() locates spell by type\n- [ ] get_spell() and get_spell_mut() for access\n- [ ] is_full() correctly detects no empty slots\n- [ ] count() returns number of spells\n- [ ] Registered as Resource in inventory plugin\n- [ ] Exported from inventory module\n\n## Required Tests\n\n- Test add to empty bag\n- Test add returns None when full (30 spells)\n- Test remove from valid slot\n- Test remove from empty slot returns None\n- Test find_spell positive case\n- Test find_spell negative case (spell not in bag)\n- Test is_full with 29 spells (not full)\n- Test is_full with 30 spells (full)\n- Test count accuracy\n- Test iter skips empty slots","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-01T21:05:44.568311+11:00","updated_at":"2026-01-01T22:29:32.604852+11:00","closed_at":"2026-01-01T22:29:32.604852+11:00","dependencies":[{"issue_id":"dt-survivor-3ji","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:05:50.278156+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-3ji","depends_on_id":"dt-survivor-2pj","type":"blocks","created_at":"2026-01-01T21:07:37.387143+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-3l7","title":"Create reusable Level component","description":"Create a generic Level component that can be attached to any entity requiring level tracking. This is the foundational building block for all progression systems.\n\n## Context\nCurrently the codebase uses composable components (Health, Damage, Speed, Velocity) that can be attached to multiple entity types. The Level component follows this pattern.\n\n## Implementation\n\n### Component Definition (src/game/components.rs or new src/level/components.rs)\n```rust\nuse bevy::prelude::*;\n\n/// Rarity tiers for game entities, matching the standard RPG color scheme\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]\npub enum Rarity {\n    #[default]\n    Common,    // Level 1 - Grey\n    Uncommon,  // Level 2 - Green\n    Rare,      // Level 3 - Blue\n    Epic,      // Level 4 - Purple\n    Legendary, // Level 5 - Gold\n}\n\nimpl Rarity {\n    pub fn from_level(level: u8) -\u003e Self {\n        match level {\n            1 =\u003e Rarity::Common,\n            2 =\u003e Rarity::Uncommon,\n            3 =\u003e Rarity::Rare,\n            4 =\u003e Rarity::Epic,\n            5.. =\u003e Rarity::Legendary,\n            _ =\u003e Rarity::Common,\n        }\n    }\n\n    pub fn color(\u0026self) -\u003e Color {\n        match self {\n            Rarity::Common =\u003e Color::srgb(0.6, 0.6, 0.6),     // Grey\n            Rarity::Uncommon =\u003e Color::srgb(0.0, 0.8, 0.2),  // Green\n            Rarity::Rare =\u003e Color::srgb(0.2, 0.4, 1.0),      // Blue\n            Rarity::Epic =\u003e Color::srgb(0.6, 0.2, 0.8),      // Purple\n            Rarity::Legendary =\u003e Color::srgb(1.0, 0.84, 0.0), // Gold\n        }\n    }\n}\n\n/// Level component for entities that have progression levels\n#[derive(Component, Debug, Clone, Copy, Default)]\npub struct Level(pub u8);\n\nimpl Level {\n    pub fn new(level: u8) -\u003e Self {\n        Self(level.max(1).min(5)) // Clamp between 1-5\n    }\n\n    pub fn value(\u0026self) -\u003e u8 {\n        self.0\n    }\n\n    pub fn rarity(\u0026self) -\u003e Rarity {\n        Rarity::from_level(self.0)\n    }\n\n    pub fn color(\u0026self) -\u003e Color {\n        self.rarity().color()\n    }\n}\n```\n\n### Prelude Export (src/prelude.rs)\nAdd Level and Rarity to prelude for easy access across modules.\n\n### ECS Usage Pattern\n```rust\n// Attach to entities at spawn time\ncommands.spawn((\n    Enemy::default(),\n    Health::new(10.0 * level as f32),\n    Level::new(level),\n    CheckDeath,\n));\n\n// Query entities by level\nfn scale_by_level(query: Query\u003c(\u0026Level, \u0026mut Health), With\u003cEnemy\u003e\u003e) {\n    for (level, mut health) in query.iter_mut() {\n        // Systems can use level.value() or level.rarity()\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] Level component clamps values between 1-5\n- [ ] Rarity enum maps levels to color scheme\n- [ ] Level and Rarity exported via prelude\n- [ ] Unit tests for Level::new clamping behavior\n- [ ] Unit tests for Rarity::from_level mapping\n- [ ] Unit tests for color() returning correct RGB values\n\n## Test Requirements\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn level_clamps_to_valid_range() {\n        assert_eq!(Level::new(0).value(), 1);\n        assert_eq!(Level::new(1).value(), 1);\n        assert_eq!(Level::new(5).value(), 5);\n        assert_eq!(Level::new(10).value(), 5);\n    }\n\n    #[test]\n    fn rarity_from_level_maps_correctly() {\n        assert_eq!(Rarity::from_level(1), Rarity::Common);\n        assert_eq!(Rarity::from_level(2), Rarity::Uncommon);\n        assert_eq!(Rarity::from_level(3), Rarity::Rare);\n        assert_eq!(Rarity::from_level(4), Rarity::Epic);\n        assert_eq!(Rarity::from_level(5), Rarity::Legendary);\n    }\n}\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-30T09:40:29.79888+11:00","updated_at":"2025-12-30T10:39:20.330029+11:00","closed_at":"2025-12-30T10:39:20.330029+11:00","dependencies":[{"issue_id":"dt-survivor-3l7","depends_on_id":"dt-survivor-aiy","type":"parent-child","created_at":"2025-12-30T09:45:18.982918+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-3y4","title":"Implement Fire Nova Spell (Fire)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Fire Nova\n- **Element**: Fire\n- **Behavior**: An expanding ring of flames erupts from the caster. Spawns at player position, expands outward in a circular pattern. Damages enemies as the ring passes through them.\n\n## ECS Implementation\n\n### Components\n- `FireNovaWave { radius: f32, max_radius: f32, expansion_rate: f32, damage: f32 }` - Core wave component tracking expansion state\n- `FireNovaVisual` - Marker for visual ring entity\n\n### Systems\n- `spawn_fire_nova` - Creates nova entity at player position when spell cast\n- `expand_fire_nova` - Updates radius each frame based on expansion_rate\n- `fire_nova_collision` - Checks for enemy hits as ring expands, applies damage\n- `cleanup_fire_nova` - Despawns when radius \u003e= max_radius\n\n### File Location\n`src/spells/fire/fire_nova.rs`\n\n## Visual Design\n- Orange-red expanding ring with flame particle effects along the edge\n- Intensity fades as ring expands outward\n- Brief flash at center on spawn\n\n## Acceptance Criteria\n- [ ] Fire Nova spawns centered on player position when cast\n- [ ] Ring expands outward at configured expansion_rate\n- [ ] Enemies take damage exactly once as the ring passes through them\n- [ ] Nova despawns automatically when reaching max_radius\n- [ ] Visual ring renders with fire-themed orange-red coloring\n- [ ] Spell integrates with 5-slot active spell system\n- [ ] Sound effect plays on cast\n\n## Required Tests\n- `test_fire_nova_spawns_at_player_position` - Verify nova spawns at correct location\n- `test_fire_nova_expands_over_time` - Verify radius increases each frame\n- `test_fire_nova_damages_enemy_on_pass` - Verify enemy takes damage when ring hits\n- `test_fire_nova_damages_enemy_only_once` - Verify no double-damage from same nova\n- `test_fire_nova_despawns_at_max_radius` - Verify cleanup when fully expanded\n- `test_fire_nova_respects_expansion_rate` - Verify expansion matches configured rate\n- `test_fire_nova_multiple_enemies` - Verify all enemies in path take damage","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:10:23.144642+11:00","updated_at":"2026-01-02T00:33:36.528319+11:00","closed_at":"2026-01-02T00:33:36.528319+11:00","dependencies":[{"issue_id":"dt-survivor-3y4","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:10:29.469037+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-3z7","title":"Create MovementPlugin","description":"Create src/movement/plugin.rs with MovementPlugin that registers systems with run_if(in_state(GameState::InGame)).in_set(GameSet::Movement). Update game/plugin.rs to delegate movement systems.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T17:41:29.704911+11:00","updated_at":"2025-12-25T19:29:18.168215+11:00","closed_at":"2025-12-25T19:29:18.168215+11:00","dependencies":[{"issue_id":"dt-survivor-3z7","depends_on_id":"dt-survivor-1j2","type":"blocks","created_at":"2025-12-25T17:41:45.36079+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-3z7","depends_on_id":"dt-survivor-7gg","type":"blocks","created_at":"2025-12-25T17:41:45.449523+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-3z7","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:41:46.047496+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-45y","title":"Run full test suite and fix regressions","description":"After all refactoring is complete, run cargo test to verify all tests pass. Run cargo clippy to fix any warnings. Ensure 90% code coverage is maintained. Fix any regressions introduced during refactoring.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T17:42:02.902028+11:00","updated_at":"2025-12-25T20:11:20.85134+11:00","closed_at":"2025-12-25T20:11:20.85134+11:00","dependencies":[{"issue_id":"dt-survivor-45y","depends_on_id":"dt-survivor-f77","type":"blocks","created_at":"2025-12-25T17:42:20.284677+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-45y","depends_on_id":"dt-survivor-70v","type":"blocks","created_at":"2025-12-25T17:42:20.363162+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-45y","depends_on_id":"dt-survivor-7gg","type":"blocks","created_at":"2025-12-25T17:42:20.446812+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-45y","depends_on_id":"dt-survivor-3z7","type":"blocks","created_at":"2025-12-25T17:42:20.531606+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-45y","depends_on_id":"dt-survivor-cch","type":"blocks","created_at":"2025-12-25T17:42:20.60702+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-45y","depends_on_id":"dt-survivor-8hu","type":"blocks","created_at":"2025-12-25T17:42:20.683525+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-45y","depends_on_id":"dt-survivor-6x9","type":"blocks","created_at":"2025-12-25T17:42:20.766376+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-45y","depends_on_id":"dt-survivor-8s7","type":"blocks","created_at":"2025-12-25T17:42:20.842823+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-45y","depends_on_id":"dt-survivor-ubg","type":"blocks","created_at":"2025-12-25T17:42:20.92369+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-45y","depends_on_id":"dt-survivor-7m0","type":"blocks","created_at":"2025-12-25T17:42:21.009282+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-45y","depends_on_id":"dt-survivor-d0t","type":"blocks","created_at":"2025-12-25T17:42:21.093144+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-45y","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:42:21.497406+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-49e","title":"Implement Mind Lash Spell (Psychic)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Mind Lash\n- **Element**: Psychic\n- **Behavior**: Psychic whip that damages enemies in a line. Projects a line attack in the direction of the nearest target, damaging all enemies caught in the line's path.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct MindLash {\n    pub start: Vec2,\n    pub end: Vec2,\n    pub width: f32,\n    pub damage: f32,\n}\n\n#[derive(Component)]\npub struct MindLashVisual {\n    pub lifetime: Timer,\n    pub fade_progress: f32,\n}\n```\n\n### Systems Needed\n1. `spawn_mind_lash` - Create lash entity toward nearest enemy\n2. `update_mind_lash_visual` - Handle fade animation\n3. `mind_lash_collision` - Detect and damage enemies in line\n4. `cleanup_mind_lash` - Remove expired lashes\n\n### File Location\n`src/spells/psychic/mind_lash.rs`\n\n## Visual Design\n- Pink/magenta energy whip extending from player\n- Pulsing violet glow along the lash length\n- Mind wave ripple effect on impact\n- Fades with transparency over lifetime\n\n## Acceptance Criteria\n- [ ] Mind Lash spawns as a line from player toward nearest enemy\n- [ ] All enemies within the line's width take damage\n- [ ] Damage is applied once per cast (not continuous)\n- [ ] Visual shows pink/magenta whip with violet glow\n- [ ] Lash fades out over its lifetime\n- [ ] Integrates with spell cooldown system\n- [ ] Works with 5-slot active spell system\n\n## Required Tests\n1. `test_mind_lash_spawns_toward_nearest_enemy` - Verify targeting\n2. `test_mind_lash_damages_enemies_in_line` - Multiple enemies hit\n3. `test_mind_lash_respects_width` - Enemies outside width unaffected\n4. `test_mind_lash_single_damage_application` - No double damage\n5. `test_mind_lash_cleanup_after_lifetime` - Entity removed\n6. `test_mind_lash_no_target_behavior` - Behavior when no enemies\n7. `test_mind_lash_cooldown_integration` - Spell system integration","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:16:08.487942+11:00","updated_at":"2026-01-02T05:39:46.039299+11:00","closed_at":"2026-01-02T05:39:46.039299+11:00","dependencies":[{"issue_id":"dt-survivor-49e","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:16:14.272568+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-4i1","title":"Update movement systems from XY to XZ plane","description":"# Task: Movement System XY→XZ Conversion\n\n## Context\nDT Survivor is migrating from 2D to 3D. All movement currently operates on the XY plane with Z used for layering. Movement must be converted to XZ plane with Y as the up axis (Bevy's default 3D coordinate system).\n\n## Current Implementation\n**Velocity Application** (`src/movement/systems.rs:10-15`):\n```rust\npub fn apply_velocity(mut query: Query\u003c(\u0026mut Transform, \u0026Velocity)\u003e, time: Res\u003cTime\u003e) {\n    for (mut transform, velocity) in query.iter_mut() {\n        let movement = velocity.value() * time.delta_secs();\n        transform.translation += movement.extend(0.0); // XY plane\n    }\n}\n```\n\n**Knockback** (`src/movement/systems.rs:19-37`): Uses Vec2 direction applied to XY\n\n**Enemy Movement** (`src/movement/systems.rs:84-100`):\n```rust\nlet direction = (player_pos - enemy_pos).normalize();\ntransform.translation += Vec3::new(direction.x, direction.y, 0.0) * speed * dt;\n```\n\n## Required Changes\n\n### 1. Create XZ Helper Function\nAdd to `src/movement/components.rs` or a new `utils.rs`:\n```rust\n/// Convert 2D vector to 3D XZ plane movement (Y=0)\npub fn to_xz(v: Vec2) -\u003e Vec3 {\n    Vec3::new(v.x, 0.0, v.y)\n}\n\n/// Extract XZ coordinates from 3D position as Vec2\npub fn from_xz(v: Vec3) -\u003e Vec2 {\n    Vec2::new(v.x, v.z)\n}\n```\n\n### 2. Update apply_velocity System\n```rust\npub fn apply_velocity(mut query: Query\u003c(\u0026mut Transform, \u0026Velocity)\u003e, time: Res\u003cTime\u003e) {\n    for (mut transform, velocity) in query.iter_mut() {\n        let movement = velocity.value() * time.delta_secs();\n        transform.translation += to_xz(movement); // XZ plane\n    }\n}\n```\n\n### 3. Update apply_knockback System\n```rust\n// Before\ntransform.translation += direction.extend(0.0) * force * dt;\n\n// After\ntransform.translation += to_xz(direction * force * dt);\n```\n\n### 4. Update enemy_movement_system\n```rust\npub fn enemy_movement_system(\n    mut query: Query\u003c(\u0026mut Transform, \u0026Enemy)\u003e,\n    player_position: Res\u003cPlayerPosition\u003e,\n    time: Res\u003cTime\u003e,\n) {\n    let player_pos = player_position.0; // Already Vec2, represents XZ\n    for (mut transform, enemy) in query.iter_mut() {\n        let enemy_pos = from_xz(transform.translation);\n        let direction = (player_pos - enemy_pos).normalize_or_zero();\n        transform.translation += to_xz(direction * enemy.speed * time.delta_secs());\n    }\n}\n```\n\n### 5. Update PlayerPosition Resource\nThe `PlayerPosition` resource stores `Vec2`. Ensure it represents XZ coordinates:\n```rust\n// When updating PlayerPosition\nplayer_position.0 = Vec2::new(player_transform.translation.x, player_transform.translation.z);\n```\n\n## Testing Requirements\n- Unit test: to_xz converts Vec2 to Vec3 with Y=0\n- Unit test: from_xz extracts X and Z as Vec2\n- Unit test: apply_velocity moves entities on XZ plane\n- Unit test: Entity Y position unchanged after velocity application\n- Unit test: apply_knockback works on XZ plane\n- Unit test: enemy_movement_system moves toward player on XZ\n- Unit test: PlayerPosition updated correctly\n- Update all existing movement tests\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] to_xz and from_xz helper functions implemented\n- [ ] apply_velocity system uses XZ plane\n- [ ] apply_knockback system uses XZ plane\n- [ ] enemy_movement_system chases player on XZ plane\n- [ ] Entity Y positions unchanged by movement systems\n- [ ] PlayerPosition resource stores XZ coordinates\n- [ ] All movement tests updated and passing\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:49:17.486913+11:00","updated_at":"2025-12-28T10:04:41.014515+11:00","closed_at":"2025-12-28T10:04:41.014515+11:00","dependencies":[{"issue_id":"dt-survivor-4i1","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.567746+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-4i1","depends_on_id":"dt-survivor-nq8","type":"blocks","created_at":"2025-12-28T09:50:36.792265+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-4oh","title":"Implement Brainburn Spell (Psychic)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Brainburn\n- **Element**: Psychic\n- **Behavior**: Damage over time that increases as enemies stay close. Creates an aura around the player; enemies within take DOT that ramps up the longer they remain, encouraging them to flee.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct BrainburnAura {\n    pub radius: f32,\n}\n\n#[derive(Component)]\npub struct BrainburnStack {\n    pub stacks: u32,\n    pub max_stacks: u32,\n    pub damage_per_stack: f32,\n    pub stack_timer: Timer,  // Time between stack applications\n}\n```\n\n### Systems Needed\n1. `spawn_brainburn_aura` - Create aura around player\n2. `update_brainburn_aura` - Follow player position\n3. `apply_brainburn_stacks` - Add stacks to enemies in range\n4. `tick_brainburn_damage` - Apply DOT based on stack count\n5. `decay_brainburn_stacks` - Remove stacks when enemies leave aura\n\n### File Location\n`src/spells/psychic/brainburn.rs`\n\n## Visual Design\n- Pink/magenta aura field around player\n- Affected enemies have violet smoke rising from head\n- Smoke intensity increases with stack count\n- Brain-pulse visual effect on stack application\n\n## Acceptance Criteria\n- [ ] Brainburn aura follows player position\n- [ ] Enemies entering aura gain stacks over time\n- [ ] Damage scales with number of stacks\n- [ ] Stacks decay when enemy leaves aura range\n- [ ] Visual intensity reflects stack count\n- [ ] Works with existing DOT/damage systems\n- [ ] Integrates with spell cooldown system\n\n## Required Tests\n1. `test_brainburn_aura_follows_player` - Aura moves with player\n2. `test_brainburn_applies_stacks` - Stacks accumulate in range\n3. `test_brainburn_damage_scales_with_stacks` - Damage increases\n4. `test_brainburn_stacks_decay_outside_aura` - Stacks decrease\n5. `test_brainburn_max_stacks_limit` - Cannot exceed max\n6. `test_brainburn_stack_timer` - Correct timing between stacks\n7. `test_brainburn_multiple_enemies` - Each tracked independently\n8. `test_brainburn_enemy_death_cleanup` - Stacks removed on death","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:17:19.619675+11:00","updated_at":"2026-01-02T07:25:44.43237+11:00","closed_at":"2026-01-02T07:25:44.43237+11:00","dependencies":[{"issue_id":"dt-survivor-4oh","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:17:24.962586+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-4ts","title":"Implement Toxic Glob Spell (Poison)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Toxic Glob\n- **Element**: Poison\n- **Behavior**: Slow-moving projectile that bursts into multiple poison pools. Large slow projectile travels toward enemies. On hit or timeout, spawns 3-5 poison puddles that persist and damage enemies.\n\n## ECS Implementation\n\n### Components\n- `ToxicGlobProjectile { speed: f32, lifetime: Timer, puddle_count: u32 }` - The slow-moving main projectile\n- `PoisonPuddle { radius: f32, duration: Timer, tick_damage: f32, tick_timer: Timer }` - Persistent poison pools spawned on burst\n\n### Systems\n- `spawn_toxic_glob` - Creates slow projectile on spell cast\n- `update_toxic_glob_movement` - Handles slow projectile travel\n- `toxic_glob_collision` - Detects enemy collision for early burst\n- `toxic_glob_burst` - Spawns multiple puddles on hit or timeout\n- `poison_puddle_damage_tick` - Applies DOT to enemies in puddles\n- `cleanup_poison_puddles` - Despawns expired puddles\n\n### File Location\n`src/spells/poison/toxic_glob.rs`\n\n## Visual Design\n- Glob: Large bubbling green sphere with dripping particles\n- Puddles: Ground-level green toxic pools with bubbling surface animation\n- Poison element uses green/toxic colors, bubble/drip particle effects\n\n## Acceptance Criteria\n- [ ] Projectile moves slowly toward target/direction\n- [ ] Projectile is visually larger than standard projectiles\n- [ ] On enemy hit, glob bursts immediately spawning puddles\n- [ ] On lifetime expiry, glob bursts spawning puddles\n- [ ] Puddles spawn in random spread pattern around burst point\n- [ ] Each puddle damages enemies independently\n- [ ] Puddles despawn after duration expires\n\n## Required Tests\n- `test_toxic_glob_spawns_on_cast` - Verify projectile creation\n- `test_toxic_glob_moves_slowly` - Verify slow movement speed\n- `test_toxic_glob_bursts_on_enemy_hit` - Verify collision trigger\n- `test_toxic_glob_bursts_on_timeout` - Verify lifetime trigger\n- `test_toxic_glob_spawns_correct_puddle_count` - Verify 3-5 puddles\n- `test_poison_puddle_damages_enemies` - Verify puddle DOT\n- `test_poison_puddle_despawns_after_duration` - Verify cleanup\n- `test_multiple_puddles_damage_independently` - Verify separate damage instances","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:11:12.161903+11:00","updated_at":"2026-01-02T02:01:12.626637+11:00","closed_at":"2026-01-02T02:01:12.626637+11:00","dependencies":[{"issue_id":"dt-survivor-4ts","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:11:17.260183+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-4w1","title":"Fix failing tests in bullets and game modules","description":"Six tests are currently failing: test_bullet_collision_detection, test_bullet_collision_no_collision (panic in run_main), and four tests in game::systems::tests related to player-enemy collision damage (test_player_enemy_collision_immediate_damage, test_player_enemy_collision_damage_cooldown, test_player_death_on_zero_health, test_damage_timer_reset_when_not_touching). These failures appear to be pre-existing issues with the collision/damage systems.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-25T18:04:53.402234+11:00","updated_at":"2025-12-25T18:17:15.454951+11:00","closed_at":"2025-12-25T18:17:15.454951+11:00"}
{"id":"dt-survivor-59e","title":"Implement Grim Tether Spell (Dark)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Grim Tether\n- **Element**: Dark\n- **Behavior**: Links enemies together sharing damage. Target 2 or more enemies to create dark tethers between them. When any linked enemy takes damage, a percentage of that damage is also applied to all other linked enemies.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct GrimTether {\n    pub linked_enemies: Vec\u003cEntity\u003e,\n    pub damage_share_percentage: f32,  // e.g., 0.5 = 50% damage shared\n    pub duration: Timer,\n}\n\n#[derive(Component)]\npub struct TetheredEnemy {\n    pub tether_entity: Entity,  // Reference to the GrimTether entity\n}\n```\n\n### Systems\n- `spawn_grim_tether` - Creates tether entity linking selected enemies\n- `update_grim_tether` - Tick duration timer, validate linked enemies still exist\n- `grim_tether_damage_share` - When tethered enemy takes damage, apply shared damage to others\n- `cleanup_grim_tether` - Remove tether when duration expires or too few enemies linked\n- `cleanup_tethered_enemy` - Remove TetheredEnemy component when tether despawns\n\n### File Location\n`src/spells/dark/grim_tether.rs`\n\n## Visual Design\n- Dark purple/black energy chains connecting linked enemies\n- Pulsing visual when damage is shared\n- Shadow particles along tether lines\n- Visual break effect when tether ends\n\n## Acceptance Criteria\n- [ ] GrimTether component tracks linked enemies and damage share percentage\n- [ ] TetheredEnemy marker component added to all linked enemies\n- [ ] Damage to one linked enemy propagates to all others\n- [ ] Shared damage is percentage of original damage\n- [ ] Tether breaks if only one enemy remains linked\n- [ ] Visual tether lines connect all linked enemies\n- [ ] Spell integrates with 5-slot active spell system\n\n## Required Tests\n- [ ] Test tether links two enemies correctly\n- [ ] Test tether links three or more enemies\n- [ ] Test damage to one enemy shares to others\n- [ ] Test damage share percentage calculated correctly\n- [ ] Test tether breaks when one enemy remains\n- [ ] Test tether duration expires correctly\n- [ ] Test dead enemy removed from linked list\n- [ ] Test shared damage does not trigger infinite loop (shared damage doesn't share again)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:18:05.172555+11:00","updated_at":"2026-01-02T08:18:53.871469+11:00","closed_at":"2026-01-02T08:18:53.871469+11:00","dependencies":[{"issue_id":"dt-survivor-59e","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:18:26.754968+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-5cj","title":"Implement Hoarfrost Spell (Frost)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Hoarfrost\n- **Element**: Frost\n- **Behavior**: Cold mist spreads around the player, creating an aura that reduces enemy speed while they remain inside. Unlike debuff-based slows, this is a continuous zone effect - enemies are slowed while in range and return to normal speed immediately upon leaving.\n\n## ECS Implementation\n\n### Components to Create\n- `HoarfrostAura { radius: f32, slow_multiplier: f32 }` - Attached to player, defines the aura\n- `InHoarfrost` - Marker component added to enemies currently in the aura\n- `HoarfrostActive` - Marker on player indicating aura is currently active\n\n### Systems Needed\n- `activate_hoarfrost` - Enables the aura on spell cast (toggle or duration-based)\n- `update_hoarfrost_aura` - Tracks which enemies are in range, adds/removes InHoarfrost marker\n- `apply_hoarfrost_slow` - Reduces speed of enemies with InHoarfrost marker\n- `deactivate_hoarfrost` - Removes aura when duration expires or toggled off\n- `cleanup_hoarfrost_markers` - Removes InHoarfrost from enemies when aura ends\n\n### File Location\n`src/spells/frost/hoarfrost.rs`\n\n## Visual Design\n- Circular cold mist effect centered on player in ice blue/cyan\n- Subtle ground frost texture within aura radius\n- Gentle ice particle drift within the aura\n- Enemies in range have light frost overlay effect\n\n## Acceptance Criteria\n- [ ] Hoarfrost creates an aura centered on player position\n- [ ] Aura follows player as they move\n- [ ] Enemies entering aura radius are immediately slowed\n- [ ] Enemies leaving aura radius immediately return to normal speed\n- [ ] Slow effect is configurable via slow_multiplier\n- [ ] Aura radius is visually displayed\n- [ ] Aura deactivates after duration or on toggle\n\n## Required Tests\n- [ ] Test HoarfrostAura component is added to player on cast\n- [ ] Test aura follows player position correctly\n- [ ] Test enemies within radius receive InHoarfrost marker\n- [ ] Test enemies outside radius do not have InHoarfrost marker\n- [ ] Test enemy speed is reduced while InHoarfrost is present\n- [ ] Test enemy speed normalizes when InHoarfrost is removed\n- [ ] Test InHoarfrost is removed when enemy exits aura radius\n- [ ] Test all InHoarfrost markers are cleaned up when aura ends","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:12:10.176953+11:00","updated_at":"2026-01-02T03:42:44.467909+11:00","closed_at":"2026-01-02T03:42:44.467909+11:00","dependencies":[{"issue_id":"dt-survivor-5cj","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:12:16.366264+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-5em","title":"Implement Arc Surge Spell (Lightning)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Arc Surge\n- **Element**: Lightning\n- **Behavior**: Periodic lightning bursts erupt from the caster. Automatic pulses while spell is equipped, each pulse hitting random enemies in range. Similar pattern to Inferno Pulse (Fire element).\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct ArcSurge {\n    pub pulse_timer: Timer,\n    pub pulse_range: f32,\n    pub targets_per_pulse: u8,\n    pub damage_per_target: f32,\n}\n\n#[derive(Component)]\npub struct ArcSurgeActive;  // Marker for equipped state\n```\n\n### Systems\n- `arc_surge_pulse` - Trigger pulse when timer fires\n- `arc_surge_target_selection` - Select random enemies in range\n- `arc_surge_damage` - Apply damage to selected targets\n- `arc_surge_visual` - Render lightning arcs from player to targets\n- `arc_surge_equip` - Add/remove ArcSurgeActive marker\n\n### File Location\n`src/spells/lightning/arc_surge.rs`\n\n## Visual Design\n- Lightning arcs radiate outward from player center\n- Yellow/electric blue bolts to each target\n- Brief bright flash at player on pulse\n- Crackling particle effects along arcs\n- Targets briefly flash when hit\n\n## Acceptance Criteria\n- [ ] Pulse timer triggers automatically while spell is equipped\n- [ ] Each pulse selects up to targets_per_pulse random enemies in range\n- [ ] Damage applies to all selected targets simultaneously\n- [ ] Visual arcs connect player to each target\n- [ ] Pulses stop when spell is unequipped\n- [ ] Timer resets properly between pulses\n- [ ] Works correctly with 0 enemies in range (no crash)\n\n## Required Tests\n- [ ] Test ArcSurge component initializes with correct timer\n- [ ] Test pulse_timer triggers at correct intervals\n- [ ] Test random target selection respects targets_per_pulse limit\n- [ ] Test targets must be within pulse_range\n- [ ] Test damage applies to all selected targets\n- [ ] Test no errors when fewer enemies than targets_per_pulse\n- [ ] Test no errors when zero enemies in range\n- [ ] Test ArcSurgeActive marker controls pulse behavior","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:11:08.900336+11:00","updated_at":"2026-01-02T01:53:53.173187+11:00","closed_at":"2026-01-02T01:53:53.173187+11:00","dependencies":[{"issue_id":"dt-survivor-5em","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:11:15.264538+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-62r","title":"Implement Halo Shield Spell (Light)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Halo Shield\n- **Element**: Light\n- **Behavior**: Protective aura that damages enemies on contact. Creates a glowing ring around the player that acts as a barrier. Enemies that touch the ring take damage on contact.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct HaloShield {\n    pub radius: f32,\n    pub damage_on_contact: f32,\n    pub duration: Timer,\n    pub hit_cooldown: Timer,  // Prevents rapid multi-hits on same enemy\n}\n\n#[derive(Component)]\npub struct HaloShieldHitCooldown {\n    pub cooldown: Timer,\n}\n```\n\n### Systems\n- `spawn_halo_shield` - Creates shield ring around player when spell activates\n- `update_halo_shield_position` - Keeps shield centered on player\n- `update_halo_shield_duration` - Ticks duration timer\n- `detect_halo_shield_contact` - Checks for enemies touching the ring\n- `apply_halo_shield_damage` - Damages enemies on ring contact\n- `manage_halo_hit_cooldowns` - Prevents same enemy being hit too rapidly\n- `cleanup_halo_shield` - Removes shield on duration expire or spell deactivation\n\n### File Location\n`src/spells/light/halo_shield.rs`\n\n## Visual Design\n- Bright golden ring floating at player height\n- Soft radiant glow around the ring\n- Sparkle/pulse effect when enemies contact the ring\n- Ring slightly rotates for visual interest\n- Intensity increases briefly on damage dealt\n\n## Acceptance Criteria\n- [ ] HaloShield creates visible ring around player\n- [ ] Ring radius is configurable\n- [ ] Enemies touching the ring take contact damage\n- [ ] Hit cooldown prevents rapid damage stacking\n- [ ] Shield follows player movement\n- [ ] Shield expires after duration or spell deactivation\n- [ ] Multiple enemies can be damaged simultaneously\n\n## Required Tests\n- [ ] Test shield spawns at correct radius around player\n- [ ] Test shield follows player position changes\n- [ ] Test enemy takes damage when touching shield ring\n- [ ] Test hit cooldown prevents immediate re-damage\n- [ ] Test enemy can be damaged again after cooldown expires\n- [ ] Test shield duration timer counts down correctly\n- [ ] Test shield despawns when duration expires\n- [ ] Test multiple enemies take damage from same shield","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:17:18.294454+11:00","updated_at":"2026-01-02T07:13:51.030856+11:00","closed_at":"2026-01-02T07:13:51.030856+11:00","dependencies":[{"issue_id":"dt-survivor-62r","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:17:24.11795+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-6hc","title":"Implement Ion Field Spell (Lightning)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Ion Field\n- **Element**: Lightning\n- **Behavior**: Creates a visible electric field zone that damages enemies while they remain inside. Persistent area denial spell with continuous damage over time to enemies within the field.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct IonField {\n    pub center: Vec3,\n    pub radius: f32,\n    pub duration: Timer,\n    pub damage_per_second: f32,\n    pub tick_timer: Timer,  // For applying damage ticks\n}\n\n#[derive(Component)]\npub struct IonFieldVisual {\n    pub pulse_phase: f32,\n}\n\n#[derive(Component)]\npub struct InIonField {\n    pub field_entity: Entity,\n}  // Marker for enemies inside\n```\n\n### Systems\n- `ion_field_spawn` - Create field at cast location\n- `ion_field_track_enemies` - Add/remove InIonField marker as enemies enter/exit\n- `ion_field_damage` - Apply damage ticks to enemies with InIonField marker\n- `ion_field_duration` - Despawn field when duration expires\n- `ion_field_visual` - Render crackling field boundary and interior\n\n### File Location\n`src/spells/lightning/ion_field.rs`\n\n## Visual Design\n- Circular boundary with crackling electric arcs\n- Semi-transparent yellow/electric blue fill\n- Interior has floating spark particles\n- Pulsing intensity effect\n- Enemies inside get electric crackling overlay\n- Fade out animation on expiry\n\n## Acceptance Criteria\n- [ ] Field spawns at player position or target location\n- [ ] Field remains stationary after spawn\n- [ ] Enemies inside field take continuous damage\n- [ ] Damage applies per tick (not per frame)\n- [ ] Enemies stop taking damage immediately when exiting\n- [ ] Field despawns when duration expires\n- [ ] Visual clearly shows field boundaries\n\n## Required Tests\n- [ ] Test field spawns with correct center and radius\n- [ ] Test enemy entering field receives InIonField marker\n- [ ] Test enemy exiting field loses InIonField marker\n- [ ] Test damage applies at tick_timer intervals\n- [ ] Test damage_per_second calculates correctly per tick\n- [ ] Test no damage when enemy outside field\n- [ ] Test duration timer despawns field\n- [ ] Test multiple enemies can be damaged simultaneously","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:12:14.640515+11:00","updated_at":"2026-01-02T03:49:54.677819+11:00","closed_at":"2026-01-02T03:49:54.677819+11:00","dependencies":[{"issue_id":"dt-survivor-6hc","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:12:19.094148+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-6q4","title":"Create movement module structure","description":"Create src/movement/ module with mod.rs, components.rs, systems.rs, plugin.rs. This consolidates movement logic from game and enemies modules. Add pub mod movement to lib.rs and movement_plugin to main.rs.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T17:41:29.367885+11:00","updated_at":"2025-12-25T19:11:47.207461+11:00","closed_at":"2025-12-25T19:11:47.207461+11:00","dependencies":[{"issue_id":"dt-survivor-6q4","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:41:45.790851+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-6rc","title":"Implement Solar Flare Spell (Light)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Solar Flare\n- **Element**: Light\n- **Behavior**: Bright explosion that damages and briefly blinds enemies. Can be a projectile that explodes on impact or an instant effect at target location. On hit, deals damage and applies a blinded debuff causing enemies to move randomly for a short duration.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct SolarFlareProjectile {\n    pub damage: f32,\n    pub explosion_radius: f32,\n    pub blind_duration: f32,\n}\n\n#[derive(Component)]\npub struct SolarFlareExplosion {\n    pub center: Vec2,\n    pub radius: f32,\n    pub damage: f32,\n}\n\n#[derive(Component)]\npub struct BlindedDebuff {\n    pub duration: Timer,\n}\n```\n\n### Systems\n- `spawn_solar_flare_projectile` - Fires projectile toward target/cursor\n- `update_solar_flare_movement` - Moves projectile toward target\n- `detect_solar_flare_impact` - Checks for collision with enemies or terrain\n- `spawn_solar_flare_explosion` - Creates explosion on impact\n- `apply_solar_flare_damage` - Damages enemies in explosion radius\n- `apply_blinded_debuff` - Adds BlindedDebuff to affected enemies\n- `update_blinded_movement` - Makes blinded enemies move randomly\n- `remove_blinded_debuff` - Removes debuff when timer expires\n\n### File Location\n`src/spells/light/solar_flare.rs`\n\n## Visual Design\n- Bright white/yellow projectile with trailing light particles\n- Intense flash effect on explosion\n- Radiant burst with expanding ring\n- Blinded enemies have stars/sparkles around their head\n- Screen flash effect (subtle) on explosion\n\n## Acceptance Criteria\n- [ ] Solar Flare projectile fires toward target direction\n- [ ] Projectile explodes on enemy contact or max range\n- [ ] Explosion deals damage to all enemies in radius\n- [ ] Blinded debuff applied to damaged enemies\n- [ ] Blinded enemies move in random directions\n- [ ] Blind duration is configurable and expires correctly\n- [ ] Visual effects clearly communicate the explosion and blind state\n\n## Required Tests\n- [ ] Test projectile spawns and moves in correct direction\n- [ ] Test explosion triggers on enemy collision\n- [ ] Test explosion triggers at max range\n- [ ] Test damage applies to all enemies in explosion radius\n- [ ] Test BlindedDebuff component added to affected enemies\n- [ ] Test blinded enemies have randomized movement direction\n- [ ] Test blind timer counts down and debuff removed on expire\n- [ ] Test enemies outside explosion radius not affected","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:16:53.917398+11:00","updated_at":"2026-01-02T06:32:30.551801+11:00","closed_at":"2026-01-02T06:32:30.551801+11:00","dependencies":[{"issue_id":"dt-survivor-6rc","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:17:00.512365+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-6tb","title":"Delete Legacy Weapon Modules","description":"## Context\n\nPart of the spells refactoring epic (dt-survivor-jdd). After all weapon-to-spell migrations are complete, the legacy weapon modules must be removed to eliminate dead code and prevent confusion.\n\n## Implementation Details\n\n### Directories to Remove\n- `src/pistol/` - after Fireball migration (dt-survivor-dwo)\n- `src/laser/` - after Radiant Beam migration (dt-survivor-gx4)\n- `src/rocket_launcher/` - after Thunder Strike migration (dt-survivor-att)\n\n### Evaluate for Removal/Refactoring\n- `src/bullets/` - assess if still needed\n  - If projectile logic is now in spells: DELETE\n  - If shared projectile components exist: REFACTOR to `src/projectiles/`\n  - Shared components might include: Projectile marker, ProjectileLifetime, ProjectileCollider\n\n### Module Declarations to Update\n- `src/lib.rs` - remove module declarations for deleted directories\n- `src/prelude.rs` - remove re-exports of deleted types\n- Update any plugin composition in `src/game/plugin.rs`\n\n### Dependency Cleanup\n- Remove any `use crate::pistol::*` imports\n- Remove any `use crate::laser::*` imports\n- Remove any `use crate::rocket_launcher::*` imports\n- Remove any `use crate::bullets::*` imports (if deleted)\n\n## Acceptance Criteria\n\n- [ ] `src/pistol/` directory deleted\n- [ ] `src/laser/` directory deleted\n- [ ] `src/rocket_launcher/` directory deleted\n- [ ] `src/bullets/` evaluated and deleted or refactored\n- [ ] `lib.rs` module declarations updated\n- [ ] `prelude.rs` re-exports updated\n- [ ] `game/plugin.rs` plugin imports updated\n- [ ] No orphan imports remain\n- [ ] Project compiles successfully\n- [ ] No dead code warnings from clippy\n- [ ] All existing tests pass\n\n## Required Tests\n\n1. **Compilation**: `cargo build` succeeds with no errors\n2. **No Dead Code**: `cargo clippy` reports no dead_code warnings for removed modules\n3. **No Orphan Imports**: No compilation errors from missing imports\n4. **Test Suite**: All existing tests pass (run `make test`)\n5. **Lint Clean**: `make lint` passes with no warnings\n\n## Dependencies\n\nThis issue MUST be completed AFTER:\n- dt-survivor-dwo (Fireball migration)\n- dt-survivor-gx4 (Radiant Beam migration)\n- dt-survivor-att (Thunder Strike migration)\n\nDo NOT delete modules until their replacement spells are fully functional and tested.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-01T21:05:21.319661+11:00","updated_at":"2026-01-01T23:58:25.217243+11:00","closed_at":"2026-01-01T23:58:25.217243+11:00","dependencies":[{"issue_id":"dt-survivor-6tb","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:05:47.659462+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-6tb","depends_on_id":"dt-survivor-dwo","type":"blocks","created_at":"2026-01-01T21:05:48.508774+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-6tb","depends_on_id":"dt-survivor-gx4","type":"blocks","created_at":"2026-01-01T21:05:49.585342+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-6tb","depends_on_id":"dt-survivor-att","type":"blocks","created_at":"2026-01-01T21:05:50.699768+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-6x9","title":"Centralize event registration","description":"Fix event registration redundancy. EnemyDeathEvent currently registered in game/plugin.rs, enemy_death/plugin.rs, and laser tests. Centralize: combat/plugin.rs owns DamageEvent/DeathEvent, game/plugin.rs owns collision events, loot/plugin.rs owns pickup events. Remove duplicates.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T17:41:30.051186+11:00","updated_at":"2025-12-25T19:46:30.827015+11:00","closed_at":"2025-12-25T19:46:30.827015+11:00","dependencies":[{"issue_id":"dt-survivor-6x9","depends_on_id":"dt-survivor-xp9","type":"blocks","created_at":"2025-12-25T17:41:45.611306+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-6x9","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:41:46.311655+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-6yd","title":"Implement Anomaly Spell (Chaos)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Anomaly\n- **Element**: Chaos\n- **Behavior**: Creates a zone with constantly shifting effects. The zone cycles through different damage types - fire, frost, poison, lightning - rotating the effect applied to enemies within.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct AnomalyZone {\n    pub center: Vec2,\n    pub radius: f32,\n    pub duration: Timer,\n    pub current_effect: AnomalyEffect,\n    pub effect_timer: Timer,\n    pub damage_per_tick: f32,\n    pub tick_timer: Timer,\n}\n\n#[derive(Clone, Copy, PartialEq)]\npub enum AnomalyEffect {\n    Fire,    // Burn damage over time\n    Frost,   // Slow + cold damage\n    Poison,  // Poison DOT\n    Lightning, // Burst damage + stun chance\n}\n```\n\n### Systems\n- `spawn_anomaly_zone` - Create zone at target location\n- `update_anomaly_effect_cycle` - Rotate through effects on timer\n- `anomaly_zone_damage` - Apply current effect's damage/debuff\n- `update_anomaly_timers` - Tick all timers\n- `cleanup_anomaly_zone` - Despawn when duration expires\n\n### File Location\n`src/spells/chaos/anomaly.rs`\n\n## Visual Design\n- Circular zone with shifting colors matching current effect\n- Fire: orange/red flames\n- Frost: blue/white ice crystals\n- Poison: green toxic bubbles\n- Lightning: yellow/white arcs\n- Transition effect: magenta/pink distortion between phases\n- Central instability core with chaotic energy\n\n## Acceptance Criteria\n- [ ] Anomaly zone spawns at target location\n- [ ] Zone cycles through all 4 effect types\n- [ ] Effect transition is visually clear\n- [ ] Each effect applies appropriate damage/debuff\n- [ ] Effect cycle time is configurable\n- [ ] Zone duration is separate from effect cycle\n- [ ] All enemies in zone affected by current effect\n\n## Required Tests\n- `test_anomaly_zone_spawns_at_location` - Position verification\n- `test_anomaly_zone_has_correct_radius` - Size validation\n- `test_anomaly_cycles_through_effects` - All effects are used\n- `test_anomaly_fire_effect_burns` - Fire damage works\n- `test_anomaly_frost_effect_slows` - Frost debuff works\n- `test_anomaly_poison_effect_dots` - Poison DOT works\n- `test_anomaly_lightning_effect_stuns` - Lightning stun works\n- `test_anomaly_duration_expires` - Zone cleanup","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:19:03.878592+11:00","updated_at":"2026-01-02T09:58:49.783049+11:00","closed_at":"2026-01-02T09:58:49.783049+11:00","dependencies":[{"issue_id":"dt-survivor-6yd","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:19:09.788094+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-6zt","title":"Implement enemy damage flash effect","description":"Add a white flash visual effect when enemies take damage, providing clear feedback that damage was dealt.\n\n## Context\nThe codebase already has a screen tint system for player damage (ScreenTintEffect). A similar pattern can be used for enemy damage flash. The combat system uses DamageEvent and apply_damage_system in src/combat/systems.rs.\n\n## Implementation\n\n### Component Definition (src/combat/components.rs)\n```rust\n/// Visual flash effect when entity takes damage\n#[derive(Component)]\npub struct DamageFlash {\n    /// Timer for flash duration\n    pub timer: Timer,\n    /// Original material handle to restore\n    pub original_material: Handle\u003cStandardMaterial\u003e,\n}\n\nimpl DamageFlash {\n    pub fn new(original_material: Handle\u003cStandardMaterial\u003e, duration: f32) -\u003e Self {\n        Self {\n            timer: Timer::from_seconds(duration, TimerMode::Once),\n            original_material,\n        }\n    }\n}\n```\n\n### Flash Material Resource (src/game/resources.rs)\n```rust\n/// Shared material for damage flash effect\n#[derive(Resource)]\npub struct DamageFlashMaterial(pub Handle\u003cStandardMaterial\u003e);\n\n// Create in setup_game_assets\nfn setup_game_assets(\n    mut commands: Commands,\n    mut materials: ResMut\u003cAssets\u003cStandardMaterial\u003e\u003e,\n) {\n    let flash_material = materials.add(StandardMaterial {\n        base_color: Color::WHITE,\n        emissive: LinearRgba::WHITE * 3.0,\n        ..default()\n    });\n    commands.insert_resource(DamageFlashMaterial(flash_material));\n}\n```\n\n### System Implementation (src/combat/systems.rs)\n```rust\n/// Apply flash effect when damage is dealt to enemies\npub fn apply_damage_flash_system(\n    mut commands: Commands,\n    mut damage_events: MessageReader\u003cDamageEvent\u003e,\n    enemy_query: Query\u003c(Entity, \u0026MeshMaterial3d\u003cStandardMaterial\u003e), (With\u003cEnemy\u003e, Without\u003cDamageFlash\u003e)\u003e,\n    flash_material: Res\u003cDamageFlashMaterial\u003e,\n) {\n    for event in damage_events.read() {\n        if let Ok((entity, current_material)) = enemy_query.get(event.target) {\n            // Store original and apply flash\n            commands.entity(entity).insert((\n                DamageFlash::new(current_material.0.clone(), 0.1),\n                MeshMaterial3d(flash_material.0.clone()),\n            ));\n        }\n    }\n}\n\n/// Update flash timers and restore original materials\npub fn update_damage_flash_system(\n    mut commands: Commands,\n    time: Res\u003cTime\u003e,\n    mut query: Query\u003c(Entity, \u0026mut DamageFlash, \u0026mut MeshMaterial3d\u003cStandardMaterial\u003e)\u003e,\n) {\n    for (entity, mut flash, mut material) in query.iter_mut() {\n        flash.timer.tick(time.delta());\n        \n        if flash.timer.finished() {\n            // Restore original material and remove flash component\n            material.0 = flash.original_material.clone();\n            commands.entity(entity).remove::\u003cDamageFlash\u003e();\n        }\n    }\n}\n```\n\n### System Registration (src/combat/plugin.rs)\n```rust\napp.add_systems(\n    Update,\n    (\n        apply_damage_flash_system,\n        update_damage_flash_system,\n    )\n        .chain()\n        .in_set(GameSet::Effects)\n        .run_if(in_state(GameState::InGame)),\n);\n```\n\n## ECS Pattern\n- DamageFlash is a marker+data component that opts entities into the flash system\n- Systems react to DamageEvent (event-driven)\n- Component stores state (original material) for cleanup\n- Material reference swapping for visual effect\n\n## Visual Behavior\n1. Enemy takes damage (DamageEvent fired)\n2. apply_damage_flash_system replaces material with white emissive\n3. update_damage_flash_system ticks timer\n4. After 0.1 seconds, original material restored\n5. Flash can re-trigger on subsequent damage\n\n## Acceptance Criteria\n- [ ] DamageFlash component stores original material and timer\n- [ ] DamageFlashMaterial resource created with white emissive material\n- [ ] Enemies flash white for 0.1 seconds when taking damage\n- [ ] Original material correctly restored after flash\n- [ ] Flash can trigger multiple times on same enemy\n- [ ] No flash applied to entities without Enemy component\n- [ ] Unit tests for DamageFlash timer behavior\n\n## Test Requirements\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn damage_flash_timer_starts_correctly() {\n        let flash = DamageFlash::new(Handle::default(), 0.1);\n        assert!(!flash.timer.finished());\n        assert_eq!(flash.timer.duration().as_secs_f32(), 0.1);\n    }\n}\n```","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-30T09:42:24.837742+11:00","updated_at":"2025-12-30T11:22:21.287471+11:00","closed_at":"2025-12-30T11:22:21.287471+11:00","dependencies":[{"issue_id":"dt-survivor-6zt","depends_on_id":"dt-survivor-wvj","type":"blocks","created_at":"2025-12-30T09:45:07.110029+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-6zt","depends_on_id":"dt-survivor-aiy","type":"parent-child","created_at":"2025-12-30T09:45:19.266457+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-70v","title":"Extract Player health to Health component","description":"Refactor src/player/components.rs: remove health, max_health from Player struct. Modify player spawn to attach separate Health component. Update player_health_regeneration_system and damage systems to use Health component. Keeps regen_rate in Player.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T17:40:29.062224+11:00","updated_at":"2025-12-25T18:52:17.946578+11:00","closed_at":"2025-12-25T18:52:17.946578+11:00","dependencies":[{"issue_id":"dt-survivor-70v","depends_on_id":"dt-survivor-xp9","type":"blocks","created_at":"2025-12-25T17:40:45.536817+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-70v","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:40:46.097014+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-78g","title":"Fix failing integration tests in main.rs due to missing ActivePowerups resource","description":"Eight integration tests in main.rs are failing because the ActivePowerups resource is not initialized. Tests failing: test_weapon_firing_spawns_bullets, test_scoring_integration_full_flow, test_scoring_integration_multiple_enemies, test_scoring_integration_score_persistence, test_weapon_equipped_to_player, test_weapon_slots_ui_created, test_no_blank_screen_during_transitions, test_camera_reuse_across_state_transitions. The system donny_tango_survivor::loot::systems::apply_item_effects requires ResMut\u003cActivePowerups\u003e but the resource doesn't exist in the test app context.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-25T18:17:08.650091+11:00","updated_at":"2025-12-25T18:20:50.690287+11:00","closed_at":"2025-12-25T18:20:50.690287+11:00","dependencies":[{"issue_id":"dt-survivor-78g","depends_on_id":"dt-survivor-4w1","type":"discovered-from","created_at":"2025-12-25T18:17:08.652038+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-7ac","title":"Implement Static Orb Spell (Lightning)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Static Orb\n- **Element**: Lightning\n- **Behavior**: Stationary orb crackles with electricity, periodically zapping the nearest enemy within range. Orb remains at cast location for its duration.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct StaticOrb {\n    pub zap_timer: Timer,\n    pub zap_range: f32,\n    pub duration: Timer,\n    pub damage_per_zap: f32,\n}\n\n#[derive(Component)]\npub struct StaticOrbVisual {\n    pub crackle_phase: f32,  // For animation\n}\n```\n\n### Systems\n- `spawn_static_orb` - Create orb at cast location\n- `static_orb_zap` - Find and damage nearest enemy each tick\n- `static_orb_duration` - Track lifetime and despawn when expired\n- `static_orb_visual` - Animate crackling electricity effect\n- `static_orb_cleanup` - Remove orb components on expiry\n\n### File Location\n`src/spells/lightning/static_orb.rs`\n\n## Visual Design\n- Spherical orb with yellow/electric blue core\n- Crackling lightning tendrils around surface\n- Bright zap line when attacking enemy\n- Pulsing glow that intensifies on zap\n- Fade out effect when duration expires\n\n## Acceptance Criteria\n- [ ] Orb spawns at player's current position when cast\n- [ ] Orb remains stationary (does not follow player)\n- [ ] Periodically zaps nearest enemy within zap_range\n- [ ] Zap applies damage to target enemy\n- [ ] Orb despawns when duration timer expires\n- [ ] Visual clearly shows zap connections to targets\n- [ ] Multiple orbs can exist simultaneously\n\n## Required Tests\n- [ ] Test orb spawns at correct position with all components\n- [ ] Test orb position remains constant after spawn\n- [ ] Test zap_timer triggers damage at correct intervals\n- [ ] Test zap targets nearest enemy only\n- [ ] Test no zap occurs when no enemies in range\n- [ ] Test duration timer despawns orb correctly\n- [ ] Test multiple orbs operate independently\n- [ ] Test damage_per_zap applies correctly to enemies","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:10:47.885017+11:00","updated_at":"2026-01-02T01:12:41.178853+11:00","closed_at":"2026-01-02T01:12:41.178853+11:00","dependencies":[{"issue_id":"dt-survivor-7ac","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:10:52.554951+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-7ch","title":"Implement Cinder Shot Spell (Fire)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Cinder Shot\n- **Element**: Fire\n- **Behavior**: Fast piercing fire projectile that weakens enemies it hits. Piercing means it passes through enemies without stopping. Applies a Weakened debuff causing enemies to take increased damage from all sources.\n\n## ECS Implementation\n\n### Components\n- `CinderShotProjectile { speed: f32, damage: f32, piercing: bool }` - Core projectile component\n- `WeakenedDebuff { duration: f32, damage_multiplier: f32 }` - Debuff applied to hit enemies\n- `CinderShotHitList(HashSet\u003cEntity\u003e)` - Tracks which enemies this projectile has already hit (prevents double-hit)\n\n### Systems\n- `spawn_cinder_shot` - Creates projectile aimed at nearest enemy or cursor direction\n- `move_cinder_shot` - Applies velocity each frame\n- `cinder_shot_collision` - Detects enemy hits, applies damage and WeakenedDebuff\n- `apply_weakened_damage_modifier` - Multiplies incoming damage for entities with WeakenedDebuff\n- `tick_weakened_debuff` - Decrements duration, removes when expired\n- `cleanup_cinder_shot` - Despawns when off-screen\n\n### File Location\n`src/spells/fire/cinder_shot.rs`\n\n## Visual Design\n- Slim, fast-moving orange-red projectile with ember trail\n- Glowing hot tip with sparks trailing behind\n- Weakened enemies get a subtle red glow overlay\n\n## Acceptance Criteria\n- [ ] Cinder Shot fires as fast projectile toward target direction\n- [ ] Projectile pierces through enemies (doesn't stop on hit)\n- [ ] Each enemy hit receives damage and WeakenedDebuff\n- [ ] WeakenedDebuff increases damage taken by configured multiplier\n- [ ] Debuff expires after duration, removing damage increase\n- [ ] Same enemy cannot be hit twice by same projectile\n- [ ] Projectile despawns when leaving play area\n\n## Required Tests\n- `test_cinder_shot_spawns_with_velocity` - Verify projectile has correct speed/direction\n- `test_cinder_shot_pierces_enemies` - Verify projectile continues after hitting enemy\n- `test_cinder_shot_applies_damage` - Verify enemy takes damage on hit\n- `test_cinder_shot_applies_weakened_debuff` - Verify debuff added to hit enemy\n- `test_weakened_debuff_increases_damage_taken` - Verify damage multiplier works\n- `test_weakened_debuff_expires` - Verify debuff removed after duration\n- `test_cinder_shot_no_double_hit` - Verify enemy hit only once per projectile\n- `test_cinder_shot_despawns_offscreen` - Verify cleanup when leaving bounds","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:10:49.25179+11:00","updated_at":"2026-01-02T01:38:39.311696+11:00","closed_at":"2026-01-02T01:38:39.311696+11:00","dependencies":[{"issue_id":"dt-survivor-7ch","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:10:54.745825+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-7gg","title":"Configure SystemSet ordering in plugin","description":"Update src/game/plugin.rs to configure set ordering: app.configure_sets(Update, (GameSet::Input, GameSet::Movement, GameSet::Combat, GameSet::Spawning, GameSet::Effects, GameSet::Cleanup).chain()). Assign existing systems to appropriate sets using .in_set().","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T17:41:02.078328+11:00","updated_at":"2025-12-25T19:03:36.681675+11:00","closed_at":"2025-12-25T19:03:36.681675+11:00","dependencies":[{"issue_id":"dt-survivor-7gg","depends_on_id":"dt-survivor-bem","type":"blocks","created_at":"2025-12-25T17:41:10.264016+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-7gg","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:41:10.503212+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-7ju","title":"Create SpellList Resource (5 Active Slots)","description":"## Context\n\nPart of the spells system refactoring for dt-survivor. The SpellList replaces the current Inventory HashMap with a fixed-size array of 5 active spell slots that the player can use in combat.\n\n## Implementation Details\n\n### File Location\n- Modify: src/inventory/resources.rs\n\n### SpellList Struct\n```rust\n#[derive(Resource, Default)]\npub struct SpellList {\n    slots: [Option\u003cSpell\u003e; 5],\n}\n```\n\n### Methods to Implement\n```rust\nimpl SpellList {\n    /// Equip spell to first empty slot, returns slot index or None if full\n    pub fn equip(\u0026mut self, spell: Spell) -\u003e Option\u003cusize\u003e\n\n    /// Find first empty slot index\n    pub fn find_empty_slot(\u0026self) -\u003e Option\u003cusize\u003e\n\n    /// Check if specific spell type is already equipped\n    pub fn has_spell(\u0026self, spell_type: SpellType) -\u003e bool\n\n    /// Get spell at specific slot (0-4)\n    pub fn get_spell(\u0026self, slot: usize) -\u003e Option\u003c\u0026Spell\u003e\n\n    /// Get mutable spell at specific slot for leveling up\n    pub fn get_spell_mut(\u0026mut self, slot: usize) -\u003e Option\u003c\u0026mut Spell\u003e\n\n    /// Iterate over all equipped spells\n    pub fn iter_spells(\u0026self) -\u003e impl Iterator\u003cItem = (usize, \u0026Spell)\u003e\n\n    /// Find slot containing specific spell type\n    pub fn find_spell_slot(\u0026self, spell_type: SpellType) -\u003e Option\u003cusize\u003e\n\n    /// Remove spell from slot, returns removed spell\n    pub fn remove(\u0026mut self, slot: usize) -\u003e Option\u003cSpell\u003e\n}\n```\n\n### Migration from Inventory\n- Remove or deprecate existing Inventory HashMap usage for weapons\n- SpellList is the new authoritative source for active spells\n- Update systems that read from Inventory to use SpellList\n\n## ECS Patterns\n\n- Use `#[derive(Resource, Default)]`\n- Follow resource pattern from game/resources.rs\n- Register in inventory plugin\n\n## Acceptance Criteria\n\n- [ ] SpellList struct defined with 5 slots\n- [ ] equip() adds spell to first empty slot\n- [ ] find_empty_slot() returns correct index\n- [ ] has_spell() correctly checks for spell type\n- [ ] get_spell() returns spell at slot\n- [ ] get_spell_mut() allows leveling up spells\n- [ ] iter_spells() iterates equipped spells with indices\n- [ ] find_spell_slot() finds existing spell by type\n- [ ] remove() removes and returns spell\n- [ ] Registered as Resource in plugin\n\n## Required Tests\n\n- Test equip to empty SpellList\n- Test equip returns None when full (5 spells)\n- Test find_empty_slot with partial fill\n- Test has_spell positive and negative cases\n- Test get_spell bounds checking (0-4 valid, 5+ returns None)\n- Test get_spell_mut for leveling\n- Test iter_spells with mixed empty/filled slots\n- Test find_spell_slot\n- Test remove returns spell and clears slot","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-01T21:05:18.735471+11:00","updated_at":"2026-01-01T22:27:15.347138+11:00","closed_at":"2026-01-01T22:27:15.347138+11:00","dependencies":[{"issue_id":"dt-survivor-7ju","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:05:23.815487+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-7ju","depends_on_id":"dt-survivor-2pj","type":"blocks","created_at":"2026-01-01T21:07:37.286767+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-7m0","title":"Use WeaponType enum in UI components","description":"Update src/ui/components.rs: change WeaponIcon { weapon_type: String } to WeaponIcon { weapon_type: WeaponType }. Same for WeaponLevelDisplay. Update UI systems to use enum matching instead of string comparison. Improves type safety.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-25T17:42:02.620929+11:00","updated_at":"2025-12-25T20:06:53.533998+11:00","closed_at":"2025-12-25T20:06:53.533998+11:00","dependencies":[{"issue_id":"dt-survivor-7m0","depends_on_id":"dt-survivor-cch","type":"blocks","created_at":"2025-12-25T17:42:20.034756+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-7m0","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:42:21.337279+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-7ox","title":"Reduce spell fire rates by 50%","description":"Lower fire rate of all spells by 50% from current values. Fire rates are defined in SpellType::fire_rate() method.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-02T11:45:21.390844+11:00","updated_at":"2026-01-02T11:50:00.459961+11:00","closed_at":"2026-01-02T11:50:00.459961+11:00"}
{"id":"dt-survivor-7qq","title":"Implement Mind Cage Spell (Psychic)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Mind Cage\n- **Element**: Psychic\n- **Behavior**: Traps enemies in a psychic field. Creates a zone that prevents enemies from leaving. Enemies inside the cage cannot exit until the cage expires, allowing the player to control the battlefield.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct MindCage {\n    pub center: Vec2,\n    pub radius: f32,\n    pub duration: Timer,\n}\n\n#[derive(Component)]\npub struct CagedEnemy {\n    pub cage_entity: Entity,\n}\n```\n\n### Systems Needed\n1. `spawn_mind_cage` - Create cage zone at target location\n2. `update_mind_cage` - Track duration\n3. `apply_cage_constraint` - Prevent enemies from leaving\n4. `cleanup_mind_cage` - Remove cage and constraints when expired\n\n### File Location\n`src/spells/psychic/mind_cage.rs`\n\n## Visual Design\n- Translucent pink/magenta dome or barrier\n- Violet energy patterns along the cage edge\n- Mind-ripple effect when enemies hit the boundary\n- Cage flickers and fades as duration nears end\n\n## Acceptance Criteria\n- [ ] Mind Cage spawns at target location\n- [ ] Enemies inside cannot move outside the radius\n- [ ] Enemies outside are not affected by the cage\n- [ ] Cage expires after configured duration\n- [ ] Enemies are freed when cage expires\n- [ ] Visual clearly shows cage boundaries\n- [ ] Integrates with spell cooldown system\n\n## Required Tests\n1. `test_mind_cage_spawns_at_location` - Correct placement\n2. `test_mind_cage_traps_enemies_inside` - Cannot leave\n3. `test_mind_cage_allows_enemies_outside` - External unaffected\n4. `test_mind_cage_duration_expires` - Timer works\n5. `test_mind_cage_frees_enemies_on_expire` - Constraints removed\n6. `test_mind_cage_boundary_collision` - Edge behavior\n7. `test_mind_cage_multiple_enemies` - All tracked\n8. `test_caged_enemy_movement_restricted` - Movement clamped","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:18:28.207824+11:00","updated_at":"2026-01-02T08:57:48.327108+11:00","closed_at":"2026-01-02T08:57:48.327108+11:00","dependencies":[{"issue_id":"dt-survivor-7qq","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:18:33.416632+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-7v3","title":"Implement Frostbolt Spell (Frost)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Frostbolt\n- **Element**: Frost\n- **Behavior**: A straight frost projectile that slows enemies on hit. Basic projectile spell that applies the Slowed debuff to enemies, reducing their movement speed for a duration.\n\n## ECS Implementation\n\n### Components to Create\n- `FrostboltProjectile` - Marker component for the projectile entity\n- `SlowedDebuff { duration: f32, speed_multiplier: f32 }` - Debuff applied to enemies (shared across Frost spells)\n\n### Systems Needed\n- `spawn_frostbolt` - Creates projectile entity when spell is cast\n- `update_frostbolt_movement` - Moves projectile in straight line toward target direction\n- `frostbolt_enemy_collision` - Detects collision with enemies, applies damage and Slowed debuff\n- `cleanup_frostbolt` - Despawns projectile after max range or collision\n- `apply_slowed_debuff` - Reduces enemy speed based on debuff (shared system)\n- `tick_slowed_debuff` - Decrements duration and removes expired debuffs\n\n### File Location\n`src/spells/frost/frostbolt.rs`\n\n## Visual Design\n- Ice blue/cyan colored projectile with trailing ice crystal particles\n- Frost mist trail effect behind projectile\n- On-hit: burst of ice particles on enemy\n- Slowed enemies have visible frost/ice overlay effect\n\n## Acceptance Criteria\n- [ ] Frostbolt fires in a straight line toward target direction\n- [ ] Projectile travels at configured speed and despawns at max range\n- [ ] Collision with enemy deals configured damage\n- [ ] Slowed debuff is applied on hit with configurable duration and speed reduction\n- [ ] Slowed enemies have reduced movement speed\n- [ ] Debuff expires after duration and enemy speed returns to normal\n- [ ] Visual effects display correctly for projectile and slowed enemies\n\n## Required Tests\n- [ ] Test frostbolt spawns with correct components when spell is cast\n- [ ] Test frostbolt moves in correct direction at configured speed\n- [ ] Test frostbolt despawns after reaching max range\n- [ ] Test frostbolt despawns on enemy collision\n- [ ] Test enemy takes correct damage on frostbolt hit\n- [ ] Test SlowedDebuff is applied to enemy on hit\n- [ ] Test enemy speed is reduced while SlowedDebuff is active\n- [ ] Test SlowedDebuff expires after duration and speed normalizes","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:10:25.67299+11:00","updated_at":"2026-01-02T01:04:37.566684+11:00","closed_at":"2026-01-02T01:04:37.566684+11:00","dependencies":[{"issue_id":"dt-survivor-7v3","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:10:31.094665+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-870","title":"Implement Nightfall Spell (Dark)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Nightfall\n- **Element**: Dark\n- **Behavior**: Area darkens increasing dark damage dealt. Creates a zone at a target location where darkness intensifies. All Dark element spells deal bonus damage to enemies within the Nightfall zone.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct NightfallZone {\n    pub center: Vec3,\n    pub radius: f32,\n    pub duration: Timer,\n    pub dark_damage_multiplier: f32,  // e.g., 1.5 = 50% bonus dark damage\n}\n```\n\n### Systems\n- `spawn_nightfall_zone` - Creates zone entity at target location\n- `update_nightfall_zone` - Tick duration timer\n- `apply_nightfall_bonus` - Check if dark spell damage occurs inside zone, apply multiplier\n- `cleanup_nightfall_zone` - Despawn zone when duration expires\n\n### File Location\n`src/spells/dark/nightfall.rs`\n\n## Visual Design\n- Dark circular zone with swirling shadows\n- Deep purple/black ground effect with moving tendrils\n- Darker ambient lighting within zone boundaries\n- Subtle pulsing darkness at zone edge\n\n## Acceptance Criteria\n- [ ] NightfallZone component stores center, radius, duration, and multiplier\n- [ ] Zone spawns at designated target location\n- [ ] Dark element spells deal bonus damage to enemies in zone\n- [ ] Non-dark element spells unaffected by zone\n- [ ] Zone persists for configured duration\n- [ ] Zone visual clearly indicates affected area\n- [ ] Spell integrates with 5-slot active spell system\n\n## Required Tests\n- [ ] Test zone spawns at correct target location\n- [ ] Test dark spell damage multiplied for enemies in zone\n- [ ] Test non-dark spell damage unaffected by zone\n- [ ] Test enemies partially in zone only affected when inside\n- [ ] Test zone expires after duration\n- [ ] Test multiple nightfall zones can stack (additive or multiplicative - design choice)\n- [ ] Test zone cleanup removes all associated entities\n- [ ] Test multiplier correctly applied to all dark spells","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:17:09.993479+11:00","updated_at":"2026-01-02T07:05:31.82782+11:00","closed_at":"2026-01-02T07:05:31.82782+11:00","dependencies":[{"issue_id":"dt-survivor-870","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:17:37.809405+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-8af","title":"Debug test_weapon_equipped_to_player failure after whisper 3D conversion","description":"When converting whisper module to 3D, the main.rs integration test test_weapon_equipped_to_player fails with 'Should have no weapon entities until Whisper is collected' (left: 1, right: 0). The failure is caused by changes in systems.rs but the exact cause was not identified. Need to investigate what in the whisper systems changes causes a Weapon entity to be spawned during game initialization.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-28T11:01:11.085495+11:00","updated_at":"2025-12-28T11:16:37.74246+11:00","closed_at":"2025-12-28T11:16:37.74246+11:00","dependencies":[{"issue_id":"dt-survivor-8af","depends_on_id":"dt-survivor-rfz","type":"blocks","created_at":"2025-12-28T11:01:11.086002+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-8ck","title":"Implement Warp Rift Spell (Chaos)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Warp Rift\n- **Element**: Chaos\n- **Behavior**: Tears space, pulling enemies toward the center. Creates a rift at target location with strong gravitational pull effect on enemies. Enemies at the center take damage.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct WarpRift {\n    pub center: Vec2,\n    pub pull_radius: f32,\n    pub damage_radius: f32,\n    pub pull_strength: f32,\n    pub duration: Timer,\n    pub damage_per_tick: f32,\n    pub tick_timer: Timer,\n}\n```\n\n### Systems\n- `spawn_warp_rift` - Create rift at target location\n- `warp_rift_pull` - Apply pull force to enemies within pull_radius\n- `warp_rift_damage` - Damage enemies within damage_radius (center)\n- `update_warp_rift` - Tick timers\n- `cleanup_warp_rift` - Despawn when duration expires\n\n### File Location\n`src/spells/chaos/warp_rift.rs`\n\n## Visual Design\n- Central tear in space with swirling magenta/pink vortex\n- Distortion lines spiraling toward center\n- Glitchy visual artifacts at the edges\n- Pulsing damage zone at center with intense glow\n- Space-warping shader effect around the rift\n- Particles being sucked into the center\n\n## Acceptance Criteria\n- [ ] Warp Rift spawns at target location\n- [ ] Enemies within pull_radius are pulled toward center\n- [ ] Pull strength falls off with distance from center\n- [ ] Enemies in damage_radius take periodic damage\n- [ ] Duration is configurable and expires correctly\n- [ ] Visual clearly shows pull zone vs damage zone\n- [ ] Enemies can escape if pull_strength \u003c their speed\n\n## Required Tests\n- `test_warp_rift_spawns_at_correct_location` - Position verification\n- `test_warp_rift_pulls_enemies_in_range` - Pull effect works\n- `test_warp_rift_pull_strength_scales_with_distance` - Falloff check\n- `test_warp_rift_damages_enemies_at_center` - Damage zone works\n- `test_warp_rift_does_not_pull_outside_radius` - Boundary check\n- `test_warp_rift_duration_expires` - Timer cleanup\n- `test_warp_rift_despawns_after_duration` - Entity removal\n- `test_fast_enemies_can_escape_pull` - Speed vs pull balance","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:17:48.37263+11:00","updated_at":"2026-01-02T08:07:50.564424+11:00","closed_at":"2026-01-02T08:07:50.564424+11:00","dependencies":[{"issue_id":"dt-survivor-8ck","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:17:54.000917+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-8hu","title":"Complete loot module migration","description":"Remove legacy code from loot module: delete LootItem component, remove loot_spawning_system, loot_attraction_system, loot_movement_system. Keep new ECS-based systems: detect_pickup_collisions, update_item_attraction, apply_item_effects. Update loot/plugin.rs registrations.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T17:41:29.937241+11:00","updated_at":"2025-12-25T19:42:41.321373+11:00","closed_at":"2025-12-25T19:42:41.321373+11:00","dependencies":[{"issue_id":"dt-survivor-8hu","depends_on_id":"dt-survivor-f77","type":"blocks","created_at":"2025-12-25T17:41:45.704476+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-8hu","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:41:46.214775+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-8i6","title":"Convert rocket launcher and explosions to 3D","description":"# Task: Rocket Launcher 3D Conversion\n\n## Context\nDT Survivor is migrating from 2D to 3D. The rocket launcher fires rockets that explode on impact, both rendered as sprites. These need to be converted to 3D geometry.\n\n## Current Implementation\n**Rocket Spawning** (`src/rocket_launcher/systems.rs`):\n- Rockets use `Sprite::from_color()` with color-changing animation\n- Size: 12x6 pixels (elongated for rocket shape)\n- Direction-based rotation\n- Velocity on XY plane\n\n**Explosion Effect**:\n- Expanding circle sprite\n- Red/orange color\n- Damages enemies within radius\n\n## Required Changes\n\n### 1. Replace Rocket Sprite with 3D Mesh\n```rust\n// Before\ncommands.spawn((\n    Sprite::from_color(color, Vec2::new(12.0, 6.0)),\n    Transform { rotation, translation, .. },\n    Rocket { ... },\n));\n\n// After\ncommands.spawn((\n    Mesh3d(meshes.add(Cuboid::new(0.3, 0.15, 0.6))), // Elongated cube\n    MeshMaterial3d(materials.add(StandardMaterial {\n        base_color: Color::srgb(1.0, 0.5, 0.0), // Orange\n        emissive: LinearRgba::rgb(1.0, 0.3, 0.0),\n        ..default()\n    })),\n    Transform {\n        translation: Vec3::new(player_pos.x, 0.5, player_pos.z),\n        rotation: rotation_y,\n        ..default()\n    },\n    Rocket { direction, speed, lifetime },\n));\n```\n\n### 2. Update Rocket Movement\nConvert from XY to XZ plane:\n```rust\n// Before\ntransform.translation += rocket.direction.extend(0.0) * speed * dt;\n\n// After\nlet movement = rocket.direction * speed * dt;\ntransform.translation += Vec3::new(movement.x, 0.0, movement.y);\n```\n\n### 3. Update Rocket Rotation\nRotate around Y axis to face direction of travel:\n```rust\nlet angle = rocket.direction.y.atan2(rocket.direction.x);\ntransform.rotation = Quat::from_rotation_y(-angle + std::f32::consts::FRAC_PI_2);\n```\n\n### 4. Replace Explosion Sprite with 3D Effect\nOption A: Expanding sphere mesh\n```rust\ncommands.spawn((\n    Mesh3d(meshes.add(Sphere::new(0.1))),\n    MeshMaterial3d(materials.add(StandardMaterial {\n        base_color: Color::srgba(1.0, 0.3, 0.0, 0.8),\n        emissive: LinearRgba::rgb(2.0, 0.5, 0.0),\n        alpha_mode: AlphaMode::Blend,\n        ..default()\n    })),\n    Transform::from_translation(explosion_pos),\n    Explosion { radius: 0.0, max_radius: 3.0, expansion_rate: 10.0 },\n));\n```\n\nOption B: Particle burst (more dramatic)\n```rust\n// Use bevy_hanabi for explosion particles\n// Orange/red burst expanding outward\n```\n\n### 5. Update Explosion Expansion\n```rust\nfn expand_explosions(\n    mut query: Query\u003c(\u0026mut Transform, \u0026mut Explosion)\u003e,\n    time: Res\u003cTime\u003e,\n) {\n    for (mut transform, mut explosion) in query.iter_mut() {\n        explosion.radius += explosion.expansion_rate * time.delta_secs();\n        let scale = explosion.radius / explosion.max_radius;\n        transform.scale = Vec3::splat(explosion.max_radius * scale);\n        \n        if explosion.radius \u003e= explosion.max_radius {\n            // Despawn or fade out\n        }\n    }\n}\n```\n\n### 6. Update Rocket Targeting\nDirection calculation to nearest enemy:\n```rust\nlet rocket_xz = Vec2::new(rocket_pos.x, rocket_pos.z);\nlet enemy_xz = Vec2::new(enemy_pos.x, enemy_pos.z);\nlet direction = (enemy_xz - rocket_xz).normalize();\n```\n\n## Testing Requirements\n- Unit test: Rocket spawns with Mesh3d component\n- Unit test: Rocket movement on XZ plane\n- Unit test: Rocket rotation faces movement direction\n- Unit test: Explosion spawns on rocket impact\n- Unit test: Explosion expands correctly\n- Unit test: Explosion damages enemies in radius\n- Unit test: Explosion radius check uses XZ coordinates\n- Update existing rocket tests for 3D\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] Rockets render as 3D elongated cubes\n- [ ] Rockets move on XZ plane\n- [ ] Rockets rotate to face direction\n- [ ] Explosions render as 3D spheres or particles\n- [ ] Explosion expansion works in 3D\n- [ ] Explosion damage radius works on XZ plane\n- [ ] No Sprite components in rocket/explosion\n- [ ] All rocket tests updated and passing\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:49:22.269968+11:00","updated_at":"2025-12-28T10:44:36.700489+11:00","closed_at":"2025-12-28T10:44:36.700489+11:00","dependencies":[{"issue_id":"dt-survivor-8i6","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.964123+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-8i6","depends_on_id":"dt-survivor-ggr","type":"blocks","created_at":"2025-12-28T09:50:35.626564+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-8mr","title":"Implement Poison Cloud Spell (Poison)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Poison Cloud\n- **Element**: Poison\n- **Behavior**: Arcing projectile that creates a lingering toxic cloud. The projectile arcs to a target location, and on impact creates a poison cloud zone that damages enemies over time.\n\n## ECS Implementation\n\n### Components\n- `PoisonCloudProjectile` - Marks the arcing projectile, tracks arc trajectory\n- `PoisonCloudZone { radius: f32, duration: Timer, tick_damage: f32, tick_timer: Timer }` - The lingering cloud that damages enemies\n\n### Systems\n- `spawn_poison_cloud_projectile` - Creates arcing projectile on spell cast\n- `update_poison_cloud_arc` - Handles arc trajectory movement\n- `spawn_poison_cloud_on_impact` - Creates cloud zone when projectile lands\n- `poison_cloud_damage_tick` - Applies DOT to enemies in cloud\n- `cleanup_poison_cloud` - Despawns expired clouds\n\n### File Location\n`src/spells/poison/poison_cloud.rs`\n\n## Visual Design\n- Projectile: Green glowing orb with trailing toxic particles\n- Cloud: Semi-transparent green/purple fog with bubble particles rising\n- Poison element uses green/toxic colors, bubble/drip particle effects\n\n## Acceptance Criteria\n- [ ] Projectile arcs correctly to target location using parabolic trajectory\n- [ ] Cloud spawns at impact point with correct radius\n- [ ] Enemies in cloud take poison DOT at configured tick rate\n- [ ] Cloud visual effects clearly communicate danger zone\n- [ ] Cloud despawns after duration expires\n- [ ] Multiple clouds can exist simultaneously\n- [ ] Projectile uses SpellDamage component for base damage scaling\n\n## Required Tests\n- `test_poison_cloud_projectile_spawns_on_cast` - Verify projectile creation\n- `test_poison_cloud_arc_reaches_target` - Verify arc trajectory math\n- `test_poison_cloud_zone_spawns_on_impact` - Verify cloud creation at landing\n- `test_poison_cloud_damages_enemies_in_radius` - Verify DOT application\n- `test_poison_cloud_no_damage_outside_radius` - Verify radius boundary\n- `test_poison_cloud_tick_rate_correct` - Verify damage timing\n- `test_poison_cloud_despawns_after_duration` - Verify cleanup\n- `test_multiple_poison_clouds_independent` - Verify multiple clouds work","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:10:25.150106+11:00","updated_at":"2026-01-02T00:48:01.337205+11:00","closed_at":"2026-01-02T00:48:01.337205+11:00","dependencies":[{"issue_id":"dt-survivor-8mr","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:10:30.2964+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-8n0","title":"Implement Lightbringer Spell (Light)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Lightbringer\n- **Element**: Light\n- **Behavior**: Pulsing radiant energy damages enemies in range. Creates an aura around the player that periodically pulses outward, dealing damage to all enemies within the pulse radius. Constant effect while the spell is active.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct LightbringerAura {\n    pub pulse_timer: Timer,\n    pub pulse_radius: f32,\n    pub damage: f32,\n}\n```\n\n### Systems\n- `spawn_lightbringer_aura` - Creates the aura component on the player when spell activates\n- `update_lightbringer_pulses` - Ticks timer and triggers damage pulses\n- `apply_lightbringer_damage` - Damages all enemies within pulse radius\n- `cleanup_lightbringer_aura` - Removes aura when spell deactivates\n\n### File Location\n`src/spells/light/lightbringer.rs`\n\n## Visual Design\n- White/gold pulsing ring emanating from player\n- Radiant glow effect on pulse\n- Expanding wave visual on each pulse tick\n- Subtle ambient glow around player between pulses\n\n## Acceptance Criteria\n- [ ] LightbringerAura component tracks pulse timing and damage stats\n- [ ] Pulse timer triggers damage at configurable intervals\n- [ ] All enemies within pulse_radius take damage on each pulse\n- [ ] Visual pulse effect expands outward from player\n- [ ] Aura persists while spell is in active slot\n- [ ] Proper cleanup when spell is removed from active slots\n- [ ] Damage scales with spell level/upgrades\n\n## Required Tests\n- [ ] Test aura spawns correctly when spell activates\n- [ ] Test pulse timer advances with delta time\n- [ ] Test damage applies to enemies within radius\n- [ ] Test enemies outside radius are not damaged\n- [ ] Test multiple enemies hit by single pulse\n- [ ] Test aura cleanup on spell deactivation\n- [ ] Test pulse_radius boundary conditions (edge of radius)\n- [ ] Test damage values match component configuration","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:16:06.753741+11:00","updated_at":"2026-01-02T05:17:14.060248+11:00","closed_at":"2026-01-02T05:17:14.060248+11:00","dependencies":[{"issue_id":"dt-survivor-8n0","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:16:12.65815+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-8s7","title":"Add GameOverEvent","description":"Create GameOverEvent in src/game/events.rs with final_score: u32, survival_time: f32. Update player_death_system to fire event before state transition. UI and audio systems can listen for this event. Decouples game over handling from direct state manipulation.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-25T17:42:02.391996+11:00","updated_at":"2025-12-25T19:53:22.892474+11:00","closed_at":"2025-12-25T19:53:22.892474+11:00","dependencies":[{"issue_id":"dt-survivor-8s7","depends_on_id":"dt-survivor-1wg","type":"blocks","created_at":"2025-12-25T17:42:19.872421+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-8s7","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:42:21.170925+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-8tu","title":"Update Loot Drop System for Equal Spell Rates","description":"Part of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Overview\nUpdate the loot drop system so all 64 spells have equal drop rates. Currently weapons have different drop rates - spells should all be equally likely to drop.\n\n## Current State\n- src/loot/systems.rs handles enemy death loot drops\n- ItemData::Weapon variant contains weapon type\n- Drop rates may be weighted by weapon type\n\n## Target State\n- ItemData::Spell variant with SpellType\n- All 64 spell types have equal 1/64 chance\n- Drop visuals use spell's element color\n\n## ECS Implementation\n\n### Components\n- Modify DroppedItem to use ItemData::Spell(Spell)\n- Spell drops show element-colored glow\n\n### Systems\n```rust\n// In enemy death/loot drop system\nfn spawn_spell_drop(spell_type: SpellType) {\n    let spell = Spell::new(spell_type); // Level 1\n    // Use spell.element().color() for visual\n}\n\nfn random_spell_type() -\u003e SpellType {\n    // Equal weight random selection from all 64 variants\n    let index = rand::thread_rng().gen_range(0..64);\n    SpellType::from_index(index)\n}\n```\n\n### Files to Modify\n- src/loot/systems.rs - drop spawning logic\n- src/loot/components.rs - ItemData enum\n- src/spell/components.rs - add SpellType::from_index() or similar\n\n## Acceptance Criteria\n- [ ] All 64 spells have equal drop probability (1/64 each)\n- [ ] Spell drops display correct element color glow\n- [ ] Dropped spells can be picked up and equipped/stored\n- [ ] Drop rate is configurable (base chance per enemy kill)\n- [ ] Element icon or visual indicator on dropped spell\n- [ ] Existing loot types (health, XP) still work\n\n## Required Tests\n1. test_all_spell_types_can_drop - verify all 64 types in drop pool\n2. test_spell_drop_distribution - statistical test for equal rates\n3. test_spell_drop_visual_matches_element - color verification\n4. test_spell_pickup_equips_to_empty_slot\n5. test_spell_pickup_levels_existing\n6. test_spell_pickup_adds_to_bag_when_slots_full\n7. test_health_and_xp_drops_unchanged","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:20:04.568319+11:00","updated_at":"2026-01-02T10:08:03.652057+11:00","closed_at":"2026-01-02T10:08:03.652057+11:00","dependencies":[{"issue_id":"dt-survivor-8tu","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:20:22.659241+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-97t","title":"Reduce enemy spawn rate 30% and slow ramp by 30%","description":"Lower enemy spawn rate by 30% (0.6 -\u003e 0.42) and reduce spawn rate ramp per level by 30% (1.5x -\u003e 1.35x per level).","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-02T11:45:22.779477+11:00","updated_at":"2026-01-02T11:54:34.49781+11:00","closed_at":"2026-01-02T11:54:34.49781+11:00"}
{"id":"dt-survivor-9fm","title":"Add Inventory Keyboard Shortcuts","description":"## Context\nPart of the spells system refactoring (epic: dt-survivor-jdd). The inventory system needs keyboard shortcuts to toggle the inventory overlay. This task focuses specifically on the input handling, separate from the inventory UI itself.\n\n## Implementation Details\n\n### Files to Modify\n- `src/ui/systems.rs` or `src/game/systems.rs` - Add keyboard input handling\n\n### Keyboard Mappings\n| Key | Action | Condition |\n|-----|--------|-----------|\n| `I` | Open inventory | Only from `GameState::InGame` |\n| `I` | Close inventory | From `GameState::InventoryOpen` |\n| `Escape` | Close inventory | From `GameState::InventoryOpen` |\n\n### State Transitions\n```\nGameState::InGame --[I key]--\u003e GameState::InventoryOpen\nGameState::InventoryOpen --[I key]--\u003e GameState::InGame\nGameState::InventoryOpen --[Escape]--\u003e GameState::InGame\n```\n\n### System Implementation\n```rust\n/// Handle I key to toggle inventory overlay\npub fn handle_inventory_toggle(\n    keyboard: Res\u003cButtonInput\u003cKeyCode\u003e\u003e,\n    current_state: Res\u003cState\u003cGameState\u003e\u003e,\n    mut next_state: ResMut\u003cNextState\u003cGameState\u003e\u003e,\n) {\n    if keyboard.just_pressed(KeyCode::KeyI) {\n        match current_state.get() {\n            GameState::InGame =\u003e next_state.set(GameState::InventoryOpen),\n            GameState::InventoryOpen =\u003e next_state.set(GameState::InGame),\n            _ =\u003e {} // Ignore I key during other states (e.g., AttunementSelect, Paused)\n        }\n    }\n}\n\n/// Handle Escape to close inventory\npub fn handle_inventory_escape(\n    keyboard: Res\u003cButtonInput\u003cKeyCode\u003e\u003e,\n    mut next_state: ResMut\u003cNextState\u003cGameState\u003e\u003e,\n) {\n    if keyboard.just_pressed(KeyCode::Escape) {\n        next_state.set(GameState::InGame);\n    }\n}\n```\n\n### System Registration\n```rust\n// In plugin\napp.add_systems(\n    Update,\n    (\n        handle_inventory_toggle.run_if(\n            in_state(GameState::InGame).or(in_state(GameState::InventoryOpen))\n        ),\n        handle_inventory_escape.run_if(in_state(GameState::InventoryOpen)),\n    )\n        .in_set(GameSet::Input),\n);\n```\n\n### Edge Cases\n- I key should be ignored during:\n  - `GameState::AttunementSelect` (must complete selection first)\n  - `GameState::Paused` (if pause menu exists)\n  - `GameState::GameOver`\n- Escape may have other uses (pause menu) - coordinate with other escape handlers\n\n## Acceptance Criteria\n- [ ] I key opens inventory from InGame state\n- [ ] I key closes inventory from InventoryOpen state\n- [ ] Escape key closes inventory from InventoryOpen state\n- [ ] I key ignored during AttunementSelect state\n- [ ] I key ignored during GameOver state\n- [ ] No state transitions during invalid states\n- [ ] Input uses just_pressed (not pressed) to prevent repeated triggers\n\n## Required Automated Tests\n- Test I key transitions InGame → InventoryOpen\n- Test I key transitions InventoryOpen → InGame\n- Test Escape key transitions InventoryOpen → InGame\n- Test I key does nothing from AttunementSelect\n- Test I key does nothing from GameOver\n- Test multiple rapid I presses don't cause issues (just_pressed behavior)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:05:32.066094+11:00","updated_at":"2026-01-02T00:24:06.117954+11:00","closed_at":"2026-01-02T00:24:06.117954+11:00","dependencies":[{"issue_id":"dt-survivor-9fm","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:05:37.895186+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-9qp","title":"Increase XP requirements per level by 5x","description":"Expand total XP needed for each player level by 5x from current levels. Currently base_xp=100, need to change to 500.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-02T11:45:20.329051+11:00","updated_at":"2026-01-02T11:49:35.775345+11:00","closed_at":"2026-01-02T11:49:35.775345+11:00"}
{"id":"dt-survivor-9wc","title":"Implement Psychic Scream Spell (Psychic)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Psychic Scream\n- **Element**: Psychic\n- **Behavior**: Damages and disorients enemies in a wide radius. Large AOE burst around the player that deals damage and applies a confusion effect, causing enemies to move erratically.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct PsychicScreamBurst {\n    pub radius: f32,\n    pub damage: f32,\n    pub disorientation_duration: f32,\n}\n\n#[derive(Component)]\npub struct DisorientedEnemy {\n    pub duration: Timer,\n    pub jitter: f32,  // Magnitude of random movement\n    pub jitter_timer: Timer,  // Time between direction changes\n}\n```\n\n### Systems Needed\n1. `cast_psychic_scream` - Create scream burst at player\n2. `apply_psychic_scream_effects` - Damage and disorient enemies\n3. `update_disoriented_enemies` - Apply erratic movement\n4. `cleanup_disorientation` - Remove effect when expired\n\n### File Location\n`src/spells/psychic/psychic_scream.rs`\n\n## Visual Design\n- Large pink/magenta shockwave emanating from player\n- Violet mind-wave ripples spreading outward\n- Disoriented enemies have swirling stars/spiral effect\n- Screen shake effect on cast\n\n## Acceptance Criteria\n- [ ] Psychic Scream creates large AOE burst at player\n- [ ] All enemies in radius take damage\n- [ ] Affected enemies become disoriented\n- [ ] Disoriented enemies move erratically with jitter\n- [ ] Disorientation expires after duration\n- [ ] Visual shows confusion state clearly\n- [ ] Integrates with spell cooldown system\n\n## Required Tests\n1. `test_psychic_scream_creates_burst` - Burst spawns correctly\n2. `test_psychic_scream_damages_in_radius` - Damage applied\n3. `test_psychic_scream_disorients_enemies` - Effect applied\n4. `test_disoriented_movement_is_erratic` - Jitter works\n5. `test_disorientation_duration_expires` - Timer works\n6. `test_disorientation_restores_normal_movement` - Effect ends\n7. `test_psychic_scream_large_radius` - Wide area covered\n8. `test_psychic_scream_enemies_outside_radius` - Not affected","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:18:49.902753+11:00","updated_at":"2026-01-02T09:40:57.267527+11:00","closed_at":"2026-01-02T09:40:57.267527+11:00","dependencies":[{"issue_id":"dt-survivor-9wc","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:18:55.30915+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-a2s","title":"Convert enemy spawning from Sprite to Mesh3d cubes","description":"# Task: Enemy 3D Spawning\n\n## Context\nDT Survivor is migrating from 2D to 3D. Enemies currently spawn as red sprites and need to be converted to 3D cube meshes. Spawn positions must be converted from XY plane to XZ plane.\n\n## Current Implementation\n**Enemy Spawning** (`src/enemies/systems.rs:11-83`):\n```rust\ncommands.spawn((\n    Sprite::from_color(Color::srgb(1.0, 0.0, 0.0), Vec2::new(15.0, 15.0)),\n    Transform::from_translation(Vec3::new(spawn_pos.x, spawn_pos.y, 0.5)),\n    Enemy { speed: 50.0, strength: 10.0 },\n    Health::new(10.0),\n    CheckDeath,\n));\n```\n\nSpawn position is calculated at 600+ units from player using angle/distance on XY plane.\n\n## Required Changes\n\n### 1. Update Enemy Spawn Position Calculation\nConvert from XY to XZ plane:\n```rust\n// Before\nlet spawn_pos = Vec2::new(\n    player_pos.x + angle.cos() * distance,\n    player_pos.y + angle.sin() * distance,\n);\n\n// After\nlet spawn_x = player_pos.x + angle.cos() * distance;\nlet spawn_z = player_pos.y + angle.sin() * distance; // Y becomes Z in 3D\nlet spawn_pos = Vec3::new(spawn_x, 0.375, spawn_z); // Y=0.375 (half of 0.75 cube)\n```\n\n### 2. Update Enemy Spawning\n```rust\ncommands.spawn((\n    Mesh3d(game_meshes.enemy.clone()),\n    MeshMaterial3d(game_materials.enemy.clone()),\n    Transform::from_translation(spawn_pos),\n    Enemy { speed: 50.0, strength: 10.0 },\n    Health::new(10.0),\n    CheckDeath,\n));\n```\n\n### 3. Update System Signature\n```rust\npub fn spawn_enemy(\n    mut commands: Commands,\n    time: Res\u003cTime\u003e,\n    mut spawn_timer: ResMut\u003cEnemySpawnTimer\u003e,\n    player_position: Res\u003cPlayerPosition\u003e,\n    game_meshes: Res\u003cGameMeshes\u003e,\n    game_materials: Res\u003cGameMaterials\u003e,\n) { ... }\n```\n\n### 4. Adjust Spawn Distance for 3D Scale\nThe spawn distance (600 units) may need adjustment for the new 3D scale. Consider reducing to ~60 units if world scale changes.\n\n## Testing Requirements\n- Unit test: Enemy spawns with Mesh3d component\n- Unit test: Enemy spawns with MeshMaterial3d component\n- Unit test: Enemy transform Y position is 0.375 (half cube height)\n- Unit test: Enemy spawn position is on XZ plane (not XY)\n- Unit test: Spawn distance from player is correct\n- Unit test: Spawn angle distribution is uniform around player\n- Update existing enemy spawn tests for 3D coordinates\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] Enemies render as red 3D cubes\n- [ ] Enemies spawn on XZ plane at appropriate Y height\n- [ ] Spawn positions calculated correctly in 3D space\n- [ ] Enemy speed and strength unchanged\n- [ ] Health and CheckDeath components still attached\n- [ ] No Sprite components in enemy spawning\n- [ ] All existing enemy tests updated and passing\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:46:32.257852+11:00","updated_at":"2025-12-28T10:09:40.364142+11:00","closed_at":"2025-12-28T10:09:40.364142+11:00","dependencies":[{"issue_id":"dt-survivor-a2s","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.371959+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-a2s","depends_on_id":"dt-survivor-ggr","type":"blocks","created_at":"2025-12-28T09:50:35.36709+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-ahu","title":"Implement Game Level resource and kill tracking","description":"Create a GameLevel resource to track the current game level and enemy kill count. The game level increases as players kill enemies. When a level is completed, the game transitions to the LevelComplete state.\n\n## Context\nThe current codebase has EnemySpawnState resource in src/enemies/systems.rs that tracks spawn rate progression. The GameLevel resource will work alongside this to drive overall game progression.\n\n## Implementation\n\n### Resource Definition (src/game/resources.rs)\n```rust\n/// Configuration for game level progression\n#[derive(Debug, Clone)]\npub struct LevelConfig {\n    /// Base number of kills needed to advance from level 1\n    pub base_kills: u32,\n    /// Multiplier applied each level (kills_needed = base_kills * multiplier^(level-1))\n    pub kill_multiplier: f32,\n}\n\nimpl Default for LevelConfig {\n    fn default() -\u003e Self {\n        Self {\n            base_kills: 10,\n            kill_multiplier: 1.5,\n        }\n    }\n}\n\n/// Tracks game level progression\n#[derive(Resource, Debug, Default)]\npub struct GameLevel {\n    /// Current game level (starts at 1)\n    pub level: u32,\n    /// Number of enemies killed in current level\n    pub kills_this_level: u32,\n    /// Total enemies killed this game\n    pub total_kills: u32,\n    /// Configuration for progression\n    pub config: LevelConfig,\n}\n\nimpl GameLevel {\n    pub fn new() -\u003e Self {\n        Self {\n            level: 1,\n            kills_this_level: 0,\n            total_kills: 0,\n            config: LevelConfig::default(),\n        }\n    }\n\n    /// Calculate kills needed to advance from current level\n    pub fn kills_to_advance(\u0026self) -\u003e u32 {\n        let multiplier = self.config.kill_multiplier.powi(self.level as i32 - 1);\n        (self.config.base_kills as f32 * multiplier).ceil() as u32\n    }\n\n    /// Register a kill and return true if level advanced\n    pub fn register_kill(\u0026mut self) -\u003e bool {\n        self.kills_this_level += 1;\n        self.total_kills += 1;\n        \n        if self.kills_this_level \u003e= self.kills_to_advance() {\n            self.level += 1;\n            self.kills_this_level = 0;\n            true\n        } else {\n            false\n        }\n    }\n\n    /// Progress percentage toward next level (0.0 - 1.0)\n    pub fn progress(\u0026self) -\u003e f32 {\n        self.kills_this_level as f32 / self.kills_to_advance() as f32\n    }\n}\n```\n\n### Event Definition (src/game/events.rs)\n```rust\n/// Fired when the game advances to a new level\n#[derive(Message, Debug)]\npub struct GameLevelUpEvent {\n    pub new_level: u32,\n}\n```\n\n### System Implementation (src/game/systems.rs)\n```rust\n/// Tracks enemy kills, advances game level, and triggers level complete state\npub fn track_enemy_kills_system(\n    mut death_events: MessageReader\u003cEnemyDeathEvent\u003e,\n    mut game_level: ResMut\u003cGameLevel\u003e,\n    mut level_up_writer: MessageWriter\u003cGameLevelUpEvent\u003e,\n    mut next_state: ResMut\u003cNextState\u003cGameState\u003e\u003e,\n) {\n    for _ in death_events.read() {\n        if game_level.register_kill() {\n            level_up_writer.write(GameLevelUpEvent {\n                new_level: game_level.level,\n            });\n            // Transition to level complete screen\n            next_state.set(GameState::LevelComplete);\n        }\n    }\n}\n\n/// Reset game level on game start\npub fn reset_game_level(mut game_level: ResMut\u003cGameLevel\u003e) {\n    *game_level = GameLevel::new();\n}\n```\n\n### Plugin Registration (src/game/plugin.rs)\n```rust\napp\n    .init_resource::\u003cGameLevel\u003e()\n    .add_message::\u003cGameLevelUpEvent\u003e()\n    .add_systems(OnEnter(GameState::InGame), reset_game_level)\n    .add_systems(\n        Update,\n        track_enemy_kills_system\n            .in_set(GameSet::Effects)\n            .run_if(in_state(GameState::InGame)),\n    );\n```\n\n## Progression Example\nWith default config (base_kills=10, multiplier=1.5):\n- Level 1 → 2: 10 kills\n- Level 2 → 3: 15 kills (10 * 1.5)\n- Level 3 → 4: 23 kills (10 * 1.5^2)\n- Level 4 → 5: 34 kills (10 * 1.5^3)\n\n## ECS Pattern\n```rust\n// Track kills via event-driven architecture\nfn track_kills(\n    mut death_events: MessageReader\u003cEnemyDeathEvent\u003e,\n    mut game_level: ResMut\u003cGameLevel\u003e,\n    mut next_state: ResMut\u003cNextState\u003cGameState\u003e\u003e,\n) {\n    for _ in death_events.read() {\n        if game_level.register_kill() {\n            next_state.set(GameState::LevelComplete);\n        }\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] GameLevel resource tracks current level, kills this level, total kills\n- [ ] kills_to_advance() returns correct threshold based on level\n- [ ] register_kill() increments counters and returns true on level up\n- [ ] GameLevelUpEvent fired when level advances\n- [ ] GameState transitions to LevelComplete when level advances\n- [ ] GameLevel resets on game start (not when returning from LevelComplete)\n- [ ] Unit tests for kill tracking and level advancement\n- [ ] Unit tests for progression formula\n\n## Test Requirements\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn game_level_starts_at_one() {\n        let level = GameLevel::new();\n        assert_eq!(level.level, 1);\n        assert_eq!(level.kills_this_level, 0);\n    }\n\n    #[test]\n    fn kills_to_advance_increases_with_level() {\n        let mut level = GameLevel::new();\n        let kills_1 = level.kills_to_advance();\n        level.level = 2;\n        let kills_2 = level.kills_to_advance();\n        assert!(kills_2 \u003e kills_1);\n    }\n\n    #[test]\n    fn register_kill_advances_level_at_threshold() {\n        let mut level = GameLevel::new();\n        let threshold = level.kills_to_advance();\n        for _ in 0..threshold - 1 {\n            assert!(!level.register_kill());\n        }\n        assert!(level.register_kill()); // Should advance\n        assert_eq!(level.level, 2);\n        assert_eq!(level.kills_this_level, 0);\n    }\n\n    #[test]\n    fn progress_returns_correct_percentage() {\n        let mut level = GameLevel::new();\n        level.kills_this_level = 5;\n        // With base_kills=10, progress should be 0.5\n        assert!((level.progress() - 0.5).abs() \u003c 0.01);\n    }\n}\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-30T09:40:58.239174+11:00","updated_at":"2025-12-30T10:47:32.578764+11:00","closed_at":"2025-12-30T10:47:32.578764+11:00","dependencies":[{"issue_id":"dt-survivor-ahu","depends_on_id":"dt-survivor-3l7","type":"blocks","created_at":"2025-12-30T09:45:06.809673+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-ahu","depends_on_id":"dt-survivor-aiy","type":"parent-child","created_at":"2025-12-30T09:45:19.055926+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-aiy","title":"Game Progression System","description":"Implement a complete game progression system including game levels, enemy levels (1-5), XP orb levels (1-5), player leveling, and weapon damage scaling. This epic coordinates all progression mechanics that make the game increasingly challenging over time.\n\n## Overview\nThe game should progress through levels, with enemies, XP orbs, and the player all having level mechanics. Higher game levels spawn stronger enemies, which drop better XP orbs, allowing players to level up and deal more damage.\n\n## Key Requirements\n- Game level progression based on enemy kills\n- Enemy levels 1-5 with HP/damage scaling and visual differentiation\n- XP orb levels 1-5 with value scaling and color coding\n- Player leveling with increasing XP requirements\n- Weapon damage scaling with level\n\n## ECS Pattern: Level Component\nA reusable Level component should be created and attached to entities that need level tracking. Systems operate on entities with the Level component.\n\n## Color Scheme (for enemies and XP orbs)\n- Level 1: Grey (common)\n- Level 2: Green (uncommon)\n- Level 3: Blue (rare)\n- Level 4: Purple (epic)\n- Level 5: Gold (legendary)","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-30T09:40:04.73001+11:00","updated_at":"2025-12-30T11:52:39.120774+11:00","closed_at":"2025-12-30T11:52:39.120774+11:00"}
{"id":"dt-survivor-arn","title":"Implement Corrode Spell (Poison)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Corrode\n- **Element**: Poison\n- **Behavior**: Poison damage reduces enemy defenses. A debuff that increases damage taken from all sources. Applied by poison damage, making enemies more vulnerable to subsequent attacks.\n\n## ECS Implementation\n\n### Components\n- `CorrodedDebuff { duration: Timer, damage_taken_multiplier: f32 }` - Debuff applied to enemies that increases all incoming damage\n\n### Systems\n- `apply_corroded_on_poison_damage` - Applies/refreshes Corroded debuff when poison damage is dealt\n- `corroded_damage_amplification` - Modifies incoming damage based on multiplier\n- `corroded_duration_tick` - Counts down debuff duration\n- `cleanup_corroded_debuff` - Removes debuff when duration expires\n\n### File Location\n`src/spells/poison/corrode.rs`\n\n## Visual Design\n- Debuff indicator: Sickly yellow-green aura around affected enemy\n- Damage numbers: Could show amplified damage in different color\n- Corroded texture: Enemy sprite gets slight green tint overlay\n- Poison element uses green/toxic colors, bubble/drip particle effects\n\n## Acceptance Criteria\n- [ ] Corroded debuff applied when enemy takes poison damage\n- [ ] Debuff increases all incoming damage by configured multiplier\n- [ ] Multiple poison sources refresh duration (not stack multiplier)\n- [ ] Visual indicator clearly shows debuffed enemies\n- [ ] Debuff expires after duration\n- [ ] Works with all damage types (spells, DOT, etc.)\n- [ ] Damage multiplier is configurable per spell level\n\n## Required Tests\n- `test_corroded_applied_on_poison_damage` - Verify debuff application\n- `test_corroded_increases_damage_taken` - Verify damage amplification\n- `test_corroded_refreshes_duration` - Verify duration refresh on reapply\n- `test_corroded_no_multiplier_stacking` - Verify multiplier doesn't stack\n- `test_corroded_affects_all_damage_types` - Verify works with all damage\n- `test_corroded_expires_after_duration` - Verify cleanup\n- `test_corroded_multiplier_calculation` - Verify math is correct","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:11:58.018126+11:00","updated_at":"2026-01-02T03:19:03.454667+11:00","closed_at":"2026-01-02T03:19:03.454667+11:00","dependencies":[{"issue_id":"dt-survivor-arn","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:12:04.237287+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-att","title":"Migrate Rocket Launcher to Thunder Strike Spell","description":"## Context\n\nPart of the spells refactoring epic (dt-survivor-jdd) to migrate existing weapons into an elemental spell system. The Rocket Launcher weapon becomes the Thunder Strike spell - a lightning-element area attack that strikes from above.\n\n## Implementation Details\n\n### File Migration\n- Move logic from `src/rocket_launcher/` into `src/spells/lightning/thunder_strike.rs`\n- Create `src/spells/lightning/mod.rs` to export thunder_strike module\n\n### Spell Mechanics\n- **Thunder Strike**: Vertical lightning bolt strikes a targeted area\n- **Element**: Lightning (yellow/electric blue visuals)\n- **Targeting**: Ground target marker appears, then bolt strikes after short delay\n- **Damage**: High area damage in strike zone\n\n### ECS Components to Create\n- `ThunderStrike` - the actual bolt entity:\n  - `damage: f32` - damage dealt in area\n  - `radius: f32` - area of effect radius\n  - `strike_timer: Timer` - delay before strike lands\n- `TargetMarker` - visual indicator on ground:\n  - `position: Vec2` - center of target area\n  - `radius: f32` - visual radius indicator\n  - `linked_strike: Entity` - the ThunderStrike entity this marks\n\n### Adaptation from Rocket Launcher\n- Adapt homing/targeting logic to target marking system\n- Convert projectile travel to instant vertical strike\n- Keep explosion area damage calculation\n- Preserve damage radius and falloff logic\n\n### Visual Changes\n- Replace rocket sprite with lightning bolt (yellow/electric)\n- Ground target marker (circle indicator before strike)\n- Lightning flash effect on impact\n- Electric particle effects in strike zone\n\n### ECS Patterns\n- TargetMarker spawns first at target location\n- After delay, ThunderStrike spawns and TargetMarker despawns\n- ThunderStrike applies area damage on spawn\n- ThunderStrike despawns after visual effect duration\n\n## Acceptance Criteria\n\n- [ ] TargetMarker spawns at aimed/targeted position\n- [ ] TargetMarker shows visual radius indicator\n- [ ] Thunder strike delay timer works correctly\n- [ ] Lightning bolt spawns at marker position after delay\n- [ ] Area damage applied to all enemies in radius\n- [ ] Damage falloff from center (if applicable)\n- [ ] Visual lightning effect renders\n- [ ] Entities cleaned up after effect\n- [ ] Level scaling affects damage and radius\n\n## Required Tests\n\n1. **Target Marking**: TargetMarker spawns at correct position\n2. **Strike Delay**: ThunderStrike spawns after timer expires\n3. **Area Damage**: All enemies in radius receive damage\n4. **Damage Calculation**: Damage matches expected values\n5. **Radius Check**: Enemies outside radius not damaged\n6. **Entity Cleanup**: TargetMarker and ThunderStrike despawn correctly\n7. **Level Scaling**: Higher levels increase damage/radius\n8. **Cooldown**: Cannot cast faster than cooldown allows","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-01T21:04:59.223082+11:00","updated_at":"2026-01-01T23:30:41.680019+11:00","closed_at":"2026-01-01T23:30:41.680019+11:00","dependencies":[{"issue_id":"dt-survivor-att","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:05:19.769885+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-avj","title":"Implement Void Pulse Spell (Dark)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Void Pulse\n- **Element**: Dark\n- **Behavior**: Dark energy wave that weakens enemies. An expanding wave emanates from the player, applying a Weakened debuff to all enemies it touches. Weakened enemies take increased damage from all sources.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct VoidPulseWave {\n    pub radius: f32,       // Current radius of expanding wave\n    pub max_radius: f32,   // Maximum radius before despawn\n    pub expansion_speed: f32,\n    pub damage: f32,\n}\n\n#[derive(Component)]\npub struct WeakenedDebuff {\n    pub damage_multiplier: f32,  // e.g., 1.5 = 50% more damage taken\n    pub duration: Timer,\n}\n```\n\n### Systems\n- `spawn_void_pulse` - Creates expanding wave entity centered on player\n- `update_void_pulse_expansion` - Grow wave radius each frame\n- `void_pulse_enemy_collision` - Apply Weakened debuff to enemies wave passes through\n- `update_weakened_debuff` - Tick debuff timers, remove expired debuffs\n- `cleanup_void_pulse` - Despawn wave when max radius reached\n\n### File Location\n`src/spells/dark/void_pulse.rs`\n\n## Visual Design\n- Dark purple/black ring expanding outward from player\n- Void particles and shadow effects along wave edge\n- Enemies hit show dark aura indicating Weakened status\n- Translucent dark overlay while debuff active\n\n## Acceptance Criteria\n- [ ] VoidPulseWave component tracks current and max radius\n- [ ] Wave expands outward from player position at configured speed\n- [ ] Enemies touched by wave receive WeakenedDebuff\n- [ ] WeakenedDebuff increases damage taken by enemies\n- [ ] Debuff expires after configured duration\n- [ ] Wave despawns after reaching max radius\n- [ ] Spell integrates with 5-slot active spell system\n\n## Required Tests\n- [ ] Test wave spawns at player position\n- [ ] Test wave expands at correct speed\n- [ ] Test enemy receives WeakenedDebuff when wave passes through\n- [ ] Test WeakenedDebuff correctly multiplies incoming damage\n- [ ] Test debuff expires after duration\n- [ ] Test wave despawns at max radius\n- [ ] Test multiple enemies can be debuffed by single pulse\n- [ ] Test enemy can only be debuffed once per pulse (no stacking from same wave)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:16:48.88349+11:00","updated_at":"2026-01-02T06:21:43.880932+11:00","closed_at":"2026-01-02T06:21:43.880932+11:00","dependencies":[{"issue_id":"dt-survivor-avj","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:17:07.139978+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-awd","title":"Implement floating damage numbers","description":"Add floating damage numbers that appear when enemies take damage, colored by spell element type, animating upward while fading out. Uses world-space Text2d rendering.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-02T12:20:58.368068+11:00","updated_at":"2026-01-02T12:25:41.316175+11:00","closed_at":"2026-01-02T12:25:41.316175+11:00"}
{"id":"dt-survivor-b35","title":"Implement Level Complete screen with overlay and continue flow","description":"Create the level complete screen that appears when a game level is completed, showing stats and allowing the player to continue.\n\n## Context\nWhen GameLevelUpEvent fires (from dt-survivor-ahu), the game should pause and display a level complete screen. The LevelStats resource (dt-survivor-0as) provides the statistics to display.\n\n## Game State Addition (src/states.rs)\n```rust\n#[derive(States, Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]\npub enum GameState {\n    #[default]\n    MainMenu,\n    InGame,\n    LevelComplete,  // NEW: Pause state for level complete screen\n    Paused,\n    GameOver,\n}\n```\n\n## Implementation\n\n### Components (src/ui/components.rs)\n```rust\n/// Root marker for level complete UI\n#[derive(Component)]\npub struct LevelCompleteScreen;\n\n/// The black overlay that animates opacity\n#[derive(Component)]\npub struct LevelCompleteOverlay {\n    pub target_opacity: f32,\n    pub current_opacity: f32,\n    pub animation_speed: f32,\n}\n\nimpl Default for LevelCompleteOverlay {\n    fn default() -\u003e Self {\n        Self {\n            target_opacity: 0.85,\n            current_opacity: 0.0,\n            animation_speed: 2.0, // Fully opaque in ~0.5 seconds\n        }\n    }\n}\n\n/// Marker for the continue button\n#[derive(Component)]\npub struct ContinueButton;\n\n/// Marker for level complete stats text\n#[derive(Component)]\npub struct LevelCompleteStatsText;\n```\n\n### Level Complete UI Setup (src/ui/systems.rs)\n```rust\npub fn setup_level_complete_screen(\n    mut commands: Commands,\n    asset_server: Res\u003cAssetServer\u003e,\n    game_level: Res\u003cGameLevel\u003e,\n    level_stats: Res\u003cLevelStats\u003e,\n) {\n    // Root container for entire level complete UI\n    commands.spawn((\n        Node {\n            width: Val::Percent(100.0),\n            height: Val::Percent(100.0),\n            position_type: PositionType::Absolute,\n            flex_direction: FlexDirection::Column,\n            align_items: AlignItems::Center,\n            justify_content: JustifyContent::Center,\n            ..default()\n        },\n        LevelCompleteScreen,\n    )).with_children(|parent| {\n        // Black overlay background (animates opacity)\n        parent.spawn((\n            Node {\n                width: Val::Percent(100.0),\n                height: Val::Percent(100.0),\n                position_type: PositionType::Absolute,\n                ..default()\n            },\n            BackgroundColor(Color::srgba(0.0, 0.0, 0.0, 0.0)),\n            LevelCompleteOverlay::default(),\n        ));\n\n        // Content container (centered)\n        parent.spawn((\n            Node {\n                flex_direction: FlexDirection::Column,\n                align_items: AlignItems::Center,\n                row_gap: Val::Px(20.0),\n                padding: UiRect::all(Val::Px(40.0)),\n                ..default()\n            },\n            ZIndex(1), // Above overlay\n        )).with_children(|content| {\n            // \"Level X Complete\" title\n            content.spawn((\n                Text::new(format!(\"Level {} Complete!\", game_level.level - 1)),\n                TextFont {\n                    font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\n                    font_size: 48.0,\n                    ..default()\n                },\n                TextColor(Color::srgb(1.0, 0.84, 0.0)), // Gold\n            ));\n\n            // Stats container\n            content.spawn((\n                Node {\n                    flex_direction: FlexDirection::Column,\n                    align_items: AlignItems::Start,\n                    row_gap: Val::Px(10.0),\n                    margin: UiRect::vertical(Val::Px(20.0)),\n                    ..default()\n                },\n            )).with_children(|stats| {\n                // Time taken\n                stats.spawn((\n                    Text::new(format!(\"Time: {}\", level_stats.formatted_time())),\n                    TextFont {\n                        font: asset_server.load(\"fonts/FiraSans-Regular.ttf\"),\n                        font_size: 24.0,\n                        ..default()\n                    },\n                    TextColor(Color::WHITE),\n                ));\n\n                // Enemies killed\n                stats.spawn((\n                    Text::new(format!(\"Enemies Killed: {}\", level_stats.enemies_killed)),\n                    TextFont {\n                        font: asset_server.load(\"fonts/FiraSans-Regular.ttf\"),\n                        font_size: 24.0,\n                        ..default()\n                    },\n                    TextColor(Color::WHITE),\n                ));\n\n                // XP gained\n                stats.spawn((\n                    Text::new(format!(\"XP Gained: {}\", level_stats.xp_gained)),\n                    TextFont {\n                        font: asset_server.load(\"fonts/FiraSans-Regular.ttf\"),\n                        font_size: 24.0,\n                        ..default()\n                    },\n                    TextColor(Color::WHITE),\n                ));\n            });\n\n            // Continue button\n            content.spawn((\n                Node {\n                    padding: UiRect::axes(Val::Px(40.0), Val::Px(15.0)),\n                    margin: UiRect::top(Val::Px(20.0)),\n                    ..default()\n                },\n                BackgroundColor(Color::srgb(0.2, 0.6, 0.2)),\n                Button,\n                ContinueButton,\n            )).with_children(|btn| {\n                btn.spawn((\n                    Text::new(\"Continue\"),\n                    TextFont {\n                        font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\n                        font_size: 28.0,\n                        ..default()\n                    },\n                    TextColor(Color::WHITE),\n                ));\n            });\n        });\n    });\n}\n```\n\n### Overlay Animation System\n```rust\npub fn animate_level_complete_overlay(\n    time: Res\u003cTime\u003e,\n    mut query: Query\u003c(\u0026mut LevelCompleteOverlay, \u0026mut BackgroundColor)\u003e,\n) {\n    for (mut overlay, mut bg_color) in query.iter_mut() {\n        if overlay.current_opacity \u003c overlay.target_opacity {\n            overlay.current_opacity += time.delta_secs() * overlay.animation_speed;\n            overlay.current_opacity = overlay.current_opacity.min(overlay.target_opacity);\n            bg_color.0 = Color::srgba(0.0, 0.0, 0.0, overlay.current_opacity);\n        }\n    }\n}\n```\n\n### Continue Button Handler\n```rust\npub fn handle_continue_button(\n    mut interaction_query: Query\u003c\n        (\u0026Interaction, \u0026mut BackgroundColor),\n        (Changed\u003cInteraction\u003e, With\u003cContinueButton\u003e),\n    \u003e,\n    mut next_state: ResMut\u003cNextState\u003cGameState\u003e\u003e,\n    mut commands: Commands,\n    enemies_query: Query\u003cEntity, With\u003cEnemy\u003e\u003e,\n    loot_query: Query\u003cEntity, With\u003cDroppedItem\u003e\u003e,\n    mut level_stats: ResMut\u003cLevelStats\u003e,\n    time: Res\u003cTime\u003e,\n) {\n    for (interaction, mut bg_color) in interaction_query.iter_mut() {\n        match *interaction {\n            Interaction::Pressed =\u003e {\n                // Despawn all enemies\n                for entity in enemies_query.iter() {\n                    commands.entity(entity).despawn_recursive();\n                }\n                \n                // Despawn all loot\n                for entity in loot_query.iter() {\n                    commands.entity(entity).despawn_recursive();\n                }\n                \n                // Reset level stats for new level\n                level_stats.reset(time.elapsed_secs());\n                \n                // Return to game\n                next_state.set(GameState::InGame);\n            }\n            Interaction::Hovered =\u003e {\n                bg_color.0 = Color::srgb(0.3, 0.7, 0.3);\n            }\n            Interaction::None =\u003e {\n                bg_color.0 = Color::srgb(0.2, 0.6, 0.2);\n            }\n        }\n    }\n}\n```\n\n### Play Level Complete Sound\n```rust\npub fn play_level_complete_sound(\n    mut commands: Commands,\n    asset_server: Res\u003cAssetServer\u003e,\n) {\n    commands.spawn((\n        AudioPlayer::new(asset_server.load(\"sounds/790472__organizedlaziness__level-completed.wav\")),\n        PlaybackSettings::DESPAWN,\n    ));\n}\n```\n\n### Trigger Level Complete State (modify track_enemy_kills_system in dt-survivor-ahu)\n```rust\npub fn track_enemy_kills_system(\n    mut death_events: MessageReader\u003cEnemyDeathEvent\u003e,\n    mut game_level: ResMut\u003cGameLevel\u003e,\n    mut level_up_writer: MessageWriter\u003cGameLevelUpEvent\u003e,\n    mut next_state: ResMut\u003cNextState\u003cGameState\u003e\u003e,\n) {\n    for _ in death_events.read() {\n        if game_level.register_kill() {\n            level_up_writer.write(GameLevelUpEvent {\n                new_level: game_level.level,\n            });\n            // Transition to level complete screen\n            next_state.set(GameState::LevelComplete);\n        }\n    }\n}\n```\n\n### Cleanup Level Complete UI\n```rust\npub fn cleanup_level_complete_screen(\n    mut commands: Commands,\n    query: Query\u003cEntity, With\u003cLevelCompleteScreen\u003e\u003e,\n) {\n    for entity in query.iter() {\n        commands.entity(entity).despawn_recursive();\n    }\n}\n```\n\n### Plugin Registration\n```rust\napp\n    .add_systems(OnEnter(GameState::LevelComplete), (\n        setup_level_complete_screen,\n        play_level_complete_sound,\n    ))\n    .add_systems(\n        Update,\n        (\n            animate_level_complete_overlay,\n            handle_continue_button,\n        ).run_if(in_state(GameState::LevelComplete)),\n    )\n    .add_systems(OnExit(GameState::LevelComplete), cleanup_level_complete_screen);\n```\n\n## State Preservation\nWhen continuing to next level, the following are preserved:\n- Player entity (position reset to center)\n- Player level and XP (PlayerExperience component)\n- Weapon levels (Weapon components)\n- Whisper state (WhisperState resource)\n\nThe following are despawned/reset:\n- All Enemy entities\n- All DroppedItem entities (loot, XP orbs)\n- LevelStats (reset for new level tracking)\n\n## Sound File\n- Path: assets/sounds/790472__organizedlaziness__level-completed.wav\n- Played once when entering LevelComplete state\n\n## ECS Pattern\n```rust\n// Marker components for UI cleanup\n#[derive(Component)]\npub struct LevelCompleteScreen;\n\n// Query all level complete UI for cleanup\nfn cleanup(mut commands: Commands, query: Query\u003cEntity, With\u003cLevelCompleteScreen\u003e\u003e) {\n    for entity in query.iter() {\n        commands.entity(entity).despawn_recursive();\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] GameState::LevelComplete added to states enum\n- [ ] Black overlay animates from transparent to 0.85 opacity\n- [ ] \"Level X Complete!\" text displayed in gold\n- [ ] Stats displayed: time (MM:SS), enemies killed, XP gained\n- [ ] Continue button visible and interactive\n- [ ] Button hover state changes color\n- [ ] Clicking Continue despawns all enemies\n- [ ] Clicking Continue despawns all loot/XP orbs\n- [ ] Level stats reset when continuing\n- [ ] Level complete sound plays on state enter\n- [ ] Player/weapon levels preserved across levels\n- [ ] Whisper state preserved across levels\n- [ ] UI cleaned up when exiting LevelComplete state\n- [ ] Game pauses (no enemy spawning/movement) during LevelComplete\n\n## Test Requirements\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn level_complete_overlay_animates_correctly() {\n        let mut overlay = LevelCompleteOverlay::default();\n        assert_eq!(overlay.current_opacity, 0.0);\n        \n        // Simulate animation\n        let delta = 0.25; // quarter second\n        overlay.current_opacity += delta * overlay.animation_speed;\n        overlay.current_opacity = overlay.current_opacity.min(overlay.target_opacity);\n        \n        assert!(overlay.current_opacity \u003e 0.0);\n        assert!(overlay.current_opacity \u003c= overlay.target_opacity);\n    }\n\n    #[test]\n    fn level_complete_overlay_caps_at_target() {\n        let mut overlay = LevelCompleteOverlay::default();\n        overlay.current_opacity = 0.8;\n        \n        // Large delta should cap at target\n        let delta = 1.0;\n        overlay.current_opacity += delta * overlay.animation_speed;\n        overlay.current_opacity = overlay.current_opacity.min(overlay.target_opacity);\n        \n        assert_eq!(overlay.current_opacity, overlay.target_opacity);\n    }\n}\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-30T10:34:53.440285+11:00","updated_at":"2025-12-30T11:50:20.037464+11:00","closed_at":"2025-12-30T11:50:20.037464+11:00","dependencies":[{"issue_id":"dt-survivor-b35","depends_on_id":"dt-survivor-aiy","type":"blocks","created_at":"2025-12-30T10:35:04.843152+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-b35","depends_on_id":"dt-survivor-ahu","type":"blocks","created_at":"2025-12-30T10:35:04.919669+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-b35","depends_on_id":"dt-survivor-0as","type":"blocks","created_at":"2025-12-30T10:35:04.99316+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-b67","title":"Convert bullet spawning from Sprite to Mesh3d cubes","description":"# Task: Bullet 3D Spawning\n\n## Context\nDT Survivor is migrating from 2D to 3D. Bullets (projectiles) currently spawn as yellow sprites and need to be converted to 3D cube meshes. Bullet direction is stored as Vec2 and used for XY movement - this needs to work with XZ plane instead.\n\n## Current Implementation\n**Bullet Spawning** (`src/bullets/systems.rs:24-106`):\n```rust\ncommands.spawn((\n    Sprite::from_color(Color::srgb(1.0, 1.0, 0.0), Vec2::new(8.0, 8.0)),\n    Transform::from_translation(player_transform.translation + Vec3::new(0.0, 0.0, 0.1)),\n    Bullet {\n        direction: direction,  // Vec2\n        speed: 200.0,\n        lifetime: Timer::from_seconds(15.0, TimerMode::Once),\n    },\n));\n```\n\n**Bullet Movement** (`src/bullets/systems.rs:108-116`):\n```rust\nlet movement = bullet.direction * bullet.speed * time.delta_secs();\ntransform.translation += movement.extend(0.0); // XY movement\n```\n\n## Required Changes\n\n### 1. Update Bullet Spawning\n```rust\ncommands.spawn((\n    Mesh3d(game_meshes.bullet.clone()),\n    MeshMaterial3d(game_materials.bullet.clone()),\n    Transform::from_translation(Vec3::new(\n        player_transform.translation.x,\n        0.5, // Same height as player center\n        player_transform.translation.z,\n    )),\n    Bullet {\n        direction: direction,  // Still Vec2, but represents XZ\n        speed: 200.0,\n        lifetime: Timer::from_seconds(15.0, TimerMode::Once),\n    },\n));\n```\n\n### 2. Update Bullet Movement System\n```rust\npub fn bullet_movement_system(\n    mut query: Query\u003c(\u0026mut Transform, \u0026Bullet)\u003e,\n    time: Res\u003cTime\u003e,\n) {\n    for (mut transform, bullet) in query.iter_mut() {\n        let movement = bullet.direction * bullet.speed * time.delta_secs();\n        // Convert Vec2 to XZ plane movement\n        transform.translation += Vec3::new(movement.x, 0.0, movement.y);\n    }\n}\n```\n\n### 3. Update Direction Calculation\nWhen calculating direction to nearest enemy:\n```rust\n// Before\nlet direction = (enemy_pos.truncate() - player_pos.truncate()).normalize();\n\n// After\nlet enemy_xz = Vec2::new(enemy_pos.x, enemy_pos.z);\nlet player_xz = Vec2::new(player_pos.x, player_pos.z);\nlet direction = (enemy_xz - player_xz).normalize();\n```\n\n### 4. Update Collision Detection\nBullet-enemy collision in `check_bullet_enemy_collision`:\n```rust\n// Before\nlet bullet_pos = bullet_transform.translation.truncate();\nlet enemy_pos = enemy_transform.translation.truncate();\n\n// After\nlet bullet_pos = Vec2::new(bullet_transform.translation.x, bullet_transform.translation.z);\nlet enemy_pos = Vec2::new(enemy_transform.translation.x, enemy_transform.translation.z);\n```\n\n## Testing Requirements\n- Unit test: Bullet spawns with Mesh3d component\n- Unit test: Bullet spawns at player XZ position with correct Y height\n- Unit test: Bullet direction Vec2 represents XZ plane correctly\n- Unit test: Bullet movement applies to X and Z axes (not X and Y)\n- Unit test: Bullet-enemy collision detection works on XZ plane\n- Unit test: Bullet spread pattern works in 3D\n- Update existing bullet tests for 3D coordinates\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] Bullets render as yellow 3D cubes (small, 0.3 size)\n- [ ] Bullets spawn at player's XZ position\n- [ ] Bullets move on XZ plane (Y stays constant)\n- [ ] Bullet direction targets enemies correctly in 3D\n- [ ] Bullet-enemy collisions detected on XZ plane\n- [ ] Bullet spread pattern functional\n- [ ] Bullet lifetime and despawning unchanged\n- [ ] No Sprite components in bullet spawning\n- [ ] All existing bullet tests updated and passing\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:46:32.415016+11:00","updated_at":"2025-12-28T10:16:30.709385+11:00","closed_at":"2025-12-28T10:16:30.709385+11:00","dependencies":[{"issue_id":"dt-survivor-b67","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.438418+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-b67","depends_on_id":"dt-survivor-ggr","type":"blocks","created_at":"2025-12-28T09:50:35.433042+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-bcf","title":"Implement Health Drain Spell (Dark)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Health Drain\n- **Element**: Dark\n- **Behavior**: Leeches health from nearby enemies over time. Creates an aura effect around the player that continuously damages enemies within range while healing the player for a percentage of damage dealt.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct HealthDrainAura {\n    pub radius: f32,\n    pub drain_rate: f32,      // Damage per second to enemies\n    pub heal_percentage: f32,  // Percentage of damage dealt returned as healing\n}\n```\n\n### Systems\n- `spawn_health_drain_aura` - Creates aura entity attached to player when spell activates\n- `update_health_drain_aura` - Tick damage to enemies in radius, apply healing to player\n- `cleanup_health_drain_aura` - Remove aura when spell duration expires or deactivates\n\n### File Location\n`src/spells/dark/health_drain.rs`\n\n## Visual Design\n- Purple/black pulsing aura around player\n- Shadow tendrils reaching toward enemies in range\n- Dark particle effects flowing from enemies to player when draining\n- Void/shadow aesthetic with semi-transparent overlay\n\n## Acceptance Criteria\n- [ ] HealthDrainAura component created with configurable radius, drain_rate, and heal_percentage\n- [ ] Aura correctly damages all enemies within radius each tick\n- [ ] Player receives healing proportional to damage dealt\n- [ ] Visual effects clearly show aura radius and drain connections\n- [ ] Aura persists for spell duration and cleans up properly\n- [ ] Multiple enemies can be drained simultaneously\n- [ ] Spell integrates with 5-slot active spell system\n\n## Required Tests\n- [ ] Test aura damages single enemy within radius\n- [ ] Test aura damages multiple enemies simultaneously\n- [ ] Test enemies outside radius take no damage\n- [ ] Test player healing scales with heal_percentage correctly\n- [ ] Test aura cleanup removes all associated entities\n- [ ] Test aura does not affect player or friendly entities\n- [ ] Test drain_rate applies damage per second accurately\n- [ ] Test integration with spell slot activation/deactivation","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:16:07.625278+11:00","updated_at":"2026-01-02T05:24:52.73932+11:00","closed_at":"2026-01-02T05:24:52.73932+11:00","dependencies":[{"issue_id":"dt-survivor-bcf","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:16:25.376181+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-bem","title":"Create GameSet SystemSets","description":"Add SystemSets for explicit system ordering in src/game/sets.rs (or systems.rs): GameSet enum with Input, Movement, Combat, Spawning, Effects, Cleanup variants. Derive SystemSet, Debug, Clone, PartialEq, Eq, Hash. Export from game module.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T17:41:01.959314+11:00","updated_at":"2025-12-25T18:56:32.52717+11:00","closed_at":"2025-12-25T18:56:32.52717+11:00","dependencies":[{"issue_id":"dt-survivor-bem","depends_on_id":"dt-survivor-xp9","type":"blocks","created_at":"2025-12-25T17:41:10.341444+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-bem","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:41:10.420985+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-bru","title":"Update Spell Bar UI to 5 Slots","description":"## Context\nPart of the spells system refactoring (epic: dt-survivor-jdd). The existing weapon bar UI needs to be refactored to support the new spells system with 5 spell slots instead of 3 weapon slots.\n\n## Implementation Details\n\n### Files to Modify\n- `src/ui/systems.rs` - Update spawn and update systems\n- `src/ui/components.rs` - Rename and add components\n\n### Component Renames\n- `WeaponSlot` → `SpellSlot`\n- `WeaponIcon` → `SpellIcon`\n- Related weapon UI components → spell equivalents\n\n### UI Changes\n- Change from 3 fixed slots to 5 dynamic slots\n- Show spell element color as background tint (use Element enum color values)\n- Display spell level number in corner\n- Show cooldown timer overlay (radial or bar)\n- Empty slots display placeholder icon\n\n### ECS Components to Create\n```rust\n#[derive(Component)]\npub struct SpellSlot {\n    pub slot_index: usize,\n}\n\n#[derive(Component)]\npub struct SpellIcon {\n    pub spell_type: Option\u003cSpellType\u003e,\n}\n\n#[derive(Component)]\npub struct SpellCooldownTimer;\n```\n\n### Bevy UI Patterns\n- Use `NodeBundle` with flexbox for horizontal slot layout\n- `ImageBundle` for spell icons\n- `BackgroundColor` component for element tint\n- Child `TextBundle` for level display\n- Overlay node for cooldown visualization\n\n## Acceptance Criteria\n- [ ] All weapon UI components renamed to spell equivalents\n- [ ] Spell bar displays exactly 5 slots\n- [ ] Slots show correct spell icons from player's SpellList\n- [ ] Element color tints background of each slot\n- [ ] Spell level displayed in each occupied slot\n- [ ] Cooldown timer visible during spell cooldown\n- [ ] Empty slots show placeholder icon\n- [ ] UI updates reactively when SpellList changes\n\n## Required Automated Tests\n- Test correct number of slots spawned (5)\n- Test SpellIcon updates when SpellList resource changes\n- Test cooldown timer visibility during active cooldown\n- Test empty slot placeholder rendering\n- Test element color mapping to background tint","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-01T21:04:09.524088+11:00","updated_at":"2026-01-01T23:09:09.141839+11:00","closed_at":"2026-01-01T23:09:09.141839+11:00","dependencies":[{"issue_id":"dt-survivor-bru","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:04:15.610899+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-bv9","title":"Implement Venom Spray Spell (Poison)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Venom Spray\n- **Element**: Poison\n- **Behavior**: Short-range cone attack that applies stacking poison. Instant cone attack in front of player. Each hit adds a poison stack, and stacks increase the DOT damage.\n\n## ECS Implementation\n\n### Components\n- `VenomSprayCone { angle: f32, range: f32, duration: f32 }` - Defines the cone hitbox for the spray\n- `PoisonStack { stacks: u32, max_stacks: u32, damage_per_stack: f32, tick_timer: Timer, duration: Timer }` - Tracks poison stacks on enemies, damage scales with stack count\n\n### Systems\n- `spawn_venom_spray` - Creates cone hitbox on spell cast\n- `venom_spray_hit_detection` - Detects enemies in cone, applies/adds poison stacks\n- `poison_stack_damage_tick` - Applies DOT based on stack count\n- `poison_stack_decay` - Reduces stacks over time or removes when duration expires\n- `cleanup_venom_spray` - Despawns cone after brief duration\n\n### File Location\n`src/spells/poison/venom_spray.rs`\n\n## Visual Design\n- Spray: Green/yellow toxic mist particles in cone shape\n- Stack visual: Green poison droplets orbiting affected enemy (more droplets = more stacks)\n- Poison element uses green/toxic colors, bubble/drip particle effects\n\n## Acceptance Criteria\n- [ ] Cone attack fires instantly in player facing direction\n- [ ] Enemies hit gain poison stack (or add to existing stacks)\n- [ ] DOT damage scales linearly with stack count\n- [ ] Maximum stack cap is enforced\n- [ ] Stacks have independent duration timers\n- [ ] Visual feedback shows stack count on enemies\n- [ ] Short range balances high damage potential\n\n## Required Tests\n- `test_venom_spray_cone_spawns_on_cast` - Verify cone creation\n- `test_venom_spray_hits_enemies_in_cone` - Verify hit detection\n- `test_venom_spray_misses_enemies_outside_cone` - Verify cone boundaries\n- `test_poison_stack_applied_on_hit` - Verify stack application\n- `test_poison_stacks_accumulate` - Verify multiple hits add stacks\n- `test_poison_stack_damage_scales_with_count` - Verify damage scaling\n- `test_poison_stack_max_cap_enforced` - Verify max stacks limit\n- `test_poison_stack_expires_after_duration` - Verify stack removal","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:10:48.974551+11:00","updated_at":"2026-01-02T01:30:11.952386+11:00","closed_at":"2026-01-02T01:30:11.952386+11:00","dependencies":[{"issue_id":"dt-survivor-bv9","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:10:54.132016+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-bvu","title":"Implement Judgment Spell (Light)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Judgment\n- **Element**: Light\n- **Behavior**: Periodic strikes of holy energy target enemies. Automatically targets enemies within range and calls down vertical beams of light that strike from above. Multiple targets can be struck in sequence.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct JudgmentCaster {\n    pub strike_timer: Timer,\n    pub target_range: f32,\n    pub damage: f32,\n    pub strike_delay: f32,  // Delay between targeting and beam hitting\n}\n\n#[derive(Component)]\npub struct JudgmentStrike {\n    pub target: Entity,\n    pub target_position: Vec2,\n    pub delay: Timer,\n}\n\n#[derive(Component)]\npub struct JudgmentBeam {\n    pub position: Vec2,\n    pub damage: f32,\n    pub lifetime: Timer,\n}\n```\n\n### Systems\n- `spawn_judgment_caster` - Creates the caster component on player when spell activates\n- `select_judgment_targets` - Finds enemies in range and spawns JudgmentStrike markers\n- `update_judgment_strike_delay` - Ticks strike delay timers\n- `spawn_judgment_beams` - Creates visible beam when delay expires\n- `apply_judgment_damage` - Damages enemy at beam location\n- `update_judgment_beam_lifetime` - Despawns beams after visual duration\n- `cleanup_judgment_caster` - Removes caster on spell deactivation\n\n### File Location\n`src/spells/light/judgment.rs`\n\n## Visual Design\n- Targeting indicator (light circle) appears on ground under target\n- Vertical beam of brilliant white/gold light descends from above\n- Impact creates radiant burst effect\n- Beam lingers briefly with fading glow\n- Sound of heavenly choir/chime on strike\n\n## Acceptance Criteria\n- [ ] JudgmentCaster periodically selects enemy targets\n- [ ] Targets are chosen from enemies within configurable range\n- [ ] Warning indicator appears before beam strikes\n- [ ] Beam visually descends from above onto target\n- [ ] Damage applies when beam hits target position\n- [ ] Multiple strikes can occur in sequence\n- [ ] Strike timing and damage are configurable\n\n## Required Tests\n- [ ] Test caster spawns with correct configuration\n- [ ] Test strike timer triggers target selection\n- [ ] Test nearest enemy within range is selected\n- [ ] Test no strike occurs when no enemies in range\n- [ ] Test strike delay timer counts down correctly\n- [ ] Test beam spawns at target position after delay\n- [ ] Test damage applies to enemy at beam position\n- [ ] Test beam despawns after lifetime expires","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:17:43.199439+11:00","updated_at":"2026-01-02T07:49:18.917385+11:00","closed_at":"2026-01-02T07:49:18.917385+11:00","dependencies":[{"issue_id":"dt-survivor-bvu","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:17:48.772244+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-bxq","title":"Implement Flashstep Spell (Lightning)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Flashstep\n- **Element**: Lightning\n- **Behavior**: Brief teleport that releases lightning at both origin and destination. Player teleports a short distance toward cursor/movement direction, with lightning bursts damaging enemies at start and end points. This is a mobility spell that affects player position.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct FlashstepEffect;  // Marker during teleport animation\n\n#[derive(Component)]\npub struct LightningBurst {\n    pub position: Vec3,\n    pub radius: f32,\n    pub damage: f32,\n    pub lifetime: Timer,\n}\n\n#[derive(Component)]\npub struct FlashstepCooldown {\n    pub timer: Timer,\n}\n```\n\n### Systems\n- `flashstep_input` - Detect cast input and calculate destination\n- `flashstep_teleport` - Move player position instantly\n- `flashstep_burst_spawn` - Create LightningBurst at origin and destination\n- `flashstep_burst_damage` - Apply AoE damage from bursts\n- `flashstep_burst_cleanup` - Remove burst effects after lifetime\n- `flashstep_cooldown` - Prevent spam casting\n\n### File Location\n`src/spells/lightning/flashstep.rs`\n\n## Visual Design\n- Player briefly becomes translucent during teleport\n- Electric trail connecting origin to destination\n- Bright yellow/electric blue burst explosion at both points\n- Crackling afterimage at origin point\n- Lightning particle trail along path\n- Brief invulnerability visual during teleport\n\n## Acceptance Criteria\n- [ ] Teleports player toward cursor/input direction\n- [ ] Teleport distance is configurable (short range)\n- [ ] Lightning burst spawns at origin position\n- [ ] Lightning burst spawns at destination position\n- [ ] Both bursts damage enemies in radius\n- [ ] Cannot teleport through walls/obstacles\n- [ ] Cooldown prevents immediate recast\n- [ ] Coordinates correctly with movement systems\n\n## Required Tests\n- [ ] Test teleport moves player to correct destination\n- [ ] Test teleport distance respects maximum range\n- [ ] Test origin burst spawns at pre-teleport position\n- [ ] Test destination burst spawns at post-teleport position\n- [ ] Test bursts damage enemies within radius\n- [ ] Test bursts do not damage enemies outside radius\n- [ ] Test cooldown prevents casting during timer\n- [ ] Test player position updates correctly in Transform","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:12:36.184981+11:00","updated_at":"2026-01-02T04:16:48.67742+11:00","closed_at":"2026-01-02T04:16:48.67742+11:00","dependencies":[{"issue_id":"dt-survivor-bxq","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:12:41.649264+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-c8q","title":"Add UI display for game level and progression","description":"Create UI elements to display the current game level, kill progress, and player level/XP progress.\n\n## Context\nCurrent UI in src/ui/systems.rs displays score, survival time, and player health. The UI uses Bevy's UI system with Text components. This task adds displays for game level and player progression.\n\n## Implementation\n\n### UI Components (src/ui/components.rs)\n```rust\n/// Marker for game level display UI element\n#[derive(Component)]\npub struct GameLevelDisplay;\n\n/// Marker for kill progress display\n#[derive(Component)]\npub struct KillProgressDisplay;\n\n/// Marker for player level display\n#[derive(Component)]\npub struct PlayerLevelDisplay;\n\n/// Marker for XP progress bar\n#[derive(Component)]\npub struct XpProgressBar;\n\n/// Marker for XP progress bar fill\n#[derive(Component)]\npub struct XpProgressBarFill;\n```\n\n### UI Setup System (src/ui/systems.rs)\n```rust\npub fn setup_progression_ui(\n    mut commands: Commands,\n    asset_server: Res\u003cAssetServer\u003e,\n) {\n    // Game Level Display (top-center)\n    commands.spawn((\n        Text::new(\"Game Level: 1\"),\n        TextFont {\n            font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\n            font_size: 24.0,\n            ..default()\n        },\n        TextColor(Color::WHITE),\n        Node {\n            position_type: PositionType::Absolute,\n            top: Val::Px(10.0),\n            left: Val::Percent(50.0),\n            ..default()\n        },\n        GameLevelDisplay,\n    ));\n\n    // Kill Progress (below game level)\n    commands.spawn((\n        Text::new(\"Kills: 0/10\"),\n        TextFont {\n            font: asset_server.load(\"fonts/FiraSans-Regular.ttf\"),\n            font_size: 16.0,\n            ..default()\n        },\n        TextColor(Color::srgba(1.0, 1.0, 1.0, 0.7)),\n        Node {\n            position_type: PositionType::Absolute,\n            top: Val::Px(40.0),\n            left: Val::Percent(50.0),\n            ..default()\n        },\n        KillProgressDisplay,\n    ));\n\n    // Player Level (top-left, below health)\n    commands.spawn((\n        Text::new(\"Player Lv: 1\"),\n        TextFont {\n            font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\n            font_size: 20.0,\n            ..default()\n        },\n        TextColor(Color::srgb(0.8, 0.8, 1.0)),\n        Node {\n            position_type: PositionType::Absolute,\n            top: Val::Px(70.0),\n            left: Val::Px(10.0),\n            ..default()\n        },\n        PlayerLevelDisplay,\n    ));\n\n    // XP Progress Bar Container\n    commands.spawn((\n        Node {\n            position_type: PositionType::Absolute,\n            top: Val::Px(95.0),\n            left: Val::Px(10.0),\n            width: Val::Px(150.0),\n            height: Val::Px(8.0),\n            ..default()\n        },\n        BackgroundColor(Color::srgba(0.2, 0.2, 0.2, 0.8)),\n        XpProgressBar,\n    )).with_children(|parent| {\n        // XP Progress Bar Fill\n        parent.spawn((\n            Node {\n                width: Val::Percent(0.0),\n                height: Val::Percent(100.0),\n                ..default()\n            },\n            BackgroundColor(Color::srgb(0.4, 0.8, 1.0)),\n            XpProgressBarFill,\n        ));\n    });\n}\n```\n\n### UI Update Systems\n```rust\n/// Update game level display\npub fn update_game_level_display(\n    game_level: Res\u003cGameLevel\u003e,\n    mut query: Query\u003c\u0026mut Text, With\u003cGameLevelDisplay\u003e\u003e,\n) {\n    if game_level.is_changed() {\n        for mut text in query.iter_mut() {\n            text.0 = format\\!(\"Game Level: {}\", game_level.level);\n        }\n    }\n}\n\n/// Update kill progress display\npub fn update_kill_progress_display(\n    game_level: Res\u003cGameLevel\u003e,\n    mut query: Query\u003c\u0026mut Text, With\u003cKillProgressDisplay\u003e\u003e,\n) {\n    if game_level.is_changed() {\n        for mut text in query.iter_mut() {\n            text.0 = format\\!(\n                \"Kills: {}/{}\", \n                game_level.kills_this_level, \n                game_level.kills_to_advance()\n            );\n        }\n    }\n}\n\n/// Update player level display\npub fn update_player_level_display(\n    player_query: Query\u003c\u0026PlayerExperience, (With\u003cPlayer\u003e, Changed\u003cPlayerExperience\u003e)\u003e,\n    mut text_query: Query\u003c\u0026mut Text, With\u003cPlayerLevelDisplay\u003e\u003e,\n) {\n    if let Ok(exp) = player_query.get_single() {\n        for mut text in text_query.iter_mut() {\n            text.0 = format\\!(\"Player Lv: {}\", exp.level);\n        }\n    }\n}\n\n/// Update XP progress bar\npub fn update_xp_progress_bar(\n    player_query: Query\u003c\u0026PlayerExperience, (With\u003cPlayer\u003e, Changed\u003cPlayerExperience\u003e)\u003e,\n    mut bar_query: Query\u003c\u0026mut Node, With\u003cXpProgressBarFill\u003e\u003e,\n) {\n    if let Ok(exp) = player_query.get_single() {\n        for mut node in bar_query.iter_mut() {\n            node.width = Val::Percent(exp.progress() * 100.0);\n        }\n    }\n}\n```\n\n### Plugin Registration\n```rust\napp\n    .add_systems(OnEnter(GameState::InGame), setup_progression_ui)\n    .add_systems(\n        Update,\n        (\n            update_game_level_display,\n            update_kill_progress_display,\n            update_player_level_display,\n            update_xp_progress_bar,\n        )\n            .run_if(in_state(GameState::InGame)),\n    );\n```\n\n## UI Layout\n```\n+------------------------------------------+\n|  HP: 100/100      Game Level: 3          |\n|  Player Lv: 5     Kills: 15/23           |\n|  [=======   ] XP                         |\n|                                          |\n|                                          |\n|              (Game Area)                 |\n|                                          |\n|                                   Score: |\n|                                   Time:  |\n+------------------------------------------+\n```\n\n## ECS Pattern\nUI elements use marker components for efficient querying:\n```rust\n// Only update changed elements\nfn update_display(\n    resource: Res\u003cSomeResource\u003e,\n    mut query: Query\u003c\u0026mut Text, With\u003cSomeMarker\u003e\u003e,\n) {\n    if resource.is_changed() {\n        // Update UI\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] Game level displayed prominently (top-center)\n- [ ] Kill progress shown as \"X/Y kills\"\n- [ ] Player level displayed (top-left area)\n- [ ] XP progress bar shows fill percentage\n- [ ] UI updates only when relevant data changes (efficiency)\n- [ ] UI elements cleaned up on game exit\n- [ ] Text is legible against game background\n- [ ] Visual test: UI elements don't overlap\n\n## Test Requirements\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // UI tests typically require visual inspection\n    // But we can test component marker existence\n    \n    #[test]\n    fn ui_markers_are_unique() {\n        // Compile-time test - markers are distinct types\n        let _game: GameLevelDisplay = GameLevelDisplay;\n        let _player: PlayerLevelDisplay = PlayerLevelDisplay;\n        // If this compiles, markers are distinct\n    }\n}\n```","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-30T09:44:49.137335+11:00","updated_at":"2025-12-30T11:34:47.467474+11:00","closed_at":"2025-12-30T11:34:47.467474+11:00","dependencies":[{"issue_id":"dt-survivor-c8q","depends_on_id":"dt-survivor-ahu","type":"blocks","created_at":"2025-12-30T09:45:07.983629+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-c8q","depends_on_id":"dt-survivor-cp8","type":"blocks","created_at":"2025-12-30T09:45:08.071808+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-c8q","depends_on_id":"dt-survivor-aiy","type":"parent-child","created_at":"2025-12-30T09:45:19.558843+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-cch","title":"Populate weapon plugin with systems","description":"Move weapon systems from src/game/plugin.rs to src/weapon/plugin.rs: weapon_firing_system, weapon_follow_player_system. Update game/plugin.rs to add WeaponPlugin as sub-plugin. Currently weapon/plugin.rs is an empty stub.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T17:41:29.82361+11:00","updated_at":"2025-12-25T19:32:50.913061+11:00","closed_at":"2025-12-25T19:32:50.913061+11:00","dependencies":[{"issue_id":"dt-survivor-cch","depends_on_id":"dt-survivor-7gg","type":"blocks","created_at":"2025-12-25T17:41:45.529638+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-cch","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:41:46.130346+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-co2","title":"Implement Neurotoxin Spell (Poison)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Neurotoxin\n- **Element**: Poison\n- **Behavior**: Poison that increases enemy erratic movement. A debuff that makes enemy movement random and jittery. Enemies move unpredictably, making it harder for them to reach the player effectively.\n\n## ECS Implementation\n\n### Components\n- `NeurotoxinDebuff { duration: Timer, jitter_amount: f32, jitter_timer: Timer }` - Debuff that adds random movement offsets to enemy pathing\n\n### Systems\n- `apply_neurotoxin_on_poison_hit` - Applies debuff when specific poison spell hits\n- `neurotoxin_movement_jitter` - Adds random direction offsets to enemy movement\n- `neurotoxin_duration_tick` - Counts down debuff duration\n- `cleanup_neurotoxin_debuff` - Removes debuff when expired\n\n### File Location\n`src/spells/poison/neurotoxin.rs`\n\n## Visual Design\n- Debuff indicator: Purple-green swirling effect around enemy head\n- Movement: Visible stuttering/jerking motion\n- Trail: Erratic path particles showing confused movement\n- Poison element uses green/toxic colors with purple accents for neural effects\n\n## Acceptance Criteria\n- [ ] Neurotoxin debuff applied on specific poison spell hit\n- [ ] Affected enemies have random direction added to movement\n- [ ] Jitter amount scales with spell level\n- [ ] Jitter occurs at configured intervals (not every frame)\n- [ ] Visual clearly shows affected enemies\n- [ ] Debuff expires after duration\n- [ ] Does not completely prevent movement, just disrupts it\n\n## Required Tests\n- `test_neurotoxin_applied_on_hit` - Verify debuff application\n- `test_neurotoxin_adds_movement_jitter` - Verify movement disruption\n- `test_neurotoxin_jitter_amount_scales` - Verify scaling with level\n- `test_neurotoxin_jitter_interval` - Verify jitter timing\n- `test_neurotoxin_expires_after_duration` - Verify cleanup\n- `test_neurotoxin_enemy_still_moves` - Verify movement not blocked\n- `test_neurotoxin_multiple_enemies` - Verify independent debuffs","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:12:19.818464+11:00","updated_at":"2026-01-02T03:56:53.883901+11:00","closed_at":"2026-01-02T03:56:53.883901+11:00","dependencies":[{"issue_id":"dt-survivor-co2","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:12:26.922558+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-cp8","title":"Implement Player leveling with increasing XP requirements","description":"Enhance the player leveling system so that leveling up requires increasing amounts of XP. XP resets on level up.\n\n## Context\nCurrent implementation in src/experience/components.rs has PlayerExperience with current and level fields. The experience_orb_collection_system in src/experience/systems.rs adds XP when orbs are collected. This task enhances the leveling mechanics.\n\n## Implementation\n\n### Updated PlayerExperience Component (src/experience/components.rs)\n```rust\n/// Configuration for player XP requirements\n#[derive(Debug, Clone)]\npub struct ExperienceConfig {\n    /// Base XP needed for level 2\n    pub base_xp: u32,\n    /// Multiplier per level (xp_needed = base_xp * multiplier^(level-1))\n    pub xp_multiplier: f32,\n}\n\nimpl Default for ExperienceConfig {\n    fn default() -\u003e Self {\n        Self {\n            base_xp: 100,\n            xp_multiplier: 1.5,\n        }\n    }\n}\n\n/// Tracks player experience and level\n#[derive(Component, Debug, Default)]\npub struct PlayerExperience {\n    /// Current XP in this level\n    pub current: u32,\n    /// Current player level (starts at 1)\n    pub level: u32,\n    /// Total XP ever gained (for stats)\n    pub total_xp: u32,\n    /// Configuration\n    pub config: ExperienceConfig,\n}\n\nimpl PlayerExperience {\n    pub fn new() -\u003e Self {\n        Self {\n            current: 0,\n            level: 1,\n            total_xp: 0,\n            config: ExperienceConfig::default(),\n        }\n    }\n\n    /// XP needed to advance from current level\n    pub fn xp_to_next_level(\u0026self) -\u003e u32 {\n        let multiplier = self.config.xp_multiplier.powi(self.level as i32 - 1);\n        (self.config.base_xp as f32 * multiplier).ceil() as u32\n    }\n\n    /// Add XP and return number of levels gained\n    pub fn add_xp(\u0026mut self, amount: u32) -\u003e u32 {\n        self.current += amount;\n        self.total_xp += amount;\n        \n        let mut levels_gained = 0;\n        while self.current \u003e= self.xp_to_next_level() {\n            self.current -= self.xp_to_next_level();\n            self.level += 1;\n            levels_gained += 1;\n        }\n        levels_gained\n    }\n\n    /// Progress percentage toward next level (0.0 - 1.0)\n    pub fn progress(\u0026self) -\u003e f32 {\n        self.current as f32 / self.xp_to_next_level() as f32\n    }\n}\n```\n\n### Event Definition (src/experience/events.rs or components.rs)\n```rust\n/// Fired when player gains a level\n#[derive(Message, Debug)]\npub struct PlayerLevelUpEvent {\n    pub new_level: u32,\n    pub levels_gained: u32,\n}\n```\n\n### Updated Experience Collection System (src/experience/systems.rs)\n```rust\npub fn experience_orb_collection_system(\n    mut effect_events: MessageReader\u003cItemEffectEvent\u003e,\n    orb_query: Query\u003c\u0026ExperienceOrb\u003e,\n    mut player_query: Query\u003c\u0026mut PlayerExperience, With\u003cPlayer\u003e\u003e,\n    mut level_up_writer: MessageWriter\u003cPlayerLevelUpEvent\u003e,\n) {\n    for event in effect_events.read() {\n        if let ItemData::Experience = event.item_data {\n            if let Ok(orb) = orb_query.get(event.source_entity) {\n                if let Ok(mut exp) = player_query.get_single_mut() {\n                    let levels_gained = exp.add_xp(orb.value);\n                    \n                    if levels_gained \u003e 0 {\n                        level_up_writer.write(PlayerLevelUpEvent {\n                            new_level: exp.level,\n                            levels_gained,\n                        });\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n### Level Up Visual Effect (optional system)\n```rust\npub fn player_level_up_effect_system(\n    mut level_up_events: MessageReader\u003cPlayerLevelUpEvent\u003e,\n    mut screen_tint: ResMut\u003cScreenTintEffect\u003e,\n) {\n    for event in level_up_events.read() {\n        // Gold screen flash for level up\n        screen_tint.set_color(Color::srgb(1.0, 0.84, 0.0), 0.3);\n    }\n}\n```\n\n### Reset on Game Start\n```rust\npub fn reset_player_experience(\n    mut player_query: Query\u003c\u0026mut PlayerExperience, With\u003cPlayer\u003e\u003e,\n) {\n    if let Ok(mut exp) = player_query.get_single_mut() {\n        *exp = PlayerExperience::new();\n    }\n}\n```\n\n## XP Requirements Table\nWith default config (base_xp=100, multiplier=1.5):\n| Level | XP to Next Level | Cumulative XP |\n|-------|------------------|---------------|\n| 1     | 100              | 0             |\n| 2     | 150              | 100           |\n| 3     | 225              | 250           |\n| 4     | 338              | 475           |\n| 5     | 506              | 813           |\n| 10    | 2,562            | 5,075         |\n\n## ECS Pattern\n```rust\n// Query player experience\nfn show_player_xp(\n    query: Query\u003c\u0026PlayerExperience, With\u003cPlayer\u003e\u003e,\n) {\n    if let Ok(exp) = query.get_single() {\n        println!(\"Level {} - {}/{} XP ({:.0}%)\", \n            exp.level, \n            exp.current, \n            exp.xp_to_next_level(),\n            exp.progress() * 100.0\n        );\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] PlayerExperience tracks current XP, level, and total XP\n- [ ] xp_to_next_level() returns correct threshold with multiplier\n- [ ] add_xp() handles level-ups correctly, including multiple at once\n- [ ] XP resets to remainder after level up (not zero)\n- [ ] PlayerLevelUpEvent fired on level up\n- [ ] Unit tests for XP threshold calculations\n- [ ] Unit tests for add_xp level-up behavior\n- [ ] Unit tests for progress percentage\n\n## Test Requirements\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn player_experience_starts_at_level_one() {\n        let exp = PlayerExperience::new();\n        assert_eq!(exp.level, 1);\n        assert_eq!(exp.current, 0);\n    }\n\n    #[test]\n    fn xp_to_next_level_increases_each_level() {\n        let mut exp = PlayerExperience::new();\n        let xp_1 = exp.xp_to_next_level();\n        exp.level = 2;\n        let xp_2 = exp.xp_to_next_level();\n        assert!(xp_2 \u003e xp_1);\n    }\n\n    #[test]\n    fn add_xp_levels_up_and_keeps_remainder() {\n        let mut exp = PlayerExperience::new();\n        let threshold = exp.xp_to_next_level();\n        let levels = exp.add_xp(threshold + 10);\n        assert_eq!(levels, 1);\n        assert_eq!(exp.level, 2);\n        assert_eq!(exp.current, 10);\n    }\n\n    #[test]\n    fn add_xp_handles_multiple_level_ups() {\n        let mut exp = PlayerExperience::new();\n        let levels = exp.add_xp(1000); // Should gain multiple levels\n        assert!(levels \u003e 1);\n        assert!(exp.level \u003e 2);\n    }\n\n    #[test]\n    fn progress_returns_correct_percentage() {\n        let mut exp = PlayerExperience::new();\n        exp.current = 50;\n        // With base_xp=100, progress should be 0.5\n        assert!((exp.progress() - 0.5).abs() \u003c 0.01);\n    }\n}\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-30T09:43:44.1818+11:00","updated_at":"2025-12-30T11:15:02.073432+11:00","closed_at":"2025-12-30T11:15:02.073432+11:00","dependencies":[{"issue_id":"dt-survivor-cp8","depends_on_id":"dt-survivor-3l7","type":"blocks","created_at":"2025-12-30T09:45:07.33636+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-cp8","depends_on_id":"dt-survivor-1qz","type":"blocks","created_at":"2025-12-30T09:45:07.638986+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-cp8","depends_on_id":"dt-survivor-aiy","type":"parent-child","created_at":"2025-12-30T09:45:19.413958+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-cq2","title":"Add bevy_lit and bevy_hanabi dependencies for Whisper visual effects","description":"Add the following dependencies to Cargo.toml for advanced Whisper visual effects:\n- bevy_lit 0.9 for 2D lighting (PointLight2d)\n- bevy_hanabi 0.17 for GPU particle effects\n\nThese are needed to implement the full lightning ball visual effect for Whisper.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-26T09:17:14.884699+11:00","updated_at":"2025-12-26T09:19:21.840097+11:00","closed_at":"2025-12-26T09:19:21.840097+11:00"}
{"id":"dt-survivor-cxm","title":"Implement Ember Swarm Spell (Fire)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Ember Swarm\n- **Element**: Fire\n- **Behavior**: Small fire wisps orbit briefly before launching outward. On cast, spawns 5-8 ember wisps that orbit around the player for 1-2 seconds. After orbit phase completes, all wisps simultaneously launch toward the nearest enemies.\n\n## ECS Implementation\n\n### Components\n- `EmberWisp { orbit_phase: f32, orbit_time_remaining: f32, orbit_radius: f32, damage: f32 }` - Individual wisp tracking orbit state\n- `EmberSwarmController { wisp_count: u8, orbit_duration: f32, wisps: Vec\u003cEntity\u003e }` - Manages the swarm lifecycle\n- `LaunchingWisp { target: Option\u003cEntity\u003e, speed: f32 }` - Added when wisp transitions to attack phase\n\n### Systems\n- `spawn_ember_swarm` - Creates controller and 5-8 wisps around player\n- `orbit_ember_wisps` - Updates wisp positions in circular orbit around player\n- `launch_ember_wisps` - Triggers when orbit_time_remaining expires, adds LaunchingWisp\n- `move_launched_wisps` - Moves wisps toward their targets\n- `ember_wisp_collision` - Handles damage when launched wisp hits enemy\n- `cleanup_ember_swarm` - Removes controller and any remaining wisps\n\n### File Location\n`src/spells/fire/ember_swarm.rs`\n\n## Visual Design\n- Small glowing orange-yellow ember particles\n- Orbiting phase: wisps leave faint fire trails as they circle\n- Launch phase: wisps streak toward targets with intensified glow\n- Small explosion particle effect on enemy hit\n\n## Acceptance Criteria\n- [ ] Cast spawns 5-8 wisps orbiting player position\n- [ ] Wisps maintain circular orbit for configured duration\n- [ ] After orbit phase, all wisps launch toward nearest enemies\n- [ ] Launched wisps home toward their target enemy\n- [ ] Wisps deal damage on contact and despawn\n- [ ] Wisps without valid target fly outward and despawn off-screen\n- [ ] Visual trails follow wisps during both phases\n\n## Required Tests\n- `test_ember_swarm_spawns_correct_wisp_count` - Verify 5-8 wisps created\n- `test_ember_wisps_orbit_player` - Verify wisps circle around player position\n- `test_ember_wisps_follow_player` - Verify orbit center moves with player\n- `test_ember_wisps_launch_after_duration` - Verify launch triggers at correct time\n- `test_launched_wisps_target_enemies` - Verify wisps seek nearest enemies\n- `test_ember_wisp_deals_damage` - Verify damage on enemy contact\n- `test_ember_wisp_despawns_on_hit` - Verify wisp removed after dealing damage\n- `test_ember_swarm_controller_cleanup` - Verify controller removed when all wisps gone","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:11:17.487203+11:00","updated_at":"2026-01-02T02:20:38.760852+11:00","closed_at":"2026-01-02T02:20:38.760852+11:00","dependencies":[{"issue_id":"dt-survivor-cxm","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:11:22.697014+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-d0t","title":"Expand prelude.rs with new modules","description":"Update src/prelude.rs to include commonly used types from new modules: pub use crate::combat::*; pub use crate::movement::*; pub use crate::weapon::WeaponType;. Keeps imports convenient across codebase.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-25T17:42:02.74856+11:00","updated_at":"2025-12-25T20:09:58.443274+11:00","closed_at":"2025-12-25T20:09:58.443274+11:00","dependencies":[{"issue_id":"dt-survivor-d0t","depends_on_id":"dt-survivor-xp9","type":"blocks","created_at":"2025-12-25T17:42:20.114365+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-d0t","depends_on_id":"dt-survivor-3z7","type":"blocks","created_at":"2025-12-25T17:42:20.201006+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-d0t","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:42:21.416994+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-d7a","title":"Implement Purify Spell (Light)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Purify\n- **Element**: Light\n- **Behavior**: Removes debuffs from the player and damages nearby enemies. Instant burst effect that cleanses negative status effects from the player while dealing radiant damage to all enemies in a radius around the player.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct PurifyCaster {\n    pub cooldown: Timer,\n    pub radius: f32,\n    pub damage: f32,\n}\n\n#[derive(Component)]\npub struct PurifyBurst {\n    pub center: Vec2,\n    pub radius: f32,\n    pub damage: f32,\n}\n```\n\n### Systems\n- `spawn_purify_caster` - Creates caster component on player when spell activates\n- `trigger_purify_burst` - Fires burst when cooldown ready (auto or on command)\n- `cleanse_player_debuffs` - Removes negative status effects from player\n- `spawn_purify_visual` - Creates burst visual effect\n- `apply_purify_damage` - Damages all enemies within radius\n- `update_purify_cooldown` - Ticks cooldown timer\n- `cleanup_purify_caster` - Removes caster on spell deactivation\n\n### File Location\n`src/spells/light/purify.rs`\n\n## Visual Design\n- Radiant burst of white/gold light emanating from player\n- Expanding ring wave effect\n- Purification sparkles clearing from player\n- Enemies hit flash with holy light\n- Brief screen brightening effect\n\n## Acceptance Criteria\n- [ ] Purify triggers burst damage in radius around player\n- [ ] All enemies within radius take damage\n- [ ] Debuffs cleared from player on activation (if debuff system exists)\n- [ ] Cooldown prevents spam activation\n- [ ] Visual burst effect clearly shows affected area\n- [ ] Damage and radius are configurable\n- [ ] Works even if no debuffs present (still deals damage)\n\n## Required Tests\n- [ ] Test caster spawns with correct configuration\n- [ ] Test burst triggers after cooldown ready\n- [ ] Test damage applies to all enemies in radius\n- [ ] Test enemies outside radius not damaged\n- [ ] Test cooldown timer prevents immediate re-trigger\n- [ ] Test debuff removal from player (when debuff system exists)\n- [ ] Test burst works with no debuffs present\n- [ ] Test multiple enemies damaged by single burst\n\n## Implementation Notes\n- Debuff cleansing may need placeholder implementation if player debuff system doesn't exist yet\n- Consider which debuffs should be cleansable (poison, slow, blind, etc.)\n- May need to define a Cleansable marker component for debuffs","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:18:33.120079+11:00","updated_at":"2026-01-02T09:20:54.609711+11:00","closed_at":"2026-01-02T09:20:54.609711+11:00","dependencies":[{"issue_id":"dt-survivor-d7a","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:18:39.516383+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-d7v","title":"Implement Ice Shards Spell (Frost)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Ice Shards\n- **Element**: Frost\n- **Behavior**: Multiple sharp ice fragments fire in a cone pattern. Fires 5-7 shards in a 60-degree cone toward target direction. Each shard damages independently, allowing for multi-hit potential on grouped enemies.\n\n## ECS Implementation\n\n### Components to Create\n- `IceShard { direction: Vec2 }` - Individual shard projectile with its specific direction\n- `IceShardsSpread { shard_count: u32, cone_angle: f32 }` - Configuration for the cone spread pattern\n- `IceShardSource` - Marker to track which spell instance spawned the shards\n\n### Systems Needed\n- `spawn_ice_shards` - Creates 5-7 shard entities spread across 60-degree cone\n- `update_ice_shard_movement` - Moves each shard along its individual direction\n- `ice_shard_enemy_collision` - Handles per-shard collision and damage\n- `cleanup_ice_shards` - Despawns shards after max range or collision\n\n### File Location\n`src/spells/frost/ice_shards.rs`\n\n## Visual Design\n- Sharp, angular ice crystal shards in ice blue/cyan color\n- Each shard has slight rotation animation as it travels\n- Crystalline sparkle particle trail on each shard\n- On-hit: shard shatters into smaller ice particle burst\n\n## Acceptance Criteria\n- [ ] Ice Shards spawns 5-7 individual shard projectiles per cast\n- [ ] Shards spread evenly across a 60-degree cone toward target\n- [ ] Each shard moves independently in its assigned direction\n- [ ] Each shard deals damage independently on collision\n- [ ] Shards despawn on collision with enemy or at max range\n- [ ] Multiple shards can hit the same large enemy\n- [ ] Spread pattern is consistent and visually satisfying\n\n## Required Tests\n- [ ] Test ice_shards spawns correct number of shard entities (5-7)\n- [ ] Test shards are distributed evenly within 60-degree cone\n- [ ] Test each shard moves in its assigned direction\n- [ ] Test each shard deals independent damage on collision\n- [ ] Test shard despawns on enemy collision\n- [ ] Test shard despawns at max range\n- [ ] Test multiple shards can damage same enemy if large enough hitbox\n- [ ] Test cone direction is correctly oriented toward target","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:10:47.928399+11:00","updated_at":"2026-01-02T01:20:22.735178+11:00","closed_at":"2026-01-02T01:20:22.735178+11:00","dependencies":[{"issue_id":"dt-survivor-d7v","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:10:53.43544+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-dwo","title":"Migrate Pistol to Fireball Spell","description":"## Context\n\nPart of the spells refactoring epic (dt-survivor-jdd) to migrate existing weapons into an elemental spell system. The Pistol weapon becomes the Fireball spell - a fire-element projectile that deals direct damage plus burn damage over time.\n\n## Implementation Details\n\n### File Migration\n- Move logic from `src/pistol/` into `src/spells/fire/fireball.rs`\n- Create `src/spells/fire/mod.rs` to export fireball module\n\n### Spell Mechanics\n- **Fireball**: Straight-line projectile that ignites enemies on hit\n- **Element**: Fire (orange-red visuals)\n- **Primary damage**: Direct hit damage (scales with level)\n- **Secondary effect**: Burn DOT - applies BurnEffect component to hit enemies\n\n### ECS Components to Create\n- `FireballProjectile` - marker component for fireball entities\n- `BurnEffect` - component attached to enemies, contains:\n  - `tick_timer: Timer` - time between damage ticks\n  - `remaining_ticks: u32` - number of ticks remaining\n  - `tick_damage: f32` - damage per tick\n  - `total_duration: Timer` - total burn duration\n\n### Reuse from Pistol\n- Bullet spawning system patterns\n- Spread pattern calculation for multi-projectile\n- Collision detection with enemies\n- Projectile movement via Velocity component\n- Level scaling (damage, fire rate, projectile count)\n\n### Visual Changes\n- Replace bullet sprite with fireball (orange-red particle/sprite)\n- Add flame trail effect (optional, can be follow-up)\n\n## Acceptance Criteria\n\n- [ ] Fireball projectiles spawn from player position\n- [ ] Projectiles travel in straight line using Velocity component\n- [ ] Multi-projectile spread pattern works at higher levels\n- [ ] Direct collision damage applied on enemy hit\n- [ ] BurnEffect component added to enemy on hit\n- [ ] Burn ticks deal damage over time\n- [ ] Burn effect expires after duration\n- [ ] Fire rate respects spell cooldown\n- [ ] Damage scales with spell level\n- [ ] Old pistol code can be removed after migration\n\n## Required Tests\n\n1. **Projectile Movement**: Fireball moves in correct direction at expected speed\n2. **Collision Damage**: Direct hit applies base damage to enemy Health\n3. **Burn Application**: Enemy receives BurnEffect component on hit\n4. **Burn DOT Ticks**: BurnEffect deals tick_damage at correct intervals\n5. **Burn Expiration**: BurnEffect removed after all ticks consumed\n6. **Level Scaling**: Higher levels increase damage/projectile count\n7. **Spread Pattern**: Multi-projectile spread calculates correctly\n8. **Cooldown**: Cannot cast faster than cooldown allows","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-01T21:04:15.012692+11:00","updated_at":"2026-01-01T23:00:37.319094+11:00","closed_at":"2026-01-01T23:00:37.319094+11:00","dependencies":[{"issue_id":"dt-survivor-dwo","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:04:34.505462+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-e2t","title":"Final integration testing and cleanup for 3D migration","description":"# Task: 3D Migration Integration Testing\n\n## Context\nThis is the final task in the 2D to 3D migration. After all individual components have been converted, this task verifies the complete system works together and cleans up any remaining 2D artifacts.\n\n## Prerequisites\nAll other migration tasks must be complete:\n- Camera and lighting infrastructure\n- Shared mesh/material resources\n- All entity spawning (player, enemies, bullets, loot)\n- Movement systems XZ conversion\n- Camera follow system\n- Mouse input ray casting\n- Collision detection\n- Whisper particle replacement\n- Laser 3D conversion\n- Rocket/explosion 3D conversion\n\n## Required Changes\n\n### 1. Remove All 2D Dependencies\nVerify no remaining usage of:\n- `Sprite` or `SpriteBundle`\n- `Camera2d` or `Camera2dBundle`\n- `Mesh2d` or `MeshMaterial2d`\n- `Material2d` trait implementations\n- `viewport_to_world_2d`\n- `.truncate()` for XY extraction (should be XZ)\n- `.extend(0.0)` for XY movement (should be XZ)\n\n### 2. Update Cargo.toml\nRemove unused 2D dependencies if applicable:\n- `bevy_lit` (2D lighting - already removed from plugin)\n- Any 2D-specific feature flags\n\n### 3. Clean Up Shader Files\nIf Whisper 2D shaders are no longer used, remove:\n- `assets/shaders/additive_textured.wgsl`\n- `assets/shaders/additive_color.wgsl`\n\nOr keep them marked as deprecated if they might be ported to 3D later.\n\n### 4. Integration Tests\n\n**Full Game Loop Test**:\n```rust\n#[test]\nfn test_game_runs_in_3d() {\n    let mut app = App::new();\n    // Add all plugins\n    // Verify game starts without panic\n    // Verify camera is Camera3d\n    // Verify entities have Mesh3d components\n}\n```\n\n**Gameplay Integration Tests**:\n- Player can move in 3D world\n- Enemies spawn and chase player\n- Bullets fire and hit enemies\n- Loot drops and can be picked up\n- All weapons function (pistol, laser, rocket, whisper)\n- Camera follows player correctly\n- Collisions detected properly\n\n### 5. Visual Verification Checklist\nRun the game and verify:\n- [ ] Ground plane visible\n- [ ] Player cube visible and controllable\n- [ ] Enemies spawn as red cubes around player\n- [ ] Bullets fire as yellow cubes toward enemies\n- [ ] Loot drops when enemies die\n- [ ] Laser beam renders correctly\n- [ ] Rockets fire and explode\n- [ ] Whisper particles visible\n- [ ] Camera maintains isometric angle\n- [ ] Lighting illuminates scene properly\n- [ ] HDR bloom still functional\n\n### 6. Performance Verification\n- [ ] Frame rate acceptable (\u003e30 FPS minimum)\n- [ ] No memory leaks from mesh/material creation\n- [ ] Entity count manageable\n\n### 7. Code Cleanup\n- Remove any TODO comments from migration\n- Ensure all tests pass: `make test`\n- Ensure linting passes: `make lint`\n- Update CLAUDE.md if any patterns changed\n\n## Testing Requirements\n- All existing tests pass after migration\n- Integration test for complete game loop\n- Each weapon system verified functional\n- Collision systems verified\n- Camera system verified\n- 90% code coverage maintained\n\n## Acceptance Criteria\n- [ ] No 2D components remain in codebase\n- [ ] Game runs without crashes\n- [ ] All gameplay systems functional in 3D\n- [ ] Visual appearance acceptable (cubes visible, lit, positioned)\n- [ ] Performance acceptable\n- [ ] All tests pass\n- [ ] No linting warnings\n- [ ] Code coverage \u003e= 90%\n- [ ] `make check \u0026\u0026 make lint \u0026\u0026 make test` all pass","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:50:00.104469+11:00","updated_at":"2025-12-28T11:24:20.612675+11:00","closed_at":"2025-12-28T11:24:20.612675+11:00","dependencies":[{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:34.028625+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-nq8","type":"blocks","created_at":"2025-12-28T09:50:39.848344+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-ggr","type":"blocks","created_at":"2025-12-28T09:50:39.912395+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-0ql","type":"blocks","created_at":"2025-12-28T09:50:39.976026+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-a2s","type":"blocks","created_at":"2025-12-28T09:50:40.041274+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-b67","type":"blocks","created_at":"2025-12-28T09:50:40.108377+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-umn","type":"blocks","created_at":"2025-12-28T09:50:40.172856+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-4i1","type":"blocks","created_at":"2025-12-28T09:50:40.240437+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-ryh","type":"blocks","created_at":"2025-12-28T09:50:40.306979+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-qy4","type":"blocks","created_at":"2025-12-28T09:50:40.372771+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-z7l","type":"blocks","created_at":"2025-12-28T09:50:40.438933+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-rfz","type":"blocks","created_at":"2025-12-28T09:50:40.507864+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-e43","type":"blocks","created_at":"2025-12-28T09:50:40.574685+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-8i6","type":"blocks","created_at":"2025-12-28T09:50:40.642763+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-e43","title":"Convert laser weapon rendering to 3D","description":"# Task: Laser Weapon 3D Conversion\n\n## Context\nDT Survivor is migrating from 2D to 3D. The laser weapon renders as a stretched sprite beam and needs to be converted to 3D geometry (stretched cube or cylinder).\n\n## Current Implementation\n**Laser Spawning** (`src/laser/systems.rs`):\n- Uses `Sprite::from_color()` with cyan color\n- Stretched in one dimension for beam effect\n- Rotated to point from player toward enemies\n- Transform positioned between player and target\n\n## Required Changes\n\n### 1. Replace Sprite with 3D Mesh\n```rust\n// Before\ncommands.spawn((\n    Sprite::from_color(Color::srgb(0.0, 1.0, 1.0), Vec2::new(width, length)),\n    Transform { ... },\n    Laser { ... },\n));\n\n// After\ncommands.spawn((\n    Mesh3d(meshes.add(Cuboid::new(0.1, 0.1, length))), // Thin, long cube\n    MeshMaterial3d(materials.add(StandardMaterial {\n        base_color: Color::srgb(0.0, 1.0, 1.0),\n        emissive: LinearRgba::rgb(0.0, 1.0, 1.0), // Glowing effect\n        ..default()\n    })),\n    Transform {\n        translation: midpoint,\n        rotation: rotation_to_target,\n        ..default()\n    },\n    Laser { ... },\n));\n```\n\n### 2. Update Laser Position Calculation\nConvert from XY to XZ:\n```rust\n// Before\nlet player_pos = player_transform.translation.truncate();\nlet target_pos = enemy_transform.translation.truncate();\nlet midpoint = (player_pos + target_pos) / 2.0;\n\n// After\nlet player_xz = Vec2::new(player_transform.translation.x, player_transform.translation.z);\nlet target_xz = Vec2::new(enemy_transform.translation.x, enemy_transform.translation.z);\nlet midpoint_xz = (player_xz + target_xz) / 2.0;\nlet midpoint = Vec3::new(midpoint_xz.x, 0.5, midpoint_xz.y); // Y at entity height\n```\n\n### 3. Update Laser Rotation\nFor 3D, rotation should be around Y axis to point toward target on XZ plane:\n```rust\nlet direction = (target_xz - player_xz).normalize();\nlet angle = direction.y.atan2(direction.x);\nlet rotation = Quat::from_rotation_y(-angle + std::f32::consts::FRAC_PI_2);\n```\n\n### 4. Update Laser Hit Detection\nAlready covered in collision detection task, but ensure laser line segment uses XZ coordinates.\n\n### 5. Add Emissive Material for Glow\nUse emissive property of StandardMaterial for laser glow effect:\n```rust\nStandardMaterial {\n    base_color: Color::srgb(0.0, 1.0, 1.0),\n    emissive: LinearRgba::rgb(0.0, 2.0, 2.0), // HDR glow\n    unlit: true, // Don't apply lighting\n    ..default()\n}\n```\n\n## Testing Requirements\n- Unit test: Laser spawns with Mesh3d component\n- Unit test: Laser mesh is elongated cube/beam shape\n- Unit test: Laser positioned between player and target\n- Unit test: Laser rotation points toward target on XZ plane\n- Unit test: Laser Y position at entity height\n- Unit test: Laser material has emissive glow\n- Update existing laser tests for 3D\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] Laser renders as 3D beam (stretched cube)\n- [ ] Laser positioned correctly between player and enemy\n- [ ] Laser rotates to point at target on XZ plane\n- [ ] Laser has emissive/glowing appearance\n- [ ] Laser damage system unchanged\n- [ ] No Sprite components in laser\n- [ ] All laser tests updated and passing\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:49:22.09061+11:00","updated_at":"2025-12-28T10:35:44.834103+11:00","closed_at":"2025-12-28T10:35:44.834103+11:00","dependencies":[{"issue_id":"dt-survivor-e43","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.89797+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e43","depends_on_id":"dt-survivor-ggr","type":"blocks","created_at":"2025-12-28T09:50:35.562324+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-e9f","title":"Create Velocity and Speed components","description":"Create movement components in src/movement/components.rs: Velocity(Vec2), Speed(f32), Knockback { direction: Vec2, force: f32, duration: Timer }. These are reusable for player, enemies, and projectiles. Include tests.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T17:41:29.475915+11:00","updated_at":"2025-12-25T19:18:06.400837+11:00","closed_at":"2025-12-25T19:18:06.400837+11:00","dependencies":[{"issue_id":"dt-survivor-e9f","depends_on_id":"dt-survivor-6q4","type":"blocks","created_at":"2025-12-25T17:41:45.165143+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e9f","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:41:45.874979+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-e9h","title":"Implement Stormcall Spell (Lightning)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Stormcall\n- **Element**: Lightning\n- **Behavior**: Summons 3-5 roaming lightning strike markers around the player. Markers move randomly within range and periodically trigger lightning strikes at their locations, damaging enemies caught in the blast.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct StormcallMarker {\n    pub move_timer: Timer,\n    pub strike_timer: Timer,\n    pub roam_range: f32,\n    pub strike_radius: f32,\n    pub strike_damage: f32,\n}\n\n#[derive(Component)]\npub struct StormcallController {\n    pub marker_count: u8,\n    pub duration: Timer,\n}\n\n#[derive(Component)]\npub struct LightningStrike {\n    pub position: Vec3,\n    pub radius: f32,\n    pub damage: f32,\n}\n```\n\n### Systems\n- `stormcall_spawn` - Create controller and initial markers\n- `stormcall_marker_move` - Move markers to new random positions\n- `stormcall_marker_strike` - Trigger lightning at marker locations\n- `stormcall_strike_damage` - Apply AoE damage at strike locations\n- `stormcall_duration` - Despawn all when controller expires\n- `stormcall_visual` - Render markers and strike effects\n\n### File Location\n`src/spells/lightning/stormcall.rs`\n\n## Visual Design\n- Glowing marker circles on ground (yellow/electric blue)\n- Markers leave faint trail when moving\n- Dramatic vertical lightning bolt on strike\n- Ground crack/scorch effect at strike point\n- Screen shake on nearby strikes\n\n## Acceptance Criteria\n- [ ] Spawns 3-5 markers around player position\n- [ ] Markers move to new random positions on move_timer\n- [ ] Markers stay within roam_range of player\n- [ ] Each marker triggers strike on strike_timer\n- [ ] Strikes damage all enemies within strike_radius\n- [ ] All markers despawn when controller duration expires\n- [ ] Markers follow player as center reference\n\n## Required Tests\n- [ ] Test correct number of markers spawn (3-5)\n- [ ] Test markers spawn within roam_range of player\n- [ ] Test move_timer triggers position change\n- [ ] Test new positions stay within roam_range\n- [ ] Test strike_timer triggers lightning strike\n- [ ] Test strike damages enemies in radius\n- [ ] Test strike does not damage enemies outside radius\n- [ ] Test all markers despawn when duration expires","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:11:52.582931+11:00","updated_at":"2026-01-02T03:07:19.761+11:00","closed_at":"2026-01-02T03:07:19.761+11:00","dependencies":[{"issue_id":"dt-survivor-e9h","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:11:57.379009+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-ef9","title":"Implement Shadow Bolt Spell (Dark)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Shadow Bolt\n- **Element**: Dark\n- **Behavior**: Fast projectile dealing damage and restoring health. A standard projectile attack with built-in lifesteal mechanic. When the bolt hits an enemy, the player is healed for a percentage of the damage dealt.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct ShadowBoltProjectile {\n    pub damage: f32,\n    pub speed: f32,\n}\n\n#[derive(Component)]\npub struct Lifesteal {\n    pub percentage: f32,  // 0.0 to 1.0, percentage of damage returned as healing\n}\n```\n\n### Systems\n- `spawn_shadow_bolt` - Creates projectile entity with velocity toward target/cursor\n- `update_shadow_bolt_movement` - Move projectile each frame\n- `shadow_bolt_collision` - Handle enemy collision, apply damage and lifesteal healing\n- `cleanup_shadow_bolt` - Despawn on collision or after max range\n\n### File Location\n`src/spells/dark/shadow_bolt.rs`\n\n## Visual Design\n- Dark purple/black energy bolt with trailing shadows\n- Wispy shadow particles following projectile path\n- Dark flash effect on impact\n- Healing effect visual on player when lifesteal triggers\n\n## Acceptance Criteria\n- [ ] ShadowBoltProjectile component with damage and speed configuration\n- [ ] Lifesteal component tracks healing percentage\n- [ ] Projectile travels in straight line toward target direction\n- [ ] On enemy hit, damage applied and player healed for percentage\n- [ ] Projectile despawns on first enemy hit or after max range\n- [ ] Visual effects for projectile trail and impact\n- [ ] Spell integrates with 5-slot active spell system\n\n## Required Tests\n- [ ] Test projectile spawns with correct velocity\n- [ ] Test projectile moves at configured speed\n- [ ] Test projectile damages enemy on collision\n- [ ] Test lifesteal heals player for correct percentage of damage\n- [ ] Test projectile despawns after hitting enemy\n- [ ] Test projectile despawns after max range if no hit\n- [ ] Test lifesteal does not heal beyond player max health\n- [ ] Test multiple bolts can exist simultaneously","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:16:27.338025+11:00","updated_at":"2026-01-02T05:45:38.4685+11:00","closed_at":"2026-01-02T05:45:38.4685+11:00","dependencies":[{"issue_id":"dt-survivor-ef9","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:16:46.731639+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-en2","title":"Add New Game States","description":"## Context\n\nPart of the spells system refactoring for dt-survivor. This adds new game states to support the spell system UI: AttunementSelect for choosing starting element and InventoryOpen for managing spells.\n\n## Implementation Details\n\n### File Location\n- Modify: src/states.rs\n\n### New GameState Variants\n```rust\n#[derive(States, Default, Debug, Clone, PartialEq, Eq, Hash)]\npub enum GameState {\n    #[default]\n    MainMenu,\n    AttunementSelect,  // NEW: Player selects starting element attunement\n    InGame,\n    InventoryOpen,     // NEW: Player managing spell inventory\n    Paused,\n    GameOver,\n}\n```\n\n### State Transition Rules\n- MainMenu -\u003e AttunementSelect (when starting new game)\n- AttunementSelect -\u003e InGame (after selecting element)\n- InGame -\u003e InventoryOpen (when opening inventory)\n- InventoryOpen -\u003e InGame (when closing inventory)\n- InGame -\u003e Paused (when pausing)\n- InGame -\u003e GameOver (when player dies)\n\n### Integration Points\n- AttunementSelect will display element selection UI\n- InventoryOpen pauses gameplay and shows inventory screen\n- Systems should use run_if(in_state(...)) appropriately\n\n## ECS Patterns\n\n- Use Bevy States derive macro\n- Follow existing state pattern in codebase\n- Systems should run conditionally based on state\n\n## Acceptance Criteria\n\n- [ ] GameState::AttunementSelect variant added\n- [ ] GameState::InventoryOpen variant added\n- [ ] Existing states unchanged\n- [ ] States derive required traits (States, Default, Debug, Clone, PartialEq, Eq, Hash)\n- [ ] States registered correctly in app\n\n## Required Tests\n\n- Test GameState derives Clone\n- Test GameState derives PartialEq (equality comparison)\n- Test all states are distinct\n- Test default state is MainMenu\n- Test state transitions compile (in_state checks)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-01T21:06:26.607602+11:00","updated_at":"2026-01-01T22:35:42.491976+11:00","closed_at":"2026-01-01T22:35:42.491976+11:00","dependencies":[{"issue_id":"dt-survivor-en2","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:06:31.380761+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-eym","title":"Implement Wraith Form Spell (Dark)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Wraith Form\n- **Element**: Dark\n- **Behavior**: Temporarily pass through enemies while draining life. Player becomes intangible for a duration, allowing them to pass through enemies without collision. Enemies the player passes through take damage. Requires modification to player collision detection during active state.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct WraithForm {\n    pub duration: Timer,\n    pub damage_on_pass: f32,  // Damage dealt to enemies passed through\n}\n\n// Marker to track which enemies have been damaged this activation\n#[derive(Component)]\npub struct WraithFormDamagedBy {\n    pub wraith_activation_id: u64,  // Prevent double-damage same enemy\n}\n```\n\n### Systems\n- `activate_wraith_form` - Add WraithForm component to player, disable enemy collision\n- `update_wraith_form` - Tick duration, detect enemies player passes through\n- `wraith_form_damage` - Apply damage to enemies player overlaps with\n- `deactivate_wraith_form` - Remove component, restore collision when duration expires\n- `cleanup_wraith_form_markers` - Remove WraithFormDamagedBy markers after deactivation\n\n### File Location\n`src/spells/dark/wraith_form.rs`\n\n## Visual Design\n- Player becomes semi-transparent with dark shadow effect\n- Wispy shadow trail following player movement\n- Dark energy burst when passing through enemies\n- Gradual fade effect at start and end of wraith form\n\n## Acceptance Criteria\n- [ ] WraithForm component with duration and damage_on_pass configuration\n- [ ] Player collision with enemies disabled during wraith form\n- [ ] Enemies player passes through take damage_on_pass damage\n- [ ] Each enemy damaged only once per wraith form activation\n- [ ] Player visually appears as wraith/ghost during effect\n- [ ] Collision restored when duration expires\n- [ ] Spell integrates with 5-slot active spell system\n\n## Required Tests\n- [ ] Test player gains intangibility when wraith form activates\n- [ ] Test player can move through enemies without taking damage\n- [ ] Test enemies take damage when player passes through\n- [ ] Test enemy only damaged once per activation\n- [ ] Test wraith form expires after duration\n- [ ] Test collision restored after expiration\n- [ ] Test damage_on_pass applies correct amount\n- [ ] Test player collision with walls/environment unaffected (only enemy collision disabled)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:18:29.084476+11:00","updated_at":"2026-01-02T09:12:58.533074+11:00","closed_at":"2026-01-02T09:12:58.533074+11:00","dependencies":[{"issue_id":"dt-survivor-eym","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:18:50.01962+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-f77","title":"Add Health component to enemies","description":"Modify src/enemies/systems.rs to spawn enemies with Health component. Update src/bullets/systems.rs and src/laser/systems.rs to use DamageEvent instead of instant despawn. Enemies should now take damage and die when health reaches 0. Enables multi-hit enemies and boss fights.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T17:40:28.947115+11:00","updated_at":"2025-12-25T18:33:28.201304+11:00","closed_at":"2025-12-25T18:33:28.201304+11:00","dependencies":[{"issue_id":"dt-survivor-f77","depends_on_id":"dt-survivor-xp9","type":"blocks","created_at":"2025-12-25T17:40:45.450648+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-f77","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:40:46.014939+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-g0j","title":"Create Element Enum System","description":"## Context\n\nPart of the spells system refactoring for dt-survivor. This creates the foundational element type system that all spells will use.\n\n## Implementation Details\n\n- Create new module: src/element/mod.rs\n- Define Element enum with 8 variants: Fire, Frost, Poison, Lightning, Light, Dark, Chaos, Psychic\n- Implement methods:\n  - `color(\u0026self) -\u003e Color` - Returns visual color for element effects\n  - `name(\u0026self) -\u003e \u0026'static str` - Returns display name\n\n### Element Colors\n| Element | Color |\n|---------|-------|\n| Fire | Orange (255, 128, 0) |\n| Frost | Ice Blue (135, 206, 235) |\n| Poison | Green (0, 255, 0) |\n| Lightning | Yellow (255, 255, 0) |\n| Light | White (255, 255, 255) |\n| Dark | Purple (128, 0, 128) |\n| Chaos | Magenta (255, 0, 255) |\n| Psychic | Pink (255, 182, 193) |\n\n## ECS Patterns\n\n- Follow established module pattern with mod.rs\n- Add to prelude.rs for convenient imports\n- Use `#[derive(Component, Clone, Copy, Debug, PartialEq, Eq, Hash)]`\n\n## Acceptance Criteria\n\n- [ ] Element enum defined with all 8 variants\n- [ ] color() returns correct Color for each element\n- [ ] name() returns correct display string\n- [ ] Module properly exported in lib.rs\n- [ ] Added to prelude.rs\n\n## Required Tests\n\n- Test each element returns correct color\n- Test each element returns correct name\n- Test all 8 variants exist (exhaustive match)\n- Test Element derives required traits (Clone, Copy, PartialEq)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-01T21:04:06.539208+11:00","updated_at":"2026-01-01T22:12:03.715173+11:00","closed_at":"2026-01-01T22:12:03.715173+11:00","dependencies":[{"issue_id":"dt-survivor-g0j","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:04:14.297825+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-ged","title":"Implement Disorder Pulse Spell (Chaos)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Disorder Pulse\n- **Element**: Chaos\n- **Behavior**: Periodic bursts with varying effects. Automatic pulses emit from the player (similar to Arc Surge), but each pulse has a random effect type applied to enemies hit.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct DisorderPulse {\n    pub pulse_timer: Timer,\n    pub pulse_radius: f32,\n    pub base_damage: f32,\n}\n\n#[derive(Component, Clone)]\npub enum PulseEffect {\n    Damage(f32),\n    Slow { factor: f32, duration: f32 },\n    Knockback { force: f32 },\n    Fear { duration: f32 },\n    Stun { duration: f32 },\n    Burn { damage: f32, duration: f32 },\n}\n```\n\n### Systems\n- `update_disorder_pulse_timer` - Tick the pulse timer\n- `emit_disorder_pulse` - Create pulse effect when timer fires\n- `apply_random_pulse_effect` - Roll random effect, apply to enemies in radius\n- `disorder_pulse_visual` - Spawn visual effect for the pulse\n\n### File Location\n`src/spells/chaos/disorder_pulse.rs`\n\n## Visual Design\n- Expanding ring of magenta/pink energy from player\n- Ring color shifts based on effect rolled\n- Glitchy distortion wave effect\n- Affected enemies flash with effect-specific color\n- Unstable crackling particles following the pulse wave\n\n## Acceptance Criteria\n- [ ] Disorder Pulse emits automatically on timer\n- [ ] Each pulse has a random effect from the pool\n- [ ] All enemies in radius are affected by the pulse\n- [ ] Pulse effect is clearly visible as expanding ring\n- [ ] Effect type is visually distinguishable\n- [ ] Timer interval is configurable\n- [ ] Base damage is always applied plus random effect\n\n## Required Tests\n- `test_disorder_pulse_timer_triggers` - Automatic emission\n- `test_disorder_pulse_radius_correct` - Size validation\n- `test_disorder_pulse_effect_is_random` - Randomization works\n- `test_disorder_pulse_affects_enemies_in_range` - Collision detection\n- `test_disorder_pulse_applies_damage_effect` - Damage variant\n- `test_disorder_pulse_applies_slow_effect` - Slow variant\n- `test_disorder_pulse_applies_knockback_effect` - Knockback variant\n- `test_disorder_pulse_timer_resets` - Continuous pulsing","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:18:38.518776+11:00","updated_at":"2026-01-02T09:31:19.935644+11:00","closed_at":"2026-01-02T09:31:19.935644+11:00","dependencies":[{"issue_id":"dt-survivor-ged","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:18:44.441902+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-ggr","title":"Create GameMeshes and GameMaterials resources for 3D entity rendering","description":"# Task: Shared 3D Asset Resources\n\n## Context\nDT Survivor is migrating from 2D sprites to 3D cubes. To efficiently render many entities (player, enemies, bullets, loot), we need shared mesh and material handles that can be cloned rather than recreating assets for each entity.\n\n## Current Implementation\n- Entities use `Sprite::from_color()` which creates inline sprite data\n- No shared mesh/material resources exist\n- Each entity spawns with its own sprite configuration\n\n## Required Changes\n\n### 1. Create Resource Structs (src/game/resources.rs)\n```rust\n#[derive(Resource)]\npub struct GameMeshes {\n    pub player: Handle\u003cMesh\u003e,      // 1.0 x 1.0 x 1.0 cube\n    pub enemy: Handle\u003cMesh\u003e,       // 0.75 x 0.75 x 0.75 cube\n    pub bullet: Handle\u003cMesh\u003e,      // 0.3 x 0.3 x 0.3 cube\n    pub loot_small: Handle\u003cMesh\u003e,  // 0.4 x 0.4 x 0.4 cube (XP orbs)\n    pub loot_large: Handle\u003cMesh\u003e,  // 0.6 x 0.6 x 0.6 cube (weapons)\n    pub rock: Handle\u003cMesh\u003e,        // 1.0 x 0.5 x 1.0 cube (flat)\n}\n\n#[derive(Resource)]\npub struct GameMaterials {\n    pub player: Handle\u003cStandardMaterial\u003e,      // Green, slight emissive\n    pub enemy: Handle\u003cStandardMaterial\u003e,       // Red\n    pub bullet: Handle\u003cStandardMaterial\u003e,      // Yellow, emissive\n    pub xp_orb: Handle\u003cStandardMaterial\u003e,      // Light grey\n    pub health_pack: Handle\u003cStandardMaterial\u003e, // Green\n    pub weapon_pistol: Handle\u003cStandardMaterial\u003e,  // Yellow\n    pub weapon_laser: Handle\u003cStandardMaterial\u003e,   // Blue\n    pub weapon_rocket: Handle\u003cStandardMaterial\u003e,  // Orange\n    pub rock: Handle\u003cStandardMaterial\u003e,        // Grey\n}\n```\n\n### 2. Create Setup System\n```rust\npub fn setup_game_assets(\n    mut commands: Commands,\n    mut meshes: ResMut\u003cAssets\u003cMesh\u003e\u003e,\n    mut materials: ResMut\u003cAssets\u003cStandardMaterial\u003e\u003e,\n) {\n    commands.insert_resource(GameMeshes {\n        player: meshes.add(Cuboid::new(1.0, 1.0, 1.0)),\n        enemy: meshes.add(Cuboid::new(0.75, 0.75, 0.75)),\n        // ... etc\n    });\n    \n    commands.insert_resource(GameMaterials {\n        player: materials.add(StandardMaterial {\n            base_color: Color::srgb(0.0, 1.0, 0.0),\n            emissive: LinearRgba::rgb(0.0, 0.2, 0.0),\n            ..default()\n        }),\n        // ... etc\n    });\n}\n```\n\n### 3. Register in Plugin\n- Add `setup_game_assets` to run in `OnEnter(GameState::InGame)` or `Startup`\n- Ensure it runs before entity spawning systems\n\n## Testing Requirements\n- Unit test: GameMeshes resource contains valid handles after setup\n- Unit test: GameMaterials resource contains valid handles after setup\n- Unit test: All mesh sizes match expected dimensions\n- Unit test: All material colors match expected values\n- Unit test: Resources are available after entering InGame state\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] GameMeshes resource defined with all entity mesh handles\n- [ ] GameMaterials resource defined with all entity material handles\n- [ ] setup_game_assets system creates and inserts both resources\n- [ ] Meshes use appropriate sizes for visual hierarchy (player \u003e enemy \u003e bullet)\n- [ ] Materials use distinguishable colors matching current 2D colors\n- [ ] Resources exported from game module for other modules to use\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:46:28.687202+11:00","updated_at":"2025-12-28T10:01:44.269706+11:00","closed_at":"2025-12-28T10:01:44.269706+11:00","dependencies":[{"issue_id":"dt-survivor-ggr","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.241775+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-ggz","title":"Implement Blight Zone Spell (Poison)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Blight Zone\n- **Element**: Poison\n- **Behavior**: Area becomes contaminated, damaging enemies over time. Cast at a target location to create a persistent zone. Enemies in the zone take damage over time for the zone's duration.\n\n## ECS Implementation\n\n### Components\n- `BlightZone { center: Vec2, radius: f32, duration: Timer, tick_damage: f32, tick_timer: Timer }` - The contaminated area that damages enemies within\n\n### Systems\n- `spawn_blight_zone` - Creates zone at target location on spell cast\n- `blight_zone_damage_tick` - Applies DOT to all enemies within radius\n- `blight_zone_visual_update` - Updates visual effects based on remaining duration\n- `cleanup_blight_zone` - Despawns zone when duration expires\n\n### File Location\n`src/spells/poison/blight_zone.rs`\n\n## Visual Design\n- Zone: Ground covered in sickly green/brown corruption texture\n- Particles: Green mist rising from the ground, occasional bubble pops\n- Edge: Visible boundary ring showing zone extent\n- Poison element uses green/toxic colors, bubble/drip particle effects\n\n## Acceptance Criteria\n- [ ] Zone spawns at targeted location\n- [ ] Zone has clearly visible radius boundary\n- [ ] All enemies within radius take DOT at tick rate\n- [ ] Enemies entering zone start taking damage immediately\n- [ ] Enemies leaving zone stop taking damage\n- [ ] Zone despawns after duration expires\n- [ ] Visual intensity can fade as duration decreases\n\n## Required Tests\n- `test_blight_zone_spawns_at_target` - Verify zone placement\n- `test_blight_zone_damages_enemies_inside` - Verify DOT application\n- `test_blight_zone_no_damage_outside` - Verify radius boundary\n- `test_blight_zone_damages_enemies_entering` - Verify new entries take damage\n- `test_blight_zone_stops_damage_on_exit` - Verify leaving stops damage\n- `test_blight_zone_tick_rate_correct` - Verify damage timing\n- `test_blight_zone_despawns_after_duration` - Verify cleanup","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:11:34.09166+11:00","updated_at":"2026-01-02T02:36:58.355131+11:00","closed_at":"2026-01-02T02:36:58.355131+11:00","dependencies":[{"issue_id":"dt-survivor-ggz","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:11:40.898097+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-gtg","title":"Migrate game from 2D to 3D isometric view","description":"# Epic: 2D to 3D Migration\n\nConvert DT Survivor from 2D sprites to 3D isometric/3/4 view with:\n- Orthographic 3D camera at ~30-45° angle\n- Ground plane (XZ) with Y as up axis\n- Cubes replacing sprites for all entities\n- DirectionalLight + PointLight (follows player)\n- bevy_hanabi particles replacing Whisper 2D materials\n\n## Coordinate System Change\n- **Current**: XY ground plane, Z for layer ordering\n- **Target**: XZ ground plane, Y for height (Bevy default, compatible with Blender \"+Y Up\" export)\n\n## Key Files Affected\n- src/main.rs - Remove Lighting2dPlugin\n- src/game/systems.rs - Camera, lighting, entity spawning\n- src/movement/systems.rs - XY→XZ conversion\n- src/player/systems.rs - Camera follow\n- src/enemies/systems.rs, bullets/systems.rs, loot/systems.rs - Cube spawning\n- src/whisper/* - Replace Material2d with particles\n\n## Testing Strategy\nEach subtask must maintain 90% code coverage. All existing tests must be updated to use 3D coordinates (XZ plane). Integration tests should verify visual rendering in 3D.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-28T09:44:21.363951+11:00","updated_at":"2025-12-28T11:24:38.447974+11:00","closed_at":"2025-12-28T11:24:38.447974+11:00"}
{"id":"dt-survivor-gx4","title":"Migrate Laser to Radiant Beam Spell","description":"## Context\n\nPart of the spells refactoring epic (dt-survivor-jdd) to migrate existing weapons into an elemental spell system. The Laser weapon becomes the Radiant Beam spell - a light-element continuous beam that deals sustained damage.\n\n## Implementation Details\n\n### File Migration\n- Move logic from `src/laser/` into `src/spells/light/radiant_beam.rs`\n- Create `src/spells/light/mod.rs` to export radiant_beam module\n\n### Spell Mechanics\n- **Radiant Beam**: Continuous beam of focused light emanating from player\n- **Element**: Light (white/gold visuals)\n- **Damage**: Continuous damage while beam intersects enemy\n- **Visual**: Beam with animated thickness pulsing\n\n### ECS Components to Rename/Create\n- Rename `LaserBeam` to `RadiantBeam` component\n- Preserve all existing fields:\n  - `start: Vec2` - beam origin\n  - `end: Vec2` - beam endpoint\n  - `damage_per_second: f32` - DPS while intersecting\n  - `thickness: f32` - current visual thickness\n\n### Reuse from Laser\n- LaserBeam component structure (rename to RadiantBeam)\n- Beam rendering system\n- Line-based collision detection\n- Thickness animation system\n- Damage falloff over distance (if implemented)\n\n### Visual Changes\n- Update beam color from red to white/gold gradient\n- Keep thickness pulsing animation\n- Optional: Add holy/radiant particle effects along beam\n\n### ECS Patterns to Preserve\n- Beam updates each frame based on player position/facing\n- Uses raycast or line intersection for collision\n- Damage applied continuously in fixed timestep\n\n## Acceptance Criteria\n\n- [ ] RadiantBeam spawns from player position\n- [ ] Beam extends in aimed direction\n- [ ] Beam renders with white/gold color\n- [ ] Thickness animation pulses correctly\n- [ ] Continuous damage applied to enemies in beam path\n- [ ] Damage respects damage_per_second * delta_time\n- [ ] Beam despawns when spell ends\n- [ ] Level scaling affects damage and beam length\n\n## Required Tests\n\n1. **Beam Rendering**: RadiantBeam renders between start and end points\n2. **Continuous Damage**: Enemy in beam takes damage proportional to time\n3. **Thickness Animation**: Beam thickness oscillates over time\n4. **Position Update**: Beam origin follows player position\n5. **Direction Update**: Beam direction follows player aim\n6. **Collision Detection**: Only enemies intersecting beam take damage\n7. **Damage Falloff**: Damage reduces at longer distances (if applicable)\n8. **Level Scaling**: Higher levels increase damage/length","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-01T21:04:36.301923+11:00","updated_at":"2026-01-01T23:21:47.060399+11:00","closed_at":"2026-01-01T23:21:47.060399+11:00","dependencies":[{"issue_id":"dt-survivor-gx4","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:04:57.602342+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-h7x","title":"Implement Flame Arc Spell (Fire)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Flame Arc\n- **Element**: Fire\n- **Behavior**: Arcing fire bolt that explodes into fragments on impact. Projectile follows an arc trajectory (parabolic path). On hitting an enemy or reaching max range, spawns 4-6 smaller flame fragments that scatter in random directions, each dealing reduced damage.\n\n## ECS Implementation\n\n### Components\n- `FlameArcProjectile { arc_height: f32, damage: f32, fragment_count: u8, fragment_damage: f32, travel_time: f32 }` - Main arcing projectile\n- `FlameArcTrajectory { start_pos: Vec3, target_pos: Vec3, elapsed: f32, duration: f32 }` - Tracks arc path\n- `FlameFragment { speed: f32, damage: f32, lifetime: Timer }` - Scattered fragment from explosion\n\n### Systems\n- `spawn_flame_arc` - Creates arcing projectile aimed at target position\n- `move_flame_arc` - Updates position along parabolic trajectory\n- `flame_arc_impact` - Detects hit or max range, spawns fragments\n- `spawn_flame_fragments` - Creates 4-6 fragments with random directions\n- `move_flame_fragments` - Moves fragments outward from explosion point\n- `flame_fragment_collision` - Handles fragment damage on enemy hit\n- `cleanup_flame_fragments` - Despawns fragments after lifetime or off-screen\n\n### File Location\n`src/spells/fire/flame_arc.rs`\n\n## Visual Design\n- Main projectile: bright orange fireball with trailing flames\n- Arc trajectory: visible fire trail showing path\n- Impact explosion: burst of sparks and flames\n- Fragments: smaller ember particles streaking outward\n\n## Acceptance Criteria\n- [ ] Flame Arc follows parabolic arc trajectory toward target\n- [ ] Main projectile deals damage on direct hit\n- [ ] On impact, spawns 4-6 flame fragments\n- [ ] Fragments scatter in random directions from impact point\n- [ ] Fragments deal reduced damage compared to main projectile\n- [ ] Fragments despawn after short lifetime\n- [ ] Arc reaches apex at configured arc_height\n\n## Required Tests\n- `test_flame_arc_spawns_with_trajectory` - Verify arc trajectory component set up\n- `test_flame_arc_follows_parabola` - Verify projectile moves along arc path\n- `test_flame_arc_hits_apex` - Verify arc reaches configured height at midpoint\n- `test_flame_arc_damages_on_hit` - Verify main projectile damage applied\n- `test_flame_arc_spawns_fragments` - Verify 4-6 fragments created on impact\n- `test_flame_fragments_scatter_randomly` - Verify fragments have varied directions\n- `test_flame_fragment_damages_enemy` - Verify fragment deals damage on hit\n- `test_flame_fragment_expires` - Verify fragment despawns after lifetime","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:12:35.452387+11:00","updated_at":"2026-01-02T04:06:03.660887+11:00","closed_at":"2026-01-02T04:06:03.660887+11:00","dependencies":[{"issue_id":"dt-survivor-h7x","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:12:40.684882+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-ijk","title":"Implement Scorch Trail Spell (Fire)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Scorch Trail\n- **Element**: Fire\n- **Behavior**: Leaves burning ground behind the player while moving. While active, creates ground fire patches at player's previous positions. Patches persist for a duration and damage enemies standing in them with damage-over-time ticks.\n\n## ECS Implementation\n\n### Components\n- `ScorchPatch { lifetime: Timer, damage_per_tick: f32, tick_timer: Timer }` - Ground fire zone that damages over time\n- `ScorchTrailActive { spawn_distance: f32, last_spawn_position: Vec3 }` - Player marker indicating trail is active\n- `ScorchedBy(HashSet\u003cEntity\u003e)` - Tracks which patches have damaged this enemy this tick (prevents multi-tick from overlapping patches)\n\n### Systems\n- `activate_scorch_trail` - Adds ScorchTrailActive to player when spell cast\n- `spawn_scorch_patches` - Creates patches as player moves (minimum distance between spawns)\n- `tick_scorch_damage` - Applies damage to enemies standing in patches each tick\n- `decay_scorch_patches` - Ticks lifetime, despawns expired patches\n- `deactivate_scorch_trail` - Removes ScorchTrailActive when spell duration ends\n\n### File Location\n`src/spells/fire/scorch_trail.rs`\n\n## Visual Design\n- Ground patches rendered as orange-red fire decals\n- Flickering flame particle effects rising from patches\n- Patches fade in opacity as lifetime decreases\n- Intensity pulses subtly to show damage ticks\n\n## Acceptance Criteria\n- [ ] Trail creates fire patches as player moves\n- [ ] Patches spawn at minimum distance intervals (not every frame)\n- [ ] Patches persist for configured lifetime\n- [ ] Enemies in patches take damage-over-time\n- [ ] Multiple overlapping patches don't stack damage per tick\n- [ ] Patches despawn when lifetime expires\n- [ ] Trail deactivates when spell duration ends\n\n## Required Tests\n- `test_scorch_trail_activates` - Verify ScorchTrailActive added to player\n- `test_scorch_patches_spawn_on_movement` - Verify patches created as player moves\n- `test_scorch_patches_respect_spawn_distance` - Verify minimum gap between patches\n- `test_scorch_patch_damages_enemy` - Verify DoT applied to enemies in patch\n- `test_scorch_patch_damage_ticks` - Verify damage applies at correct intervals\n- `test_overlapping_patches_no_stack` - Verify single damage per tick regardless of overlap\n- `test_scorch_patch_expires` - Verify patch despawns after lifetime\n- `test_scorch_trail_deactivates` - Verify trail stops after duration","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:11:42.717212+11:00","updated_at":"2026-01-02T02:47:52.676059+11:00","closed_at":"2026-01-02T02:47:52.676059+11:00","dependencies":[{"issue_id":"dt-survivor-ijk","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:11:48.194677+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-jdd","title":"Epic: Spells System Refactoring","description":"Convert the weapon system to a spell system with 8 elements, 64 unique spells, 5 active spell slots, a 30-slot inventory bag, and Whisper elemental attunement.\n\n## Overview\nThis epic transforms the game's combat system from simple weapons to an element-based spell system. The player will have 5 active spell slots and a 30-slot inventory bag. When Whisper is picked up, the player chooses an elemental attunement that provides 10% bonus damage to matching spells.\n\n## Key Changes\n- Rename Weapon → Spell throughout codebase\n- Create Element enum (Fire, Frost, Poison, Lightning, Light, Dark, Chaos, Psychic)\n- Expand from 3 fixed weapon slots to 5 dynamic spell slots\n- Add 30-slot inventory bag with grid overlay UI (I key)\n- Whisper attunement modal on pickup for 10% element damage bonus\n- Implement 64 unique spells (8 per element)\n- All spells have equal drop rates\n\n## ECS Architecture\n- Components: Spell, SpellType, Element, EquippedSpell\n- Resources: SpellList, InventoryBag, WhisperAttunement, SpellOrigin\n- Events: SpellCastEvent, AttunementSelectedEvent\n- States: GameState::AttunementSelect, GameState::InventoryOpen\n\n## File Structure\n- src/element/ - Element enum and helpers\n- src/spell/ - Core spell components (renamed from weapon/)\n- src/spells/ - Individual spell implementations by element\n- src/ui/attunement.rs - Attunement selection modal\n- src/ui/inventory_bag.rs - Inventory bag overlay","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-01T21:02:57.084207+11:00","updated_at":"2026-01-02T10:12:44.487406+11:00","closed_at":"2026-01-02T10:12:44.487406+11:00"}
{"id":"dt-survivor-jf7","title":"Verify and document weapon damage scaling with levels","description":"Verify the existing weapon level damage scaling system works correctly and document the scaling formula for consistency with other progression systems.\n\n## Context\nWeapons already have levels 1-10 in src/weapon/components.rs. The Weapon component has a calculate_damage() method that scales damage: `base_damage * level * 1.25`. This task verifies this system works correctly and adds comprehensive tests.\n\n## Current Implementation (src/weapon/components.rs)\n```rust\n#[derive(Component, Debug, Clone)]\npub struct Weapon {\n    pub weapon_type: WeaponType,\n    pub level: u32,\n    pub fire_rate: f32,\n    pub base_damage: f32,\n    pub last_fired: f32,\n}\n\nimpl Weapon {\n    /// Calculate actual damage based on level\n    pub fn calculate_damage(\u0026self) -\u003e f32 {\n        self.base_damage * self.level as f32 * 1.25\n    }\n}\n```\n\n## Verification Tasks\n\n### 1. Confirm damage is applied during combat\nTrace the damage flow from weapon firing through to enemy health reduction:\n- weapon_firing_system → spawn projectile with Damage component\n- bullet_collision_detection → fires BulletEnemyCollisionEvent\n- bullet_collision_effects → applies damage via DamageEvent\n- apply_damage_system → reduces enemy Health\n\n### 2. Verify damage scaling formula\n| Level | Base 10 Damage | Calculated |\n|-------|----------------|------------|\n| 1     | 10.0           | 12.5       |\n| 2     | 10.0           | 25.0       |\n| 5     | 10.0           | 62.5       |\n| 10    | 10.0           | 125.0      |\n\n### 3. Add comprehensive tests\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn weapon_damage_scales_with_level() {\n        let weapon = Weapon {\n            weapon_type: WeaponType::Pistol { bullet_count: 1, spread_angle: 0.0 },\n            level: 1,\n            fire_rate: 1.0,\n            base_damage: 10.0,\n            last_fired: 0.0,\n        };\n        assert_eq!(weapon.calculate_damage(), 12.5);\n        \n        let weapon_5 = Weapon { level: 5, ..weapon.clone() };\n        assert_eq!(weapon_5.calculate_damage(), 62.5);\n        \n        let weapon_10 = Weapon { level: 10, ..weapon };\n        assert_eq!(weapon_10.calculate_damage(), 125.0);\n    }\n\n    #[test]\n    fn weapon_damage_increases_linearly_with_level() {\n        let base_weapon = Weapon {\n            weapon_type: WeaponType::Laser,\n            level: 1,\n            fire_rate: 0.5,\n            base_damage: 20.0,\n            last_fired: 0.0,\n        };\n        \n        let damage_1 = base_weapon.calculate_damage();\n        let weapon_2 = Weapon { level: 2, ..base_weapon.clone() };\n        let damage_2 = weapon_2.calculate_damage();\n        \n        // Damage should double when level doubles\n        assert!((damage_2 / damage_1 - 2.0).abs() \u003c 0.01);\n    }\n}\n```\n\n## Integration with Enemy Levels\nWith enemy levels having scaled HP, weapon effectiveness remains consistent:\n- Level 1 enemy (10 HP) vs Level 1 weapon (12.5 damage) = 1 hit kill\n- Level 3 enemy (40 HP) vs Level 1 weapon (12.5 damage) = 4 hit kill\n- Level 3 enemy (40 HP) vs Level 3 weapon (37.5 damage) = 2 hit kill\n- Level 5 enemy (70 HP) vs Level 10 weapon (125 damage) = 1 hit kill\n\nThis creates satisfying progression where leveling weapons makes higher-tier enemies manageable.\n\n## ECS Pattern\n```rust\n// Weapons are queried and damage calculated at fire time\nfn fire_weapon_system(\n    weapon_query: Query\u003c\u0026Weapon, With\u003cEquippedWeapon\u003e\u003e,\n) {\n    for weapon in weapon_query.iter() {\n        let damage = weapon.calculate_damage();\n        // Spawn projectile with Damage(damage)\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] Verify calculate_damage() formula is correct\n- [ ] Verify projectiles spawn with correct Damage component value\n- [ ] Verify damage is correctly applied to enemy Health\n- [ ] Unit tests for weapon damage calculation at all levels 1-10\n- [ ] Document damage formula in code comments\n- [ ] Integration test: weapon damage reduces enemy health correctly\n\n## Test Requirements\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn all_weapon_types_scale_damage_correctly() {\n        let weapon_types = vec![\n            WeaponType::Pistol { bullet_count: 1, spread_angle: 0.0 },\n            WeaponType::Laser,\n            WeaponType::RocketLauncher,\n        ];\n        \n        for weapon_type in weapon_types {\n            let weapon = Weapon {\n                weapon_type,\n                level: 5,\n                fire_rate: 1.0,\n                base_damage: 10.0,\n                last_fired: 0.0,\n            };\n            // 10 * 5 * 1.25 = 62.5\n            assert_eq!(weapon.calculate_damage(), 62.5);\n        }\n    }\n}\n```","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-30T09:44:14.787909+11:00","updated_at":"2025-12-30T11:28:00.41371+11:00","closed_at":"2025-12-30T11:28:00.41371+11:00","dependencies":[{"issue_id":"dt-survivor-jf7","depends_on_id":"dt-survivor-3l7","type":"blocks","created_at":"2025-12-30T09:45:07.868765+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-jf7","depends_on_id":"dt-survivor-aiy","type":"parent-child","created_at":"2025-12-30T09:45:19.486434+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-jpp","title":"Implement Psionic Burst Spell (Psychic)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Psionic Burst\n- **Element**: Psychic\n- **Behavior**: Expanding wave of mental energy. Nova-style expanding ring emanates from the player, damaging all enemies it contacts as it expands outward.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct PsionicBurstWave {\n    pub radius: f32,\n    pub max_radius: f32,\n    pub expansion_rate: f32,\n    pub damage: f32,\n}\n\n#[derive(Component)]\npub struct PsionicBurstDamagedBy(pub Entity);  // Track which bursts have hit an enemy\n```\n\n### Systems Needed\n1. `spawn_psionic_burst` - Create expanding wave from player position\n2. `update_psionic_burst` - Expand radius each frame\n3. `psionic_burst_collision` - Damage enemies at wave edge\n4. `cleanup_psionic_burst` - Remove when max_radius reached\n\n### File Location\n`src/spells/psychic/psionic_burst.rs`\n\n## Visual Design\n- Translucent pink/magenta ring expanding outward\n- Violet energy ripples within the wave\n- Inner edge fades as it expands\n- Mind-wave distortion effect at the ring edge\n\n## Acceptance Criteria\n- [ ] Psionic Burst spawns centered on player position\n- [ ] Wave expands at configured expansion_rate\n- [ ] Enemies take damage once when wave passes through them\n- [ ] Wave despawns when reaching max_radius\n- [ ] Visual shows expanding pink/violet ring effect\n- [ ] Integrates with spell cooldown system\n- [ ] Works with 5-slot active spell system\n\n## Required Tests\n1. `test_psionic_burst_spawns_at_player` - Verify spawn position\n2. `test_psionic_burst_expands_over_time` - Radius increases\n3. `test_psionic_burst_damages_enemies_once` - No repeat damage\n4. `test_psionic_burst_cleanup_at_max_radius` - Entity removed\n5. `test_psionic_burst_expansion_rate` - Correct expansion speed\n6. `test_psionic_burst_multiple_enemies` - All enemies in range hit\n7. `test_psionic_burst_cooldown_integration` - Spell system integration","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:16:31.946222+11:00","updated_at":"2026-01-02T05:59:30.315862+11:00","closed_at":"2026-01-02T05:59:30.315862+11:00","dependencies":[{"issue_id":"dt-survivor-jpp","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:16:37.213017+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-kxo","title":"Implement Soul Rend Spell (Dark)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Soul Rend\n- **Element**: Dark\n- **Behavior**: Damage increases against low-health enemies. A projectile with an execute mechanic that deals bonus damage when the target is below a health threshold (e.g., 50%). Ideal for finishing off weakened enemies.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct SoulRendProjectile {\n    pub base_damage: f32,\n    pub execute_threshold: f32,     // e.g., 0.5 = 50% health\n    pub execute_multiplier: f32,    // e.g., 2.0 = double damage below threshold\n    pub speed: f32,\n}\n```\n\n### Systems\n- `spawn_soul_rend` - Creates projectile entity toward target direction\n- `update_soul_rend_movement` - Move projectile each frame\n- `soul_rend_collision` - On hit, check enemy health percentage, apply normal or execute damage\n- `cleanup_soul_rend` - Despawn on collision or max range\n\n### File Location\n`src/spells/dark/soul_rend.rs`\n\n## Visual Design\n- Dark crimson/purple energy projectile\n- Spectral scythe or claw visual\n- Brighter/more intense effect when execute triggers\n- Soul fragment particles on kill\n\n## Acceptance Criteria\n- [ ] SoulRendProjectile component with execute_threshold and execute_multiplier\n- [ ] Projectile deals base_damage to enemies above threshold\n- [ ] Projectile deals base_damage * execute_multiplier to enemies below threshold\n- [ ] Health percentage check uses current_health / max_health\n- [ ] Visual indicator when execute damage triggers\n- [ ] Projectile despawns on first enemy hit\n- [ ] Spell integrates with 5-slot active spell system\n\n## Required Tests\n- [ ] Test projectile deals base damage to full health enemy\n- [ ] Test projectile deals execute damage to low health enemy\n- [ ] Test threshold boundary (exactly at 50% health)\n- [ ] Test execute multiplier correctly scales damage\n- [ ] Test projectile movement at configured speed\n- [ ] Test projectile despawns on enemy hit\n- [ ] Test projectile despawns after max range\n- [ ] Test execute calculation uses current vs max health ratio","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:17:40.472307+11:00","updated_at":"2026-01-02T07:42:28.776601+11:00","closed_at":"2026-01-02T07:42:28.776601+11:00","dependencies":[{"issue_id":"dt-survivor-kxo","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:18:02.974565+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-lbe","title":"Implement Ice Lance Spell (Frost)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Ice Lance\n- **Element**: Frost\n- **Behavior**: High-speed piercing frost projectile. Very fast, pierces all enemies in line, dealing damage to each. Higher damage than Frostbolt but with a longer cooldown, making it a precision skill shot.\n\n## ECS Implementation\n\n### Components to Create\n- `IceLanceProjectile` - Marker component for the high-speed piercing projectile\n- `Piercing { max_hits: Option\u003cu32\u003e, current_hits: u32 }` - Shared component for piercing projectiles (unlimited for Ice Lance)\n- `IceLanceHitList { hit_entities: Vec\u003cEntity\u003e }` - Tracks enemies already damaged to prevent double-hit\n\n### Systems Needed\n- `spawn_ice_lance` - Creates fast-moving piercing projectile\n- `update_ice_lance_movement` - Moves projectile at high speed in target direction\n- `ice_lance_enemy_collision` - Damages enemies and continues through (pierce behavior)\n- `update_ice_lance_hit_tracking` - Ensures each enemy only takes damage once per lance\n- `cleanup_ice_lance` - Despawns after max range traveled\n\n### File Location\n`src/spells/frost/ice_lance.rs`\n\n## Visual Design\n- Long, sharp ice lance/javelin shape in ice blue/cyan\n- Speed lines/blur effect due to high velocity\n- Ice crystal trail particles\n- On-hit: enemy gets pierced-through ice effect with shatter particles\n\n## Acceptance Criteria\n- [ ] Ice Lance fires at very high speed toward target direction\n- [ ] Projectile pierces through all enemies in its path\n- [ ] Each enemy takes damage only once per lance (no multi-hit on same enemy)\n- [ ] Damage is higher than Frostbolt (configurable)\n- [ ] Cooldown is longer than Frostbolt (handled by spell system)\n- [ ] Lance despawns after reaching max range\n- [ ] Visual shows piercing/speed effect\n\n## Required Tests\n- [ ] Test ice_lance spawns with correct high-speed velocity\n- [ ] Test lance moves faster than frostbolt\n- [ ] Test lance continues through enemy after collision (piercing)\n- [ ] Test enemy takes damage on lance collision\n- [ ] Test same enemy cannot be hit twice by same lance\n- [ ] Test multiple enemies in line all take damage\n- [ ] Test lance despawns at max range\n- [ ] Test damage value is higher than frostbolt damage","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:12:53.074951+11:00","updated_at":"2026-01-02T04:38:23.470733+11:00","closed_at":"2026-01-02T04:38:23.470733+11:00","dependencies":[{"issue_id":"dt-survivor-lbe","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:12:59.676404+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-lj5","title":"Implement Ashfall Spell (Fire)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Ashfall\n- **Element**: Fire\n- **Behavior**: Embers rain down over an area dealing sustained damage. Creates a targeted zone ahead of the player where falling ember particles spawn from above. Embers damage enemies on contact as they fall through the zone.\n\n## ECS Implementation\n\n### Components\n- `AshfallZone { center: Vec3, radius: f32, duration: Timer, spawn_rate: f32, spawn_timer: Timer, damage_per_ember: f32 }` - The target area spawning embers\n- `FallingEmber { fall_speed: f32, damage: f32 }` - Individual falling particle\n- `AshfallSpawnHeight(f32)` - Height above zone where embers spawn\n\n### Systems\n- `spawn_ashfall_zone` - Creates zone at target position ahead of player\n- `spawn_falling_embers` - Periodically spawns embers at random positions within zone radius\n- `move_falling_embers` - Moves embers downward at fall_speed\n- `falling_ember_collision` - Damages enemies when ember passes through them\n- `cleanup_falling_embers` - Despawns embers when below ground level\n- `expire_ashfall_zone` - Removes zone when duration ends\n\n### File Location\n`src/spells/fire/ashfall.rs`\n\n## Visual Design\n- Zone marked with subtle circular ground indicator (orange glow)\n- Embers fall as small bright orange particles with subtle trails\n- Ember impacts create tiny spark bursts\n- Zone fades as duration decreases\n\n## Acceptance Criteria\n- [ ] Ashfall zone spawns at position ahead of player facing direction\n- [ ] Embers spawn at random positions within zone radius\n- [ ] Embers fall downward at configured speed\n- [ ] Enemies take damage when embers pass through them\n- [ ] Embers despawn at ground level\n- [ ] Zone expires after configured duration\n- [ ] Ember spawn rate creates sustained damage coverage\n\n## Required Tests\n- `test_ashfall_zone_spawns_ahead_of_player` - Verify zone position relative to player\n- `test_ashfall_zone_has_correct_radius` - Verify zone size matches config\n- `test_falling_embers_spawn_in_zone` - Verify embers spawn within radius\n- `test_falling_embers_move_downward` - Verify embers fall at correct speed\n- `test_falling_ember_damages_enemy` - Verify damage applied on contact\n- `test_falling_ember_despawns_at_ground` - Verify cleanup below ground level\n- `test_ashfall_zone_expires` - Verify zone removed after duration\n- `test_ashfall_ember_spawn_rate` - Verify consistent ember generation","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:12:59.693784+11:00","updated_at":"2026-01-02T04:48:06.8482+11:00","closed_at":"2026-01-02T04:48:06.8482+11:00","dependencies":[{"issue_id":"dt-survivor-lj5","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:13:05.566846+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-m0q","title":"Implement Sanctify Spell (Light)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Sanctify\n- **Element**: Light\n- **Behavior**: Enemies take increased damage while within the area. Creates a sanctified zone at a target location that applies a damage vulnerability debuff to enemies inside. All damage sources deal multiplied damage to affected enemies.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct SanctifiedZone {\n    pub center: Vec2,\n    pub radius: f32,\n    pub duration: Timer,\n    pub damage_multiplier: f32,\n}\n\n#[derive(Component)]\npub struct SanctifiedDebuff {\n    pub damage_multiplier: f32,\n}\n```\n\n### Systems\n- `spawn_sanctified_zone` - Creates zone entity at target location\n- `update_sanctified_zone_duration` - Ticks zone timer, despawns when expired\n- `apply_sanctified_debuff` - Adds debuff component to enemies entering zone\n- `remove_sanctified_debuff` - Removes debuff when enemies leave zone\n- `modify_damage_for_sanctified` - Multiplies incoming damage for debuffed enemies\n- `cleanup_sanctified_zones` - Removes all zones on spell deactivation\n\n### File Location\n`src/spells/light/sanctify.rs`\n\n## Visual Design\n- Glowing white/gold circular area on ground\n- Radiant particles rising within the zone\n- Enemies inside have subtle golden highlight/glow\n- Pulsing border effect around zone perimeter\n\n## Acceptance Criteria\n- [ ] SanctifiedZone spawns at designated target location\n- [ ] Zone has configurable radius, duration, and damage multiplier\n- [ ] Enemies inside zone receive SanctifiedDebuff component\n- [ ] Debuff removed when enemy exits zone\n- [ ] All damage sources deal multiplied damage to debuffed enemies\n- [ ] Zone despawns after duration expires\n- [ ] Multiple zones can exist simultaneously\n- [ ] Visual clearly indicates affected area\n\n## Required Tests\n- [ ] Test zone spawns at correct position with correct radius\n- [ ] Test zone duration timer counts down correctly\n- [ ] Test zone despawns when duration expires\n- [ ] Test enemy gains debuff when entering zone\n- [ ] Test enemy loses debuff when leaving zone\n- [ ] Test damage multiplier applies correctly to debuffed enemies\n- [ ] Test multiple damage sources all benefit from multiplier\n- [ ] Test enemy can be in multiple zones (multiplicative or max multiplier)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:16:30.066655+11:00","updated_at":"2026-01-02T05:52:23.952328+11:00","closed_at":"2026-01-02T05:52:23.952328+11:00","dependencies":[{"issue_id":"dt-survivor-m0q","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:16:35.611675+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-m2z","title":"Implement Overload Spell (Lightning)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Overload\n- **Element**: Lightning\n- **Behavior**: Lightning damage builds up with each lightning hit until releasing a powerful blast. Charges accumulate passively from any lightning spell damage dealt. At max charge, auto-releases a massive damage nova around the player.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct OverloadCharge {\n    pub current_charge: f32,\n    pub max_charge: f32,\n    pub charge_per_hit: f32,\n    pub blast_damage: f32,\n    pub blast_radius: f32,\n}\n\n#[derive(Component)]\npub struct OverloadBlast {\n    pub origin: Vec3,\n    pub radius: f32,\n    pub damage: f32,\n}\n```\n\n### Systems\n- `overload_charge_accumulate` - Add charge when lightning damage dealt\n- `overload_check_release` - Trigger blast when max_charge reached\n- `overload_blast_spawn` - Create nova effect entity\n- `overload_blast_damage` - Apply damage to all enemies in radius\n- `overload_visual` - Show charge meter and blast effect\n\n### File Location\n`src/spells/lightning/overload.rs`\n\n## Visual Design\n- Visible charge meter or aura intensity around player\n- Charge aura grows brighter/larger as charge increases\n- Massive yellow/electric blue explosion on release\n- Screen flash effect on blast\n- Crackling residual particles after blast\n\n## Acceptance Criteria\n- [ ] Charge accumulates when player deals lightning damage\n- [ ] Charge amount scales with damage dealt\n- [ ] Visual indicator shows current charge level\n- [ ] Auto-releases blast when current_charge \u003e= max_charge\n- [ ] Blast damages all enemies within blast_radius\n- [ ] Charge resets to 0 after blast\n- [ ] Charge persists between casts of other spells\n\n## Required Tests\n- [ ] Test OverloadCharge initializes with zero charge\n- [ ] Test charge increases on lightning damage events\n- [ ] Test charge_per_hit multiplier applies correctly\n- [ ] Test blast triggers at exactly max_charge threshold\n- [ ] Test blast damages enemies within radius\n- [ ] Test blast does not damage enemies outside radius\n- [ ] Test charge resets to 0 after blast\n- [ ] Test charge accumulates from multiple lightning spell sources","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:11:31.76954+11:00","updated_at":"2026-01-02T02:32:33.110652+11:00","closed_at":"2026-01-02T02:32:33.110652+11:00","dependencies":[{"issue_id":"dt-survivor-m2z","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:11:36.04129+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-nbb","title":"Implement Synapse Shock Spell (Psychic)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Synapse Shock\n- **Element**: Psychic\n- **Behavior**: Stuns enemies briefly with mental overload. Creates an AOE stun effect around the player or at a target location, briefly incapacitating enemies.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct SynapseShockBurst {\n    pub radius: f32,\n    pub stun_duration: f32,\n}\n\n#[derive(Component)]\npub struct StunnedEnemy {\n    pub duration: Timer,\n    pub original_velocity: Vec2,\n}\n```\n\n### Systems Needed\n1. `cast_synapse_shock` - Create stun burst at location\n2. `apply_synapse_shock_stun` - Stun enemies in radius\n3. `update_stunned_enemies` - Track stun duration\n4. `cleanup_stun` - Restore movement when stun expires\n\n### File Location\n`src/spells/psychic/synapse_shock.rs`\n\n## Visual Design\n- Pink/magenta lightning burst emanating from center\n- Stunned enemies have violet static effect\n- Brain-zap particle effect on stun application\n- Fading electric arcs during stun duration\n\n## Acceptance Criteria\n- [ ] Synapse Shock creates AOE stun burst\n- [ ] All enemies in radius are stunned\n- [ ] Stunned enemies cannot move or attack\n- [ ] Stun expires after configured duration\n- [ ] Movement is restored after stun ends\n- [ ] Visual clearly indicates stunned state\n- [ ] Integrates with spell cooldown system\n\n## Required Tests\n1. `test_synapse_shock_creates_burst` - Burst spawns correctly\n2. `test_synapse_shock_stuns_enemies_in_radius` - Range check\n3. `test_stunned_enemy_cannot_move` - Movement disabled\n4. `test_stunned_enemy_cannot_attack` - Attacks disabled\n5. `test_stun_duration_expires` - Timer works correctly\n6. `test_stun_restores_movement` - Velocity restored\n7. `test_synapse_shock_multiple_enemies` - All in range stunned\n8. `test_synapse_shock_enemies_outside_radius` - Not affected","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:18:07.107513+11:00","updated_at":"2026-01-02T08:30:53.8729+11:00","closed_at":"2026-01-02T08:30:53.8729+11:00","dependencies":[{"issue_id":"dt-survivor-nbb","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:18:12.286545+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-ndd","title":"Implement Entropy Field Spell (Chaos)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Entropy Field\n- **Element**: Chaos\n- **Behavior**: Area of distortion causing unpredictable damage. Creates a zone with variable damage where the damage amount is randomized each tick, creating chaotic and unpredictable destruction.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct EntropyField {\n    pub center: Vec2,\n    pub radius: f32,\n    pub duration: Timer,\n    pub min_damage: f32,\n    pub max_damage: f32,\n    pub tick_timer: Timer,\n}\n```\n\n### Systems\n- `spawn_entropy_field` - Create field at target location\n- `update_entropy_field` - Tick damage timer and duration\n- `entropy_field_damage` - Apply randomized damage to enemies in zone\n- `cleanup_entropy_field` - Despawn when duration expires\n\n### File Location\n`src/spells/chaos/entropy_field.rs`\n\n## Visual Design\n- Distorted circular area with warping space effect\n- Shifting magenta/pink energy crackling randomly\n- Glitch-like visual artifacts within the field\n- Damage numbers vary wildly in size to match randomness\n- Unstable pulsing that doesn't follow regular patterns\n\n## Acceptance Criteria\n- [ ] Entropy Field spawns at target location with correct radius\n- [ ] Damage is randomized between min and max each tick\n- [ ] All enemies within radius take damage per tick\n- [ ] Field duration is configurable and expires correctly\n- [ ] Visual effects convey chaotic/unstable nature\n- [ ] Damage variance is clearly visible in damage numbers\n- [ ] Field persists independently of player position\n\n## Required Tests\n- `test_entropy_field_spawns_at_correct_location` - Position verification\n- `test_entropy_field_has_correct_radius` - Size validation\n- `test_entropy_field_damage_is_randomized` - Damage varies between ticks\n- `test_entropy_field_damage_within_bounds` - Min/max respected\n- `test_entropy_field_damages_enemies_in_zone` - Collision detection\n- `test_entropy_field_ignores_enemies_outside` - Boundary check\n- `test_entropy_field_duration_expires` - Timer cleanup\n- `test_entropy_field_despawns_after_duration` - Entity removal","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:17:00.42149+11:00","updated_at":"2026-01-02T06:53:03.778885+11:00","closed_at":"2026-01-02T06:53:03.778885+11:00","dependencies":[{"issue_id":"dt-survivor-ndd","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:17:05.948789+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-no1","title":"Implement Virulence Spell (Poison)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Virulence\n- **Element**: Poison\n- **Behavior**: Poison effects spread to nearby enemies on death. When a poisoned enemy dies, the poison spreads to nearby enemies. Creates chain reaction potential for crowd control.\n\n## ECS Implementation\n\n### Components\n- `VirulentPoison` - Marker component added to poison effects that should spread on death\n- `VirulentPoisonSource { damage: f32, duration: Timer, spread_radius: f32 }` - Tracks virulent poison on an enemy for spread calculation\n\n### Systems\n- `mark_poison_as_virulent` - Adds VirulentPoison marker when Virulence spell active\n- `spread_virulent_poison_on_death` - On poisoned enemy death, applies poison to nearby enemies\n- `virulent_chain_reaction` - Handles recursive spreading when chain kills occur\n\n### File Location\n`src/spells/poison/virulence.rs`\n\n## Visual Design\n- Virulent marker: Pulsing green glow on poisoned enemies\n- Spread effect: Green tendrils reaching to nearby enemies on death\n- Chain visual: Connecting lines briefly visible during spread\n- Poison element uses green/toxic colors, bubble/drip particle effects\n\n## Acceptance Criteria\n- [ ] VirulentPoison marker applied to poison from Virulence spell\n- [ ] On death of virulent-poisoned enemy, poison spreads to nearby enemies\n- [ ] Spread radius is configurable\n- [ ] Spread poison also has VirulentPoison marker (chain potential)\n- [ ] Spread has diminishing returns or max chain depth to prevent infinite loops\n- [ ] Visual effect shows poison spreading\n- [ ] Works with all poison DOT sources\n\n## Required Tests\n- `test_virulent_marker_applied` - Verify marker on poison effects\n- `test_virulent_spreads_on_death` - Verify spread to nearby enemies\n- `test_virulent_spread_radius` - Verify only enemies in radius affected\n- `test_virulent_chain_reaction` - Verify spread poison can also spread\n- `test_virulent_max_chain_depth` - Verify infinite loop prevention\n- `test_virulent_no_spread_without_marker` - Verify normal poison doesn't spread\n- `test_virulent_spread_damage_calculation` - Verify spread damage values","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:12:44.57597+11:00","updated_at":"2026-01-02T04:26:59.486098+11:00","closed_at":"2026-01-02T04:26:59.486098+11:00","dependencies":[{"issue_id":"dt-survivor-no1","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:12:49.714239+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-nq8","title":"Replace Camera2d with orthographic Camera3d and add 3D lighting","description":"# Task: Core 3D Infrastructure\n\n## Context\nDT Survivor is being migrated from 2D to 3D isometric view. This task sets up the foundational 3D rendering infrastructure: camera with orthographic projection at isometric angle, and 3D lighting to replace the 2D lighting system.\n\n## Current Implementation\n- `src/game/systems.rs:19-39`: Camera2d with HDR, Bloom, Lighting2dSettings, AmbientLight2d\n- `src/main.rs`: Registers `Lighting2dPlugin` from bevy_lit\n\n## Required Changes\n\n### 1. Remove 2D Lighting Plugin (src/main.rs)\n- Remove `use bevy_lit::prelude::*` import\n- Remove `.add_plugins(Lighting2dPlugin)` registration\n\n### 2. Replace Camera (src/game/systems.rs)\nReplace Camera2d setup with:\n```rust\ncommands.spawn((\n    Camera3d::default(),\n    Projection::Orthographic(OrthographicProjection {\n        scaling_mode: ScalingMode::FixedVertical { viewport_height: 20.0 },\n        ..default()\n    }),\n    Hdr,\n    Tonemapping::TonyMcMapface,\n    Bloom { intensity: 0.3, ..default() },\n    Transform::from_xyz(0.0, 20.0, 15.0).looking_at(Vec3::ZERO, Vec3::Y),\n));\n```\n\n### 3. Add 3D Lighting\n```rust\n// Directional light (sun)\ncommands.spawn((\n    DirectionalLight {\n        illuminance: 10000.0,\n        shadows_enabled: true,\n        ..default()\n    },\n    Transform::from_rotation(Quat::from_euler(EulerRot::XYZ, -0.8, 0.4, 0.0)),\n));\n\n// Ambient light resource\ncommands.insert_resource(AmbientLight {\n    color: Color::WHITE,\n    brightness: 200.0,\n});\n```\n\n### 4. Add Ground Plane\n```rust\ncommands.spawn((\n    Mesh3d(meshes.add(Plane3d::new(Vec3::Y, Vec2::new(100.0, 100.0)))),\n    MeshMaterial3d(materials.add(StandardMaterial {\n        base_color: Color::srgb(0.2, 0.2, 0.3),\n        ..default()\n    })),\n    Transform::from_translation(Vec3::ZERO),\n));\n```\n\n## Testing Requirements\n- Unit test: Verify camera spawns with correct projection type\n- Unit test: Verify camera transform position and rotation\n- Unit test: Verify DirectionalLight spawns with shadows enabled\n- Unit test: Verify AmbientLight resource is inserted\n- Unit test: Verify ground plane mesh spawns at Y=0\n- Integration test: Game starts without panic after changes\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] Lighting2dPlugin removed from main.rs\n- [ ] Camera2d replaced with Camera3d + orthographic projection\n- [ ] Camera positioned for isometric view (~30-45° angle)\n- [ ] DirectionalLight provides main scene illumination\n- [ ] AmbientLight provides base illumination\n- [ ] Ground plane visible as flat surface at Y=0\n- [ ] HDR and Bloom effects still functional\n- [ ] All existing camera tests updated for 3D\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:46:26.845484+11:00","updated_at":"2025-12-28T10:07:33.77432+11:00","closed_at":"2025-12-28T10:07:33.77432+11:00","dependencies":[{"issue_id":"dt-survivor-nq8","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.173058+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-o1l","title":"Implement advanced Whisper visual effects (lighting, particles, bloom)","description":"Implement the full visual effects for Whisper lightning ball:\n\n1. Camera Setup:\n   - Add Lighting2dSettings to camera for bevy_lit\n   - Enable Bevy bloom effect\n\n2. PointLight2d:\n   - Add cyan/white PointLight2d to WhisperCompanion\n   - Configure: intensity 4.0, outer_radius 240.0, falloff 2.0\n\n3. Hanabi GPU Particles:\n   - Create spark effect: 120 particles/sec, 0.35s lifetime\n   - Velocity: 180px/s outward sphere\n   - Size: 4px → 0px over lifetime\n   - Color: Cyan/white\n\n4. Enhanced arc effects:\n   - Replace simple sprites with more dynamic bolt patterns\n   - Add glow/bloom to arc sprites","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-26T09:17:16.185782+11:00","updated_at":"2025-12-26T09:34:46.888549+11:00","closed_at":"2025-12-26T09:34:46.888549+11:00","dependencies":[{"issue_id":"dt-survivor-o1l","depends_on_id":"dt-survivor-cq2","type":"blocks","created_at":"2025-12-26T09:17:28.652257+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-ogr","title":"Implement Permafrost Spell (Frost)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Permafrost\n- **Element**: Frost\n- **Behavior**: Enemies gradually freeze solid if exposed to frost effects too long. This is a passive synergy spell that adds stacking freeze buildup to enemies hit by ANY frost spell. When an enemy reaches max stacks, they become frozen (stunned) briefly.\n\n## ECS Implementation\n\n### Components to Create\n- `FreezeBuildup { stacks: u32, max_stacks: u32, decay_timer: Timer }` - Tracks freeze stacks on enemy\n- `FrozenStatus { duration: f32, remaining: f32 }` - Applied when max stacks reached, enemy is stunned\n- `PermafrostEnabled` - Marker on player indicating this passive is active\n- `FrostSpellHit` - Event/marker used by frost spells to trigger stack application\n\n### Systems Needed\n- `activate_permafrost` - Enables the passive effect when equipped\n- `apply_freeze_buildup` - Adds stacks to enemies hit by frost spells\n- `decay_freeze_stacks` - Reduces stacks over time if not refreshed\n- `check_freeze_threshold` - Applies FrozenStatus when max_stacks reached\n- `update_frozen_status` - Ticks frozen duration and removes when expired\n- `apply_frozen_stun` - Prevents frozen enemies from moving/attacking\n\n### File Location\n`src/spells/frost/permafrost.rs`\n\n## Visual Design\n- Enemies gain visible frost/ice accumulation as stacks build\n- At 50% stacks: light ice particles around enemy\n- At max stacks: enemy becomes encased in ice crystal effect\n- Frozen enemies have ice-block visual with crack effects as duration expires\n\n## Acceptance Criteria\n- [ ] Permafrost passive activates when spell is equipped\n- [ ] Frost spell hits add freeze stacks to enemies\n- [ ] Stacks decay over time if not refreshed\n- [ ] Enemy becomes frozen (stunned) at max stacks\n- [ ] Frozen enemies cannot move or attack\n- [ ] Frozen status expires after configured duration\n- [ ] Stacks reset to zero after frozen status ends\n\n## Required Tests\n- [ ] Test PermafrostEnabled marker is added when spell equipped\n- [ ] Test frost spell hits add FreezeBuildup stacks\n- [ ] Test stacks increment correctly up to max_stacks\n- [ ] Test stacks decay over time via decay_timer\n- [ ] Test FrozenStatus is applied when max_stacks reached\n- [ ] Test frozen enemy movement is prevented\n- [ ] Test frozen enemy attacks are prevented\n- [ ] Test FrozenStatus expires after duration and stacks reset","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:13:20.922692+11:00","updated_at":"2026-01-02T05:04:40.3369+11:00","closed_at":"2026-01-02T05:04:40.3369+11:00","dependencies":[{"issue_id":"dt-survivor-ogr","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:13:27.351803+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-osz","title":"Update Spell Casting System","description":"## Context\n\nPart of the spells refactoring epic (dt-survivor-jdd). The weapon firing system needs to be renamed and updated to work with the new spell system. This integrates SpellList (replacing Inventory), SpellType matching, and the WhisperAttunement damage multiplier.\n\n## Implementation Details\n\n### File Changes\n- Primary file: `src/spell/systems.rs`\n- May also touch: `src/spell/plugin.rs` for system registration\n\n### System Rename\n- Rename `weapon_firing_system` to `spell_casting_system`\n- Update all references in plugin registration\n- Update any system ordering constraints\n\n### SpellList Integration\n- Replace `Inventory` component queries with `SpellList`\n- SpellList contains up to 5 spell slots\n- Each slot has: SpellType, level, cooldown state\n\n### SpellType Matching\n- Use match expression on SpellType enum to call appropriate cast function:\n```rust\nmatch spell.spell_type {\n    SpellType::Fireball { .. } =\u003e cast_fireball(..),\n    SpellType::RadiantBeam { .. } =\u003e cast_radiant_beam(..),\n    SpellType::ThunderStrike { .. } =\u003e cast_thunder_strike(..),\n    SpellType::FrostNova { .. } =\u003e cast_frost_nova(..),\n    SpellType::VoidOrb { .. } =\u003e cast_void_orb(..),\n    // ... other spell types\n}\n```\n\n### WhisperAttunement Integration\n- Query for WhisperAttunement component on player\n- Apply damage multiplier to base spell damage\n- Formula: `final_damage = base_damage * attunement.damage_multiplier`\n\n### Cooldown Handling\n- Check cooldown timer before allowing cast\n- Reset cooldown timer after successful cast\n- Cooldown may vary by spell type and level\n\n### ECS Patterns\n- System runs in GameSet::Combat (or new GameSet::Casting)\n- Queries: `Query\u003c(\u0026SpellList, Option\u003c\u0026WhisperAttunement\u003e), With\u003cPlayer\u003e\u003e`\n- Uses Commands for spawning spell entities\n\n## Acceptance Criteria\n\n- [ ] System renamed from weapon_firing_system to spell_casting_system\n- [ ] SpellList queried instead of Inventory\n- [ ] All 5 spell slots can trigger casts\n- [ ] SpellType match dispatches to correct cast function\n- [ ] WhisperAttunement damage multiplier applied\n- [ ] Cooldowns prevent rapid casting\n- [ ] Cooldowns reset after cast\n- [ ] System registered correctly in plugin\n- [ ] System ordering preserved in GameSet\n\n## Required Tests\n\n1. **Slot Iteration**: All 5 spell slots checked for ready spells\n2. **SpellType Dispatch**: Each SpellType calls its correct cast function\n3. **Attunement Bonus**: Damage multiplier correctly applied when present\n4. **No Attunement**: Base damage used when WhisperAttunement absent\n5. **Cooldown Block**: Cannot cast while cooldown active\n6. **Cooldown Reset**: Cooldown timer resets after cast\n7. **Empty Slot**: Empty spell slots gracefully skipped\n8. **System Registration**: spell_casting_system runs in correct GameSet","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-01T21:05:51.081109+11:00","updated_at":"2026-01-02T00:07:52.852987+11:00","closed_at":"2026-01-02T00:07:52.852987+11:00","dependencies":[{"issue_id":"dt-survivor-osz","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:05:56.417324+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-p1n","title":"Add enemy visual differentiation by level (color and size)","description":"Make enemies visually distinct based on their level with different colors and sizes.\n\n## Context\nCurrent enemies use a red color (Color::srgb(1.0, 0.0, 0.0)) and fixed size (0.75 cube). The GameMaterials resource in src/game/systems.rs centralizes materials. Enemies spawn with Mesh3d and MeshMaterial3d components.\n\n## Implementation\n\n### Level-Based Materials (src/game/resources.rs or systems.rs)\n```rust\n/// Materials for each enemy rarity level\npub struct EnemyLevelMaterials {\n    pub common: Handle\u003cStandardMaterial\u003e,      // Grey\n    pub uncommon: Handle\u003cStandardMaterial\u003e,    // Green\n    pub rare: Handle\u003cStandardMaterial\u003e,        // Blue\n    pub epic: Handle\u003cStandardMaterial\u003e,        // Purple\n    pub legendary: Handle\u003cStandardMaterial\u003e,   // Gold with emissive\n}\n\nimpl EnemyLevelMaterials {\n    pub fn new(materials: \u0026mut Assets\u003cStandardMaterial\u003e) -\u003e Self {\n        Self {\n            common: materials.add(StandardMaterial {\n                base_color: Color::srgb(0.6, 0.6, 0.6),\n                ..default()\n            }),\n            uncommon: materials.add(StandardMaterial {\n                base_color: Color::srgb(0.0, 0.8, 0.2),\n                ..default()\n            }),\n            rare: materials.add(StandardMaterial {\n                base_color: Color::srgb(0.2, 0.4, 1.0),\n                ..default()\n            }),\n            epic: materials.add(StandardMaterial {\n                base_color: Color::srgb(0.6, 0.2, 0.8),\n                ..default()\n            }),\n            legendary: materials.add(StandardMaterial {\n                base_color: Color::srgb(1.0, 0.84, 0.0),\n                emissive: LinearRgba::new(1.0, 0.84, 0.0, 0.0) * 2.0,\n                ..default()\n            }),\n        }\n    }\n\n    pub fn for_level(\u0026self, level: u8) -\u003e Handle\u003cStandardMaterial\u003e {\n        match level {\n            1 =\u003e self.common.clone(),\n            2 =\u003e self.uncommon.clone(),\n            3 =\u003e self.rare.clone(),\n            4 =\u003e self.epic.clone(),\n            _ =\u003e self.legendary.clone(),\n        }\n    }\n}\n```\n\n### Level-Based Size Scaling\n```rust\n/// Calculate enemy scale based on level\npub fn enemy_scale_for_level(level: u8) -\u003e f32 {\n    // Base scale is 0.75, increase by 15% per level above 1\n    let base_scale = 0.75;\n    let scale_per_level = 0.15;\n    base_scale + (level.saturating_sub(1) as f32 * scale_per_level)\n}\n\n// Size progression:\n// Level 1: 0.75 (base)\n// Level 2: 0.90\n// Level 3: 1.05\n// Level 4: 1.20\n// Level 5: 1.35\n```\n\n### Enemy Spawning Update (src/enemies/systems.rs)\n```rust\npub fn spawn_enemies_system(\n    // ... existing params ...\n    enemy_materials: Res\u003cEnemyLevelMaterials\u003e,\n) {\n    let enemy_level = select_enemy_level(game_level.level, \u0026mut rng);\n    let scale = enemy_scale_for_level(enemy_level);\n    \n    commands.spawn((\n        Enemy { /* ... */ },\n        Level::new(enemy_level),\n        Mesh3d(game_meshes.enemy.clone()),\n        MeshMaterial3d(enemy_materials.for_level(enemy_level)),\n        Transform::from_translation(spawn_pos)\n            .with_scale(Vec3::splat(scale)),\n        // ... other components ...\n    ));\n}\n```\n\n### Resource Registration (src/game/plugin.rs)\n```rust\n// In setup_game_assets system\nfn setup_game_assets(\n    mut commands: Commands,\n    mut materials: ResMut\u003cAssets\u003cStandardMaterial\u003e\u003e,\n    // ...\n) {\n    commands.insert_resource(EnemyLevelMaterials::new(\u0026mut materials));\n}\n```\n\n## Color Scheme Reference\n| Level | Rarity    | Color                  | RGB               |\n|-------|-----------|------------------------|-------------------|\n| 1     | Common    | Grey                   | (0.6, 0.6, 0.6)   |\n| 2     | Uncommon  | Green                  | (0.0, 0.8, 0.2)   |\n| 3     | Rare      | Blue                   | (0.2, 0.4, 1.0)   |\n| 4     | Epic      | Purple                 | (0.6, 0.2, 0.8)   |\n| 5     | Legendary | Gold (emissive glow)   | (1.0, 0.84, 0.0)  |\n\n## Acceptance Criteria\n- [ ] EnemyLevelMaterials resource created with 5 materials\n- [ ] Enemies spawn with correct material based on level\n- [ ] Enemies spawn with correct scale based on level (0.75 to 1.35)\n- [ ] Legendary enemies have emissive glow effect\n- [ ] Materials cached in resource (not created per spawn)\n- [ ] Unit tests for enemy_scale_for_level function\n- [ ] Visual inspection confirms distinct enemy appearances\n\n## Test Requirements\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn enemy_scale_increases_with_level() {\n        let scale_1 = enemy_scale_for_level(1);\n        let scale_5 = enemy_scale_for_level(5);\n        assert!(scale_5 \u003e scale_1);\n        assert_eq!(scale_1, 0.75);\n    }\n\n    #[test]\n    fn enemy_scale_is_reasonable() {\n        for level in 1..=5 {\n            let scale = enemy_scale_for_level(level);\n            assert!(scale \u003e= 0.75 \u0026\u0026 scale \u003c= 1.5);\n        }\n    }\n}\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-30T09:42:01.51049+11:00","updated_at":"2025-12-30T11:00:02.857155+11:00","closed_at":"2025-12-30T11:00:02.857155+11:00","dependencies":[{"issue_id":"dt-survivor-p1n","depends_on_id":"dt-survivor-wvj","type":"blocks","created_at":"2025-12-30T09:45:07.037007+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-p1n","depends_on_id":"dt-survivor-aiy","type":"parent-child","created_at":"2025-12-30T09:45:19.197443+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-qlv","title":"Implement Fear Spell (Chaos)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Fear\n- **Element**: Chaos\n- **Behavior**: Enemies flee uncontrollably for a short duration. AOE burst around player or at target location causes affected enemies to run away from the player.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct FearBurst {\n    pub radius: f32,\n}\n\n#[derive(Component)]\npub struct FearedEnemy {\n    pub flee_duration: Timer,\n    pub flee_direction: Vec2,\n}\n```\n\n### Systems\n- `spawn_fear_burst` - Create fear AOE when spell cast\n- `apply_fear_to_enemies` - Check enemies in radius, apply FearedEnemy component\n- `update_feared_enemies` - Override enemy movement to flee from player\n- `cleanup_fear_effect` - Remove FearedEnemy when duration expires\n\n### File Location\n`src/spells/chaos/fear.rs`\n\n## Visual Design\n- Magenta/pink expanding ring for the burst\n- Affected enemies get glitchy/distorted shader effect\n- Shifting purple particles trailing feared enemies\n- Unstable flickering on fear application\n\n## Acceptance Criteria\n- [ ] Fear burst creates visible AOE effect at cast location\n- [ ] Enemies within radius receive FearedEnemy component\n- [ ] Feared enemies move away from player at increased speed\n- [ ] Fear duration is configurable and expires correctly\n- [ ] Feared enemies ignore their normal AI targeting\n- [ ] Visual effects clearly indicate feared state\n- [ ] Multiple fear applications refresh duration\n\n## Required Tests\n- `test_fear_burst_spawns_with_correct_radius` - Verify component initialization\n- `test_fear_applies_to_enemies_in_radius` - Enemies in range get feared\n- `test_fear_does_not_affect_enemies_outside_radius` - Boundary check\n- `test_feared_enemy_moves_away_from_player` - Movement direction validation\n- `test_fear_duration_expires_correctly` - Timer cleanup\n- `test_fear_effect_removed_on_expiry` - Component removal\n- `test_multiple_fear_refreshes_duration` - Duration stacking behavior\n- `test_feared_enemy_ignores_normal_ai` - AI override verification","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:16:07.753823+11:00","updated_at":"2026-01-02T05:32:43.180661+11:00","closed_at":"2026-01-02T05:32:43.180661+11:00","dependencies":[{"issue_id":"dt-survivor-qlv","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:16:13.917568+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-qy4","title":"Update player mouse input to use 3D ray casting","description":"# Task: Player Input 3D Ray Casting\n\n## Context\nDT Survivor is migrating from 2D to 3D. Player movement is controlled by clicking on the screen. Currently, cursor position is converted to 2D world coordinates using `viewport_to_world_2d`. For 3D, we need to cast a ray from the camera through the cursor and intersect it with the ground plane (Y=0).\n\n## Current Implementation\n**Player Movement** (`src/movement/systems.rs:39-82`):\n```rust\npub fn player_movement(\n    // ... params\n    camera_query: Query\u003c(\u0026Camera, \u0026GlobalTransform)\u003e,\n    // ...\n) {\n    // ... button check ...\n    \n    if let Some(world_pos) = camera.viewport_to_world_2d(camera_transform, cursor_pos) {\n        let direction = (world_pos - player_pos).normalize_or_zero();\n        // ... apply movement\n    }\n}\n```\n\nUses `viewport_to_world_2d` which returns `Option\u003cVec2\u003e` for 2D world position.\n\n## Required Changes\n\n### 1. Replace viewport_to_world_2d with 3D Ray Casting\n```rust\npub fn player_movement(\n    buttons: Res\u003cButtonInput\u003cMouseButton\u003e\u003e,\n    windows: Query\u003c\u0026Window\u003e,\n    camera_query: Query\u003c(\u0026Camera, \u0026GlobalTransform), With\u003cCamera3d\u003e\u003e,\n    mut player_query: Query\u003c(\u0026mut Transform, \u0026Player)\u003e,\n    time: Res\u003cTime\u003e,\n) {\n    if !buttons.pressed(MouseButton::Left) {\n        return;\n    }\n\n    let window = windows.single();\n    let Some(cursor_pos) = window.cursor_position() else { return };\n    \n    let Ok((camera, camera_transform)) = camera_query.get_single() else { return };\n    let Ok((mut player_transform, player)) = player_query.get_single_mut() else { return };\n\n    // Cast ray from camera through cursor\n    let Some(ray) = camera.viewport_to_world(camera_transform, cursor_pos) else { return };\n    \n    // Intersect ray with Y=0 plane (ground)\n    // Ray: origin + direction * t = point\n    // For Y=0: origin.y + direction.y * t = 0\n    // Therefore: t = -origin.y / direction.y\n    if ray.direction.y.abs() \u003c 0.0001 {\n        return; // Ray parallel to ground, no intersection\n    }\n    \n    let t = -ray.origin.y / ray.direction.y;\n    if t \u003c 0.0 {\n        return; // Intersection behind camera\n    }\n    \n    let world_pos = ray.origin + ray.direction * t;\n    let target_xz = Vec2::new(world_pos.x, world_pos.z);\n    let player_xz = Vec2::new(player_transform.translation.x, player_transform.translation.z);\n    \n    let direction = (target_xz - player_xz).normalize_or_zero();\n    \n    // Apply movement on XZ plane\n    let speed = player.speed; // Apply slow modifier if present\n    let movement = direction * speed * time.delta_secs();\n    player_transform.translation += Vec3::new(movement.x, 0.0, movement.y);\n}\n```\n\n### 2. Update Query to Use Camera3d\nChange camera query to filter by `Camera3d` component.\n\n### 3. Handle SlowModifier\nEnsure `SlowModifier` component still works for speed reduction:\n```rust\nlet effective_speed = if let Ok(slow) = slow_query.get(player_entity) {\n    player.speed * slow.multiplier\n} else {\n    player.speed\n};\n```\n\n## Testing Requirements\n- Unit test: Ray casting returns correct world position\n- Unit test: Ray-plane intersection calculates correct XZ point\n- Unit test: Player moves toward cursor world position\n- Unit test: Movement applies to X and Z axes only\n- Unit test: Player Y position unchanged\n- Unit test: Parallel ray (edge case) handled gracefully\n- Unit test: Behind-camera intersection ignored\n- Update existing player movement tests\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] viewport_to_world_2d replaced with 3D ray casting\n- [ ] Ray intersects Y=0 ground plane correctly\n- [ ] Player moves toward click position on XZ plane\n- [ ] Player Y position stays constant\n- [ ] Edge cases handled (parallel ray, behind camera)\n- [ ] SlowModifier still reduces movement speed\n- [ ] Mouse button detection unchanged\n- [ ] All movement tests updated and passing\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:49:18.998883+11:00","updated_at":"2025-12-28T10:26:08.600548+11:00","closed_at":"2025-12-28T10:26:08.600548+11:00","dependencies":[{"issue_id":"dt-survivor-qy4","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.701572+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-qy4","depends_on_id":"dt-survivor-nq8","type":"blocks","created_at":"2025-12-28T09:50:36.726173+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-rfz","title":"Replace Whisper 2D materials with bevy_hanabi particle effects","description":"# Task: Whisper Particle Replacement\n\n## Context\nDT Survivor is migrating from 2D to 3D. The Whisper weapon uses custom 2D materials (`AdditiveTextureMaterial`, `AdditiveColorMaterial`) for glow and lightning effects that are incompatible with 3D rendering. Per user decision, these will be replaced with bevy_hanabi particle effects which already work in 3D.\n\n## Current Implementation\n**2D Materials** (`src/whisper/materials.rs`):\n- `AdditiveTextureMaterial`: Custom Material2d with additive blend shader for glow\n- `AdditiveColorMaterial`: Custom Material2d for solid color lightning bolts\n\n**Plugin Registration** (`src/whisper/plugin.rs:14-17`):\n```rust\n.add_plugins((\n    Material2dPlugin::\u003cAdditiveTextureMaterial\u003e::default(),\n    Material2dPlugin::\u003cAdditiveColorMaterial\u003e::default(),\n))\n```\n\n**2D Mesh Usage** (`src/whisper/systems.rs`):\n- Uses `Mesh2d` and `MeshMaterial2d` for glow textures\n- Uses `PointLight2d` for lighting effects\n\n## Required Changes\n\n### 1. Remove 2D Material Plugin Registration\nIn `src/whisper/plugin.rs`, remove:\n```rust\nMaterial2dPlugin::\u003cAdditiveTextureMaterial\u003e::default(),\nMaterial2dPlugin::\u003cAdditiveColorMaterial\u003e::default(),\n```\n\n### 2. Remove 2D Material Spawning\nRemove or replace entities that use:\n- `Mesh2d` component\n- `MeshMaterial2d\u003cAdditiveTextureMaterial\u003e`\n- `MeshMaterial2d\u003cAdditiveColorMaterial\u003e`\n- `PointLight2d`\n\n### 3. Enhance Particle Effects\nThe existing bevy_hanabi particles should be enhanced to replace the visual effects:\n\n**Glow Effect Replacement**:\n```rust\n// Create a particle burst for glow\nlet mut gradient = Gradient::new();\ngradient.add_key(0.0, Vec4::new(1.0, 0.3, 0.3, 1.0)); // Red glow\ngradient.add_key(1.0, Vec4::new(1.0, 0.1, 0.1, 0.0)); // Fade out\n\n// Spawner with short-lived particles around whisper\nlet spawner = Spawner::rate(50.0.into());\n```\n\n**Lightning Effect Replacement**:\n```rust\n// Quick spark particles for lightning\nlet mut gradient = Gradient::new();\ngradient.add_key(0.0, Vec4::new(1.0, 0.0, 0.0, 1.0)); // Bright red\ngradient.add_key(0.5, Vec4::new(1.0, 0.5, 0.0, 0.8)); // Orange\ngradient.add_key(1.0, Vec4::new(0.5, 0.0, 0.0, 0.0)); // Fade\n\n// Burst spawner for lightning flashes\nlet spawner = Spawner::burst(20.0.into(), 0.1.into());\n```\n\n### 4. Update Particle Axes for 3D\nChange particle spawn circles from XY plane to XZ plane:\n```rust\n// Before (2D)\nlet init_pos = SetPositionCircleModifier {\n    axis: writer.lit(Vec3::Z).expr(), // Circle in XY plane\n    ...\n};\n\n// After (3D)\nlet init_pos = SetPositionCircleModifier {\n    axis: writer.lit(Vec3::Y).expr(), // Circle in XZ plane (ground)\n    ...\n};\n```\n\n### 5. Add 3D PointLight for Glow\nReplace `PointLight2d` with 3D `PointLight`:\n```rust\ncommands.spawn((\n    PointLight {\n        color: Color::srgb(1.0, 0.3, 0.3),\n        intensity: 5000.0,\n        radius: 5.0,\n        ..default()\n    },\n    Transform::from_translation(whisper_position),\n    WhisperLight, // Marker component\n));\n```\n\n### 6. Clean Up Unused Code\n- Remove or deprecate `AdditiveTextureMaterial` and `AdditiveColorMaterial`\n- Remove shader files if no longer needed: `assets/shaders/additive_textured.wgsl`, `additive_color.wgsl`\n- Remove texture loading for 2D glow textures\n\n## Testing Requirements\n- Unit test: Whisper spawns without 2D material components\n- Unit test: Particle effects spawn with correct axis\n- Unit test: PointLight3d follows whisper position\n- Unit test: No Mesh2d components in whisper entities\n- Unit test: Particle gradient colors correct\n- Integration test: Whisper weapon functions without crash\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] Material2dPlugin registrations removed\n- [ ] No Mesh2d or MeshMaterial2d components used\n- [ ] PointLight2d replaced with PointLight (3D)\n- [ ] Particle effects provide visual feedback\n- [ ] Particle spawn axes updated for XZ ground plane\n- [ ] Whisper weapon still functions correctly\n- [ ] No visual artifacts or crashes\n- [ ] All whisper tests updated and passing\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:49:20.713811+11:00","updated_at":"2025-12-28T11:14:26.843123+11:00","closed_at":"2025-12-28T11:14:26.843123+11:00","dependencies":[{"issue_id":"dt-survivor-rfz","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.832154+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-rfz","depends_on_id":"dt-survivor-nq8","type":"blocks","created_at":"2025-12-28T09:50:36.857261+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-rfz","depends_on_id":"dt-survivor-8i6","type":"blocks","created_at":"2025-12-28T10:41:53.848561+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-ryh","title":"Update camera follow system for 3D isometric view","description":"# Task: Camera Follow System Update\n\n## Context\nDT Survivor is migrating from 2D to 3D. The camera currently tracks the player by copying X and Y coordinates. For the 3D isometric view, the camera must maintain a fixed offset and rotation while following the player on the XZ plane.\n\n## Current Implementation\n**Camera Follow** (`src/player/systems.rs:194-209`):\n```rust\npub fn camera_follow_player(\n    player_query: Query\u003c\u0026Transform, With\u003cPlayer\u003e\u003e,\n    mut camera_query: Query\u003c\u0026mut Transform, (With\u003cCamera\u003e, Without\u003cPlayer\u003e)\u003e,\n    mut player_position: ResMut\u003cPlayerPosition\u003e,\n) {\n    if let Ok(player_transform) = player_query.single() {\n        let player_pos = player_transform.translation.truncate();\n        player_position.0 = player_pos;\n\n        for mut camera_transform in camera_query.iter_mut() {\n            camera_transform.translation.x = player_transform.translation.x;\n            camera_transform.translation.y = player_transform.translation.y;\n        }\n    }\n}\n```\n\n## Required Changes\n\n### 1. Update Camera Follow to Maintain Isometric Offset\n```rust\npub fn camera_follow_player(\n    player_query: Query\u003c\u0026Transform, With\u003cPlayer\u003e\u003e,\n    mut camera_query: Query\u003c\u0026mut Transform, (With\u003cCamera3d\u003e, Without\u003cPlayer\u003e)\u003e,\n    mut player_position: ResMut\u003cPlayerPosition\u003e,\n) {\n    if let Ok(player_transform) = player_query.single() {\n        // Update PlayerPosition with XZ coordinates\n        player_position.0 = Vec2::new(\n            player_transform.translation.x,\n            player_transform.translation.z,\n        );\n\n        // Isometric camera offset (matching initial camera setup)\n        let camera_offset = Vec3::new(0.0, 20.0, 15.0);\n        \n        for mut camera_transform in camera_query.iter_mut() {\n            // Maintain offset while following player on XZ plane\n            let target_pos = player_transform.translation + camera_offset;\n            camera_transform.translation = target_pos;\n            // Note: Rotation is fixed (set during camera spawn)\n        }\n    }\n}\n```\n\n### 2. Update Query to Use Camera3d\nChange from `With\u003cCamera\u003e` to `With\u003cCamera3d\u003e` to match new camera type.\n\n### 3. Update PlayerPosition Extraction\nEnsure `PlayerPosition` stores XZ coordinates (X, Z) instead of XY:\n```rust\nplayer_position.0 = Vec2::new(\n    player_transform.translation.x,\n    player_transform.translation.z, // Z instead of Y\n);\n```\n\n### 4. Consider Smooth Following (Optional Enhancement)\nFor smoother camera movement, add interpolation:\n```rust\nlet target_pos = player_transform.translation + camera_offset;\ncamera_transform.translation = camera_transform.translation.lerp(target_pos, 5.0 * time.delta_secs());\n```\n\n## Testing Requirements\n- Unit test: Camera maintains correct offset from player\n- Unit test: Camera offset is Vec3(0, 20, 15)\n- Unit test: Camera follows player movement on XZ plane\n- Unit test: Camera Y position stays at player.y + 20\n- Unit test: Camera rotation unchanged during following\n- Unit test: PlayerPosition updated with XZ coordinates\n- Update existing camera tests for 3D\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] Camera follows player on XZ plane\n- [ ] Camera maintains fixed Y offset above player\n- [ ] Camera maintains fixed Z offset behind player\n- [ ] Camera rotation stays fixed (isometric angle)\n- [ ] PlayerPosition resource updated correctly\n- [ ] Query uses Camera3d component\n- [ ] All camera tests updated and passing\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:49:18.811863+11:00","updated_at":"2025-12-28T10:18:42.251049+11:00","closed_at":"2025-12-28T10:18:42.251049+11:00","dependencies":[{"issue_id":"dt-survivor-ryh","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.635111+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-ryh","depends_on_id":"dt-survivor-nq8","type":"blocks","created_at":"2025-12-28T09:50:36.660028+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-ryz","title":"Delete tmp/spells.csv After Implementation","description":"Part of the Spells System Refactoring (dt-survivor-jdd). Final cleanup task.\n\n## Overview\nAfter all 64 spells are implemented with their metadata stored in code, delete the temporary CSV file that was used as a reference during implementation.\n\n## Context\nThe file tmp/spells.csv contains the spell definitions:\n- Name, Element, Description for all 64 spells\n- This was a temporary reference file for implementation\n- All spell data is now in SpellType enum methods\n\n## Verification Before Deletion\n1. Confirm all 64 SpellType variants exist\n2. Verify each spell has correct element() method\n3. Verify each spell has correct name() method  \n4. Verify each spell has correct description() method\n5. Run full test suite to confirm nothing references CSV\n\n## Files\n- DELETE: tmp/spells.csv\n\n## Acceptance Criteria\n- [ ] All 64 spells implemented and tested\n- [ ] SpellType::name() returns correct name for all variants\n- [ ] SpellType::element() returns correct element for all variants\n- [ ] SpellType::description() returns correct description for all variants\n- [ ] No code references tmp/spells.csv\n- [ ] Full test suite passes\n- [ ] File deleted from repository\n\n## Required Tests\n1. test_all_spell_types_have_name - verify name() not empty\n2. test_all_spell_types_have_element - verify element() returns valid\n3. test_all_spell_types_have_description - verify description() not empty\n4. test_spell_count_is_64 - verify exactly 64 variants\n5. test_no_csv_file_references - grep codebase for csv references","status":"closed","priority":3,"issue_type":"chore","created_at":"2026-01-01T21:20:23.037581+11:00","updated_at":"2026-01-02T10:12:37.548714+11:00","closed_at":"2026-01-02T10:12:37.548714+11:00","dependencies":[{"issue_id":"dt-survivor-ryz","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:20:31.870884+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-s2u","title":"Refactor codebase to Bevy ECS best practices","description":"Comprehensive refactoring to align the dt-survivor codebase with Bevy ECS best practices. Includes: unified combat module with Health/Damage components, SystemSets for explicit ordering, movement module consolidation, weapon plugin population, loot module cleanup, event registration fixes, and various polish items. See plan at ~/.claude/plans/lovely-napping-starfish.md for full details.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-25T17:40:02.957854+11:00","updated_at":"2025-12-25T20:11:37.36042+11:00","closed_at":"2025-12-25T20:11:37.36042+11:00"}
{"id":"dt-survivor-sej","title":"Fix AoE spell transparency - spherical effects too opaque","description":"Most AoE spells with spherical visualization are not transparent enough. Current opacities are 50-70% which obscures gameplay. Need to lower opacity and potentially adjust blending for better see-through visibility.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-02T11:45:18.826927+11:00","updated_at":"2026-01-02T11:47:18.373908+11:00","closed_at":"2026-01-02T11:47:18.373908+11:00"}
{"id":"dt-survivor-tu8","title":"Implement Pandemonium Spell (Chaos)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Pandemonium\n- **Element**: Chaos\n- **Behavior**: Enemies behave erratically and attack randomly. Applies a debuff causing enemies to target randomly, including attacking other enemies. Creates friendly fire chaos among enemy ranks.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct PandemoniumDebuff {\n    pub duration: Timer,\n}\n\n#[derive(Component)]\npub struct ConfusedEnemy {\n    pub current_target: Option\u003cEntity\u003e,\n    pub retarget_timer: Timer,\n}\n```\n\n### Systems\n- `spawn_pandemonium_burst` - Create AOE that applies confusion\n- `apply_pandemonium_debuff` - Add debuff components to enemies in range\n- `update_confused_enemy_targeting` - Override enemy AI to target randomly\n- `confused_enemy_attack` - Allow enemies to damage each other\n- `cleanup_pandemonium` - Remove debuff when duration expires\n\n### File Location\n`src/spells/chaos/pandemonium.rs`\n\n## Visual Design\n- Initial burst: magenta shockwave with chaotic symbols\n- Confused enemies: spiral effect over head, eyes change color\n- Glitchy/unstable visual distortion on affected enemies\n- Pink/purple aura indicating confused state\n- Attack trails between confused enemies for friendly fire visibility\n\n## Acceptance Criteria\n- [ ] Pandemonium applies confusion to enemies in AOE radius\n- [ ] Confused enemies randomly retarget including other enemies\n- [ ] Enemies can damage and kill each other while confused\n- [ ] Duration is configurable and expires correctly\n- [ ] Normal enemy AI resumes after debuff expires\n- [ ] Visual clearly indicates which enemies are confused\n- [ ] Retargeting happens periodically, not every frame\n\n## Required Tests\n- `test_pandemonium_applies_debuff_in_radius` - AOE application\n- `test_confused_enemy_targets_other_enemies` - Random targeting works\n- `test_confused_enemy_can_damage_allies` - Friendly fire enabled\n- `test_pandemonium_duration_expires` - Timer cleanup\n- `test_confused_enemy_retargets_periodically` - Not constant retargeting\n- `test_normal_ai_resumes_after_debuff` - State restoration\n- `test_pandemonium_does_not_affect_player` - Player immunity\n- `test_enemy_kills_count_for_score` - Deaths from friendly fire still count","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:17:23.11622+11:00","updated_at":"2026-01-02T07:35:15.714561+11:00","closed_at":"2026-01-02T07:35:15.714561+11:00","dependencies":[{"issue_id":"dt-survivor-tu8","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:17:29.739458+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-ubg","title":"Consolidate timer cleanup components","description":"Replace AudioCleanupTimer, ExperienceAudioCleanupTimer, LootAudioCleanupTimer with generic CleanupTimer { timer: Timer, cleanup_type: CleanupType }. Create CleanupType enum with Audio, Experience, Loot variants. Update systems in audio, experience, loot modules.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-25T17:42:02.50933+11:00","updated_at":"2025-12-25T19:57:36.794894+11:00","closed_at":"2025-12-25T19:57:36.794894+11:00","dependencies":[{"issue_id":"dt-survivor-ubg","depends_on_id":"dt-survivor-xp9","type":"blocks","created_at":"2025-12-25T17:42:19.955527+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-ubg","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:42:21.259164+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-umn","title":"Convert loot spawning from Sprite to Mesh3d cubes","description":"# Task: Loot 3D Spawning\n\n## Context\nDT Survivor is migrating from 2D to 3D. Loot items (XP orbs, weapons, health packs, powerups) spawn as colored sprites when enemies die and need to be converted to 3D cubes. Loot attraction physics work on XY plane and must be converted to XZ.\n\n## Current Implementation\n**Loot Spawning** (`src/loot/systems.rs:15-128`):\n```rust\n// Experience orbs\ncommands.spawn((\n    Sprite::from_color(Color::srgb(0.75, 0.75, 0.75), Vec2::new(8.0, 8.0)),\n    Transform::from_translation(Vec3::new(enemy_pos.x + offset_x, enemy_pos.y + offset_y, 0.2)),\n    DroppedItem { pickup_state: PickupState::Idle, item_data: ItemData::Experience { amount }, velocity: Vec2::ZERO },\n));\n\n// Weapon drops\ncommands.spawn((\n    Sprite::from_color(color, Vec2::new(16.0, 16.0)),\n    Transform::from_translation(Vec3::new(enemy_pos.x, enemy_pos.y, 0.5)),\n    DroppedItem { ... },\n));\n```\n\n**Loot Colors by Type**:\n- Pistol: Yellow (1.0, 1.0, 0.0), 16x16\n- Laser: Blue (0.0, 0.0, 1.0), 16x16\n- Rocket: Orange (1.0, 0.5, 0.0), 16x16\n- Health Pack: Green (0.0, 1.0, 0.0), 12x12\n- Experience: Grey (0.75, 0.75, 0.75), 8x8\n\n## Required Changes\n\n### 1. Update Loot Spawn Positions\nConvert from XY to XZ plane:\n```rust\n// Before\nVec3::new(enemy_pos.x + offset_x, enemy_pos.y + offset_y, 0.2)\n\n// After\nVec3::new(enemy_pos.x + offset_x, 0.2, enemy_pos.z + offset_z)\n```\n\n### 2. Update Loot Spawning to Use 3D Meshes\n```rust\n// XP Orb\ncommands.spawn((\n    Mesh3d(game_meshes.loot_small.clone()),\n    MeshMaterial3d(game_materials.xp_orb.clone()),\n    Transform::from_translation(Vec3::new(x, 0.2, z)),\n    DroppedItem { ... },\n));\n\n// Weapon\ncommands.spawn((\n    Mesh3d(game_meshes.loot_large.clone()),\n    MeshMaterial3d(game_materials.weapon_pistol.clone()),\n    Transform::from_translation(Vec3::new(x, 0.3, z)),\n    DroppedItem { ... },\n));\n```\n\n### 3. Update Loot Attraction Physics\nThe loot attraction system uses velocity Vec2 and applies to transform. Update to use XZ:\n```rust\n// Before\ntransform.translation += velocity.extend(0.0) * time.delta_secs();\n\n// After\nlet vel = item.velocity * time.delta_secs();\ntransform.translation += Vec3::new(vel.x, 0.0, vel.y);\n```\n\n### 4. Update Pickup Detection\n```rust\n// Before\nlet loot_pos = loot_transform.translation.truncate();\nlet player_pos = player_transform.translation.truncate();\n\n// After\nlet loot_pos = Vec2::new(loot_transform.translation.x, loot_transform.translation.z);\nlet player_pos = Vec2::new(player_transform.translation.x, player_transform.translation.z);\n```\n\n## Testing Requirements\n- Unit test: XP orbs spawn with Mesh3d component\n- Unit test: Weapon drops spawn with correct material for type\n- Unit test: Loot spawns on XZ plane with correct Y height\n- Unit test: Loot attraction works on XZ plane\n- Unit test: Pickup detection works on XZ plane\n- Unit test: Pickup radius unchanged\n- Update existing loot tests for 3D coordinates\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] XP orbs render as small grey cubes\n- [ ] Weapons render as larger colored cubes (yellow/blue/orange)\n- [ ] Health packs render as green cubes\n- [ ] Loot spawns on XZ plane when enemies die\n- [ ] Loot attraction physics work correctly in 3D\n- [ ] Pickup detection functional on XZ plane\n- [ ] Drop rates unchanged\n- [ ] No Sprite components in loot spawning\n- [ ] All existing loot tests updated and passing\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:46:33.773539+11:00","updated_at":"2025-12-28T10:23:16.809182+11:00","closed_at":"2025-12-28T10:23:16.809182+11:00","dependencies":[{"issue_id":"dt-survivor-umn","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.503453+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-umn","depends_on_id":"dt-survivor-ggr","type":"blocks","created_at":"2025-12-28T09:50:35.497345+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-uwk","title":"Implement Echo Thought Spell (Psychic)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Echo Thought\n- **Element**: Psychic\n- **Behavior**: Psychic afterimages repeat the last attack. Creates ghost copies that replay recent spell casts, dealing reduced damage. Allows for combo potential with other spells.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct EchoThought {\n    pub echoes_remaining: u32,\n    pub echo_delay: Timer,\n}\n\n#[derive(Component)]\npub struct SpellEcho {\n    pub spell_to_repeat: SpellType,\n    pub source_position: Vec2,\n    pub source_direction: Vec2,\n    pub damage_multiplier: f32,  // Usually 0.3-0.5\n}\n\n#[derive(Component)]\npub struct EchoVisual {\n    pub opacity: f32,\n}\n```\n\n### Systems Needed\n1. `track_last_spell_cast` - Record spell for echo replay\n2. `spawn_echo_thought` - Create echo entity after delay\n3. `replay_echo_spell` - Execute the echoed spell\n4. `update_echo_visual` - Ghostly appearance effect\n5. `cleanup_echo` - Remove after replay complete\n\n### File Location\n`src/spells/psychic/echo_thought.rs`\n\n## Visual Design\n- Ghost copies are translucent pink/magenta\n- Violet afterimage trail on echo movement\n- Echoes slightly phase-shifted from original position\n- Fade effect as echo completes its action\n\n## Acceptance Criteria\n- [ ] Echo Thought records the last spell cast\n- [ ] Ghost copies spawn after configured delay\n- [ ] Echoes replay the recorded spell at reduced damage\n- [ ] Multiple echoes spawn in sequence if configured\n- [ ] Echoed spells have distinct ghostly visual\n- [ ] Works with all other spell types\n- [ ] Integrates with spell cooldown system\n\n## Required Tests\n1. `test_echo_records_last_spell` - Spell tracking works\n2. `test_echo_spawns_after_delay` - Correct timing\n3. `test_echo_damage_multiplier` - Reduced damage applied\n4. `test_echo_multiple_echoes` - Sequential echoes work\n5. `test_echo_replays_correct_spell` - Right spell executed\n6. `test_echo_position_offset` - Echoes offset from original\n7. `test_echo_cleanup` - Entities removed after replay\n8. `test_echo_no_spell_to_echo` - Behavior when nothing to echo","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:17:44.311185+11:00","updated_at":"2026-01-02T08:00:46.730061+11:00","closed_at":"2026-01-02T08:00:46.730061+11:00","dependencies":[{"issue_id":"dt-survivor-uwk","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:17:50.244468+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-v4u","title":"Implement Chaos Bolt Spell (Chaos)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Chaos Bolt\n- **Element**: Chaos\n- **Behavior**: Unstable projectile with random effects. Fires a projectile that applies a random effect on hit from a pool including: damage, slow, burn, poison, stun, and more.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct ChaosBolt {\n    pub speed: f32,\n    pub base_damage: f32,\n}\n\n#[derive(Component, Clone)]\npub enum RandomEffect {\n    ExtraDamage(f32),\n    Slow { factor: f32, duration: f32 },\n    Burn { damage_per_tick: f32, duration: f32 },\n    Poison { damage_per_tick: f32, duration: f32 },\n    Stun { duration: f32 },\n    Knockback { force: f32 },\n    Fear { duration: f32 },\n}\n```\n\n### Systems\n- `spawn_chaos_bolt` - Create projectile with random pre-determined effect\n- `update_chaos_bolt_movement` - Standard projectile movement\n- `chaos_bolt_collision` - On hit, apply the random effect to target\n- `cleanup_chaos_bolt` - Despawn on hit or timeout\n\n### File Location\n`src/spells/chaos/chaos_bolt.rs`\n\n## Visual Design\n- Projectile with shifting magenta/pink/purple colors\n- Crackling unstable energy effect around the bolt\n- Color hints at the random effect (subtle glow matching effect type)\n- Glitchy trail particles that phase in and out\n\n## Acceptance Criteria\n- [ ] Chaos Bolt fires as a projectile toward target/cursor\n- [ ] Random effect is determined on spawn (not on hit)\n- [ ] All effect types can be rolled and applied correctly\n- [ ] Base damage is always dealt plus the random effect\n- [ ] Visual appearance reflects chaotic/unstable nature\n- [ ] Effect distribution is reasonably balanced\n- [ ] Bolt despawns after hitting enemy or reaching max range\n\n## Required Tests\n- `test_chaos_bolt_spawns_with_random_effect` - Effect is assigned on creation\n- `test_chaos_bolt_moves_toward_target` - Movement system works\n- `test_chaos_bolt_deals_base_damage` - Damage is always applied\n- `test_chaos_bolt_applies_slow_effect` - Slow variant works\n- `test_chaos_bolt_applies_burn_effect` - Burn variant works\n- `test_chaos_bolt_applies_poison_effect` - Poison variant works\n- `test_chaos_bolt_applies_stun_effect` - Stun variant works\n- `test_chaos_bolt_despawns_on_hit` - Cleanup after collision","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:16:36.56878+11:00","updated_at":"2026-01-02T06:09:55.964871+11:00","closed_at":"2026-01-02T06:09:55.964871+11:00","dependencies":[{"issue_id":"dt-survivor-v4u","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:16:42.388262+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-vmx","title":"Create WhisperAttunement Resource","description":"## Context\n\nPart of the spells system refactoring for dt-survivor. WhisperAttunement represents the player's elemental attunement chosen at the start of a run, providing a damage bonus to matching element spells.\n\n## Implementation Details\n\n### File Location\n- Modify: src/whisper/resources.rs\n\n### WhisperAttunement Struct\n```rust\n#[derive(Resource, Default)]\npub struct WhisperAttunement {\n    element: Option\u003cElement\u003e,\n}\n```\n\n### Methods to Implement\n```rust\nimpl WhisperAttunement {\n    /// Create new attunement with no element selected\n    pub fn new() -\u003e Self\n\n    /// Create attunement with specific element\n    pub fn with_element(element: Element) -\u003e Self\n\n    /// Set the attuned element\n    pub fn set_element(\u0026mut self, element: Element)\n\n    /// Clear the attunement\n    pub fn clear(\u0026mut self)\n\n    /// Get current attuned element\n    pub fn element(\u0026self) -\u003e Option\u003cElement\u003e\n\n    /// Calculate damage multiplier for a spell's element\n    /// Returns 1.1 (10% bonus) for matching element, 1.0 otherwise\n    pub fn damage_multiplier(\u0026self, spell_element: Element) -\u003e f32\n}\n```\n\n### Integration\n- Selected during GameState::AttunementSelect\n- Applied in damage calculation systems\n- Displayed in UI HUD\n\n## ECS Patterns\n\n- Use `#[derive(Resource, Default)]`\n- Follow resource pattern from whisper/resources.rs\n- Register in whisper plugin\n\n## Acceptance Criteria\n\n- [ ] WhisperAttunement struct defined\n- [ ] Optional element field\n- [ ] new() returns no attunement\n- [ ] with_element() creates with attunement\n- [ ] set_element() updates attunement\n- [ ] clear() removes attunement\n- [ ] element() returns current attunement\n- [ ] damage_multiplier() returns 1.1 for matching element\n- [ ] damage_multiplier() returns 1.0 for non-matching or no attunement\n- [ ] Registered as Resource in plugin\n\n## Required Tests\n\n- Test new() has no element\n- Test with_element() has correct element\n- Test set_element() changes element\n- Test clear() removes element\n- Test damage_multiplier with no attunement returns 1.0\n- Test damage_multiplier with matching element returns 1.1\n- Test damage_multiplier with non-matching element returns 1.0\n- Test each element as attunement with matching spell","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-01T21:06:07.808399+11:00","updated_at":"2026-01-01T22:32:40.822762+11:00","closed_at":"2026-01-01T22:32:40.822762+11:00","dependencies":[{"issue_id":"dt-survivor-vmx","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:06:12.676985+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-vmx","depends_on_id":"dt-survivor-g0j","type":"blocks","created_at":"2026-01-01T21:07:41.734125+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-vql","title":"Create Inventory Bag Overlay UI","description":"## Context\nPart of the spells system refactoring (epic: dt-survivor-jdd). The player needs an inventory screen to manage their collected spells. This overlay allows viewing all 30 inventory slots and swapping spells between bag and active slots.\n\n## Implementation Details\n\n### Files to Create\n- `src/ui/inventory_bag.rs` - New module for inventory overlay UI\n\n### UI Layout\n```\n+----------------------------------+\n|         INVENTORY (Bag)          |\n| +----+----+----+----+----+----+  |\n| |    |    |    |    |    |    |  |  (Row 1 of 5)\n| +----+----+----+----+----+----+  |\n| |    |    |    |    |    |    |  |  (Row 2 of 5)\n| +----+----+----+----+----+----+  |\n| ...                              |\n|                                  |\n| === ACTIVE SPELLS ===            |\n| +----+----+----+----+----+       |\n| | 1  | 2  | 3  | 4  | 5  |       |  (5 active slots)\n| +----+----+----+----+----+       |\n+----------------------------------+\n```\n\n### State Flow\n1. In `GameState::InGame`, press I key → transition to `GameState::InventoryOpen`\n2. Display full inventory overlay\n3. Click slot to select spell\n4. Click active slot to swap/equip selected spell\n5. Press I or Escape → return to `GameState::InGame`\n\n### ECS Components to Create\n```rust\n#[derive(Component)]\npub struct InventoryScreen;  // Root marker for cleanup\n\n#[derive(Component)]\npub struct InventorySlot {\n    pub index: usize,  // 0-29 for bag slots\n}\n\n#[derive(Component)]\npub struct InventoryOverlay;  // Dark background\n\n#[derive(Component)]\npub struct SelectedSpell;  // Marker for currently selected slot\n\n#[derive(Component)]\npub struct ActiveSlotDisplay {\n    pub index: usize,  // 0-4 for active spell slots\n}\n```\n\n### Systems to Implement\n```rust\n// OnEnter(GameState::InventoryOpen)\npub fn setup_inventory_ui(mut commands: Commands, inventory: Res\u003cSpellInventory\u003e, ...) { }\n\n// OnExit(GameState::InventoryOpen)\npub fn cleanup_inventory_ui(query: Query\u003cEntity, With\u003cInventoryScreen\u003e\u003e, mut commands: Commands) { }\n\n// Update, run_if(in_state(GameState::InventoryOpen))\npub fn handle_inventory_input(\n    keyboard: Res\u003cButtonInput\u003cKeyCode\u003e\u003e,\n    mut next_state: ResMut\u003cNextState\u003cGameState\u003e\u003e,\n) { }\n\n// Update, run_if(in_state(GameState::InventoryOpen))\npub fn update_slot_visuals(\n    interaction_query: Query\u003c(\u0026Interaction, \u0026InventorySlot), Changed\u003cInteraction\u003e\u003e,\n    mut commands: Commands,\n    selected_query: Query\u003cEntity, With\u003cSelectedSpell\u003e\u003e,\n) { }\n\n// Update, run_if(in_state(GameState::InventoryOpen))\npub fn handle_slot_swap(\n    interaction_query: Query\u003c(\u0026Interaction, \u0026ActiveSlotDisplay), Changed\u003cInteraction\u003e\u003e,\n    selected_query: Query\u003c\u0026InventorySlot, With\u003cSelectedSpell\u003e\u003e,\n    mut inventory: ResMut\u003cSpellInventory\u003e,\n    mut spell_list: ResMut\u003cSpellList\u003e,\n) { }\n```\n\n### Bevy UI Patterns\n- Use `NodeBundle` with `position_type: Absolute` for full-screen overlay\n- CSS Grid-like layout with flexbox for 6x5 slot grid\n- `Interaction` component for click detection\n- Visual highlight for selected slot using `BorderColor`\n- Show spell icon, element color tint, and level for occupied slots\n- Placeholder/empty texture for unoccupied slots\n\n### Keyboard Controls\n- `I` key: Toggle inventory (only from InGame)\n- `Escape`: Close inventory (return to InGame)\n\n## Acceptance Criteria\n- [ ] 6x5 grid (30 slots) renders correctly\n- [ ] Each slot shows spell icon or empty placeholder\n- [ ] Element color tints slot background\n- [ ] Spell level displayed in occupied slots\n- [ ] Active spells bar shows current 5 equipped spells\n- [ ] Clicking bag slot selects it (visual highlight)\n- [ ] Clicking active slot swaps with selected bag spell\n- [ ] I key opens inventory from InGame\n- [ ] Escape key closes inventory\n- [ ] All entities cleaned up on state exit\n\n## Required Automated Tests\n- Test grid renders correct number of slots (30 bag + 5 active = 35)\n- Test slot selection adds SelectedSpell marker\n- Test swap logic correctly modifies SpellInventory and SpellList\n- Test I key toggles GameState correctly\n- Test Escape key returns to InGame\n- Test cleanup removes all InventoryScreen entities","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-01T21:05:04.298965+11:00","updated_at":"2026-01-01T23:44:18.884261+11:00","closed_at":"2026-01-01T23:44:18.884261+11:00","dependencies":[{"issue_id":"dt-survivor-vql","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:05:10.414974+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-vxt","title":"Rename WeaponOrigin to SpellOrigin","description":"## Context\n\nPart of the spells system refactoring for dt-survivor. This renames the WeaponOrigin resource and related systems to use Spell terminology, maintaining consistency with the rest of the refactoring.\n\n## Implementation Details\n\n### File Location\n- Modify: src/whisper/resources.rs\n\n### Resource Rename\n```rust\n// Before\n#[derive(Resource)]\npub struct WeaponOrigin(pub Entity);\n\n// After\n#[derive(Resource)]\npub struct SpellOrigin(pub Entity);\n```\n\n### System Renames\n```rust\n// Before\nfn weapon_firing_system(...)\n\n// After\nfn spell_casting_system(...)\n```\n\n### Import Updates\nUpdate all files that reference:\n- WeaponOrigin -\u003e SpellOrigin\n- weapon_firing_system -\u003e spell_casting_system\n\n### Files to Update\n- src/whisper/resources.rs (rename)\n- src/whisper/systems.rs (rename system)\n- src/weapon/systems.rs (now src/spell/systems.rs)\n- src/pistol/systems.rs\n- src/laser/systems.rs\n- src/rocket_launcher/systems.rs\n- Any other files using these names\n\n## ECS Patterns\n\n- Follow resource naming conventions\n- Update system registration in plugins\n- Maintain existing functionality, only rename\n\n## Acceptance Criteria\n\n- [ ] WeaponOrigin renamed to SpellOrigin\n- [ ] weapon_firing_system renamed to spell_casting_system\n- [ ] All imports updated\n- [ ] All references updated\n- [ ] No remaining 'weapon' terminology in renamed areas\n- [ ] Existing functionality preserved\n- [ ] All tests pass after rename\n\n## Required Tests\n\n- Test SpellOrigin resource creation\n- Test SpellOrigin stores correct entity\n- Test spell_casting_system is registered\n- Verify existing weapon firing tests pass under new names","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-01T21:07:15.12059+11:00","updated_at":"2026-01-01T23:36:48.082949+11:00","closed_at":"2026-01-01T23:36:48.082949+11:00","dependencies":[{"issue_id":"dt-survivor-vxt","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:07:20.662326+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-vxt","depends_on_id":"dt-survivor-2pj","type":"blocks","created_at":"2026-01-01T21:07:51.855626+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-w84","title":"Implement Frozen Orb Spell (Frost)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Frozen Orb\n- **Element**: Frost\n- **Behavior**: A slow-moving orb that radiates freezing energy, damaging nearby enemies continuously as it passes. The orb pierces through enemies rather than stopping on collision, dealing damage-over-time to anything in its aura radius.\n\n## ECS Implementation\n\n### Components to Create\n- `FrozenOrb { damage_radius: f32, tick_timer: Timer, damage_per_tick: f32 }` - The orb entity with its damage aura\n- `FrozenOrbVelocity { direction: Vec2, speed: f32 }` - Slow movement component\n- `FrozenOrbHitTracker { hit_entities: HashMap\u003cEntity, Timer\u003e }` - Tracks cooldown per-enemy to prevent damage spam\n\n### Systems Needed\n- `spawn_frozen_orb` - Creates slow-moving orb with damage aura\n- `update_frozen_orb_movement` - Moves orb slowly forward\n- `frozen_orb_damage_aura` - Damages enemies within radius on tick timer\n- `update_frozen_orb_hit_tracker` - Manages per-enemy damage cooldowns\n- `cleanup_frozen_orb` - Despawns orb after max duration or range\n\n### File Location\n`src/spells/frost/frozen_orb.rs`\n\n## Visual Design\n- Large spherical orb of swirling ice energy in ice blue/cyan\n- Constant particle emission of ice crystals radiating outward\n- Visible cold \"aura\" effect around orb showing damage radius\n- Enemies in range get periodic frost hit effect\n\n## Acceptance Criteria\n- [ ] Frozen Orb spawns and moves slowly in target direction\n- [ ] Orb has visible damage radius aura\n- [ ] Enemies within damage radius take periodic damage\n- [ ] Damage ticks at configured interval (not every frame)\n- [ ] Orb pierces through enemies (does not despawn on collision)\n- [ ] Per-enemy damage cooldown prevents instant multi-hit\n- [ ] Orb despawns after max duration or travel distance\n\n## Required Tests\n- [ ] Test frozen_orb spawns with correct components\n- [ ] Test orb moves at slow configured speed in correct direction\n- [ ] Test enemies within damage_radius take damage\n- [ ] Test damage only occurs on tick_timer intervals\n- [ ] Test orb continues moving after hitting enemy (piercing)\n- [ ] Test same enemy cannot be damaged faster than cooldown allows\n- [ ] Test orb despawns after max duration\n- [ ] Test multiple enemies in radius all take damage","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:11:44.103159+11:00","updated_at":"2026-01-02T02:56:52.735357+11:00","closed_at":"2026-01-02T02:56:52.735357+11:00","dependencies":[{"issue_id":"dt-survivor-w84","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:11:49.485907+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-wfa","title":"Implement Beacon Spell (Light)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Beacon\n- **Element**: Light\n- **Behavior**: Light source that draws enemies while damaging them. Creates a bright beacon at a target location that acts as a taunt, attracting enemies toward it. Enemies near the beacon take continuous damage.\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct Beacon {\n    pub position: Vec2,\n    pub attract_radius: f32,\n    pub damage_radius: f32,\n    pub damage_per_tick: f32,\n    pub tick_timer: Timer,\n    pub duration: Timer,\n}\n\n#[derive(Component)]\npub struct BeaconAttracted {\n    pub beacon_entity: Entity,\n}\n```\n\n### Systems\n- `spawn_beacon` - Creates beacon entity at target location\n- `update_beacon_timers` - Ticks damage and duration timers\n- `attract_enemies_to_beacon` - Overrides enemy AI to move toward beacon\n- `apply_beacon_damage` - Damages enemies within damage radius\n- `update_beacon_duration` - Despawns beacon when duration expires\n- `remove_beacon_attraction` - Clears attraction when beacon despawns\n- `cleanup_beacons` - Removes all beacons on spell deactivation\n\n### File Location\n`src/spells/light/beacon.rs`\n\n## Visual Design\n- Tall pillar of radiant white/gold light\n- Pulsing glow that intensifies on damage ticks\n- Particle effects spiraling upward\n- Enemies attracted show subtle trail toward beacon\n- Ground beneath beacon has glowing rune/circle\n\n## Acceptance Criteria\n- [ ] Beacon spawns at designated target location\n- [ ] Enemies within attract_radius are pulled toward beacon\n- [ ] Attracted enemies have their movement overridden\n- [ ] Enemies within damage_radius take periodic damage\n- [ ] Damage ticks at configurable intervals\n- [ ] Beacon expires after duration\n- [ ] Multiple beacons can exist (attract to nearest or specific logic)\n- [ ] Visual clearly indicates beacon location and radii\n\n## Required Tests\n- [ ] Test beacon spawns at correct position\n- [ ] Test enemy within attract_radius gains BeaconAttracted component\n- [ ] Test attracted enemy moves toward beacon position\n- [ ] Test enemy outside attract_radius not affected\n- [ ] Test enemy within damage_radius takes damage on tick\n- [ ] Test damage tick timer resets correctly\n- [ ] Test beacon duration timer counts down\n- [ ] Test beacon despawns and clears attractions on expire","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:18:09.000427+11:00","updated_at":"2026-01-02T08:40:47.210287+11:00","closed_at":"2026-01-02T08:40:47.210287+11:00","dependencies":[{"issue_id":"dt-survivor-wfa","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:18:14.518879+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-wfv","title":"Update Spell Pickup Logic","description":"## Context\n\nPart of the spells system refactoring for dt-survivor. This updates the loot pickup system to handle spells with the new SpellList and InventoryBag resources, including level-up logic for duplicate pickups.\n\n## Implementation Details\n\n### File Location\n- Modify: src/loot/systems.rs\n- Modify: src/loot/components.rs (if ItemData exists there)\n\n### ItemData Rename\n```rust\n// Before\npub enum ItemData {\n    Weapon(WeaponType),\n    XpOrb(u32),\n    HealthPickup(f32),\n}\n\n// After\npub enum ItemData {\n    Spell(SpellType),  // Renamed from Weapon\n    XpOrb(u32),\n    HealthPickup(f32),\n}\n```\n\n### Pickup Priority Logic\nWhen player picks up a spell, check in this order:\n\n1. **SpellList has same spell type** -\u003e Level up that spell\n2. **InventoryBag has same spell type** -\u003e Level up that spell in bag\n3. **SpellList has empty slot** -\u003e Equip to empty slot\n4. **InventoryBag has empty slot** -\u003e Add to bag\n5. **Both full** -\u003e Spell is lost (or future: prompt to swap)\n\n### Spell Pickup System\n```rust\nfn handle_spell_pickup(\n    mut spell_list: ResMut\u003cSpellList\u003e,\n    mut bag: ResMut\u003cInventoryBag\u003e,\n    spell_type: SpellType,\n) {\n    // Check SpellList for same spell (level up)\n    if let Some(slot) = spell_list.find_spell_slot(spell_type) {\n        if let Some(spell) = spell_list.get_spell_mut(slot) {\n            spell.level_up();\n        }\n        return;\n    }\n\n    // Check bag for same spell (level up)\n    if let Some(slot) = bag.find_spell(spell_type) {\n        if let Some(spell) = bag.get_spell_mut(slot) {\n            spell.level_up();\n        }\n        return;\n    }\n\n    // Try to equip to SpellList\n    let new_spell = Spell::new(spell_type);\n    if spell_list.equip(new_spell.clone()).is_some() {\n        return;\n    }\n\n    // Try to add to bag\n    bag.add(new_spell);\n}\n```\n\n### Spell Component Level Up\nThe Spell component needs a level field and level_up() method (may need to add if not present).\n\n## ECS Patterns\n\n- Follow event-driven pickup pattern\n- Use existing PickupEvent or similar\n- Update systems in GameSet::Effects or appropriate set\n\n## Acceptance Criteria\n\n- [ ] ItemData::Weapon renamed to ItemData::Spell\n- [ ] Pickup checks SpellList for existing spell first\n- [ ] Pickup levels up spell in SpellList if found\n- [ ] Pickup checks bag for existing spell second\n- [ ] Pickup levels up spell in bag if found\n- [ ] Pickup equips to SpellList if empty slot\n- [ ] Pickup adds to bag if SpellList full\n- [ ] All pickup scenarios handled gracefully\n\n## Required Tests\n\n- Test pickup to empty SpellList (slot 0)\n- Test pickup levels up existing spell in SpellList\n- Test pickup levels up existing spell in bag\n- Test pickup equips to SpellList when bag has different spell\n- Test pickup adds to bag when SpellList full\n- Test pickup when both SpellList and bag are full\n- Test ItemData::Spell variant works correctly","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-01T21:06:52.85011+11:00","updated_at":"2026-01-02T00:17:14.603626+11:00","closed_at":"2026-01-02T00:17:14.603626+11:00","dependencies":[{"issue_id":"dt-survivor-wfv","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:07:01.254068+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-wfv","depends_on_id":"dt-survivor-7ju","type":"blocks","created_at":"2026-01-01T21:07:47.3428+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-wfv","depends_on_id":"dt-survivor-3ji","type":"blocks","created_at":"2026-01-01T21:07:47.44141+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-wfv","depends_on_id":"dt-survivor-0rl","type":"blocks","created_at":"2026-01-01T21:07:47.542761+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-whr","title":"Create combat systems","description":"Create src/combat/systems.rs with: apply_damage (reads DamageEvent, updates Health, fires DeathEvent), check_death (monitors Health \u003c= 0), handle_invincibility (ticks invincibility timers). Include tests.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T17:40:28.720944+11:00","updated_at":"2025-12-25T18:04:44.3668+11:00","closed_at":"2025-12-25T18:04:44.3668+11:00","dependencies":[{"issue_id":"dt-survivor-whr","depends_on_id":"dt-survivor-y2f","type":"blocks","created_at":"2025-12-25T17:40:45.203649+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-whr","depends_on_id":"dt-survivor-1wg","type":"blocks","created_at":"2025-12-25T17:40:45.294286+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-whr","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:40:45.856432+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-wvj","title":"Implement Enemy Level system with HP and damage scaling","description":"Add Level component to enemies, with HP and damage that scale based on their level. Enemy levels are influenced by the current game level.\n\n## Context\nCurrent enemy spawning is in src/enemies/systems.rs. Enemies currently have:\n- speed: 1.7 units/sec\n- strength: 10.0 (damage to player)\n- Health: 10.0 HP\n\nWith this change, enemies will have levels 1-5, and their stats will scale accordingly.\n\n## Implementation\n\n### Updated Enemy Component (src/enemies/components.rs)\n```rust\n/// Configuration for enemy stat scaling\npub struct EnemyScaling {\n    pub base_health: f32,\n    pub health_per_level: f32,\n    pub base_damage: f32,\n    pub damage_per_level: f32,\n}\n\nimpl Default for EnemyScaling {\n    fn default() -\u003e Self {\n        Self {\n            base_health: 10.0,\n            health_per_level: 15.0,  // Level 5 = 10 + (4 * 15) = 70 HP\n            base_damage: 10.0,\n            damage_per_level: 5.0,   // Level 5 = 10 + (4 * 5) = 30 damage\n        }\n    }\n}\n\nimpl EnemyScaling {\n    pub fn health_for_level(\u0026self, level: u8) -\u003e f32 {\n        self.base_health + (level.saturating_sub(1) as f32 * self.health_per_level)\n    }\n\n    pub fn damage_for_level(\u0026self, level: u8) -\u003e f32 {\n        self.base_damage + (level.saturating_sub(1) as f32 * self.damage_per_level)\n    }\n}\n```\n\n### Enemy Spawning Update (src/enemies/systems.rs)\n```rust\n/// Determine enemy level based on game level with weighted random selection\nfn select_enemy_level(game_level: u32, rng: \u0026mut impl Rng) -\u003e u8 {\n    // Base spawn chances (percentages)\n    // Game level increases chances of higher-tier enemies\n    let level_bonus = (game_level.saturating_sub(1) as f32 * 5.0).min(40.0);\n    \n    let chances = [\n        (1, 100.0 - level_bonus),           // Level 1: starts at 100%, decreases\n        (2, 15.0 + level_bonus * 0.5),      // Level 2: starts at 15%\n        (3, 8.0 + level_bonus * 0.3),       // Level 3: starts at 8%\n        (4, 4.0 + level_bonus * 0.15),      // Level 4: starts at 4%\n        (5, 2.0 + level_bonus * 0.05),      // Level 5: starts at 2%\n    ];\n    \n    let total: f32 = chances.iter().map(|(_, c)| c).sum();\n    let roll = rng.gen_range(0.0..total);\n    \n    let mut cumulative = 0.0;\n    for (level, chance) in chances {\n        cumulative += chance;\n        if roll \u003c cumulative {\n            return level;\n        }\n    }\n    1 // Fallback\n}\n\npub fn spawn_enemies_system(\n    mut commands: Commands,\n    game_meshes: Res\u003cGameMeshes\u003e,\n    // ... existing params ...\n    game_level: Res\u003cGameLevel\u003e,\n) {\n    // ... existing spawn logic ...\n    \n    let enemy_level = select_enemy_level(game_level.level, \u0026mut rng);\n    let scaling = EnemyScaling::default();\n    \n    commands.spawn((\n        Enemy {\n            speed: 1.7,\n            strength: scaling.damage_for_level(enemy_level),\n        },\n        Health::new(scaling.health_for_level(enemy_level)),\n        Level::new(enemy_level),\n        CheckDeath,\n        // ... mesh and transform ...\n    ));\n}\n```\n\n### Spawn Rate Adjustment\nHigher level enemies spawn less frequently. The select_enemy_level function handles this via weighted probabilities.\n\n## Stat Scaling Table\n| Level | HP | Damage | Base Spawn % | At Game Lvl 5 |\n|-------|-----|--------|--------------|---------------|\n| 1     | 10  | 10     | 100%         | 80%           |\n| 2     | 25  | 15     | 15%          | 25%           |\n| 3     | 40  | 20     | 8%           | 14%           |\n| 4     | 55  | 25     | 4%           | 7%            |\n| 5     | 70  | 30     | 2%           | 3%            |\n\n## ECS Pattern\n```rust\n// Entities with Level component can be queried together\nfn process_leveled_enemies(\n    query: Query\u003c(Entity, \u0026Level, \u0026Health, \u0026Enemy)\u003e,\n) {\n    for (entity, level, health, enemy) in query.iter() {\n        // Access level.value() for logic\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] Enemies spawn with Level component (1-5)\n- [ ] Enemy HP scales with level (10, 25, 40, 55, 70)\n- [ ] Enemy damage scales with level (10, 15, 20, 25, 30)\n- [ ] Higher game levels increase chance of higher level enemies\n- [ ] Level 1 enemies are most common, level 5 rarest\n- [ ] Unit tests for EnemyScaling calculations\n- [ ] Unit tests for select_enemy_level probability distribution\n- [ ] Integration test verifying enemy spawns with correct stats\n\n## Test Requirements\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn enemy_scaling_calculates_correct_health() {\n        let scaling = EnemyScaling::default();\n        assert_eq!(scaling.health_for_level(1), 10.0);\n        assert_eq!(scaling.health_for_level(2), 25.0);\n        assert_eq!(scaling.health_for_level(5), 70.0);\n    }\n\n    #[test]\n    fn enemy_scaling_calculates_correct_damage() {\n        let scaling = EnemyScaling::default();\n        assert_eq!(scaling.damage_for_level(1), 10.0);\n        assert_eq!(scaling.damage_for_level(5), 30.0);\n    }\n\n    #[test]\n    fn select_enemy_level_returns_valid_level() {\n        let mut rng = rand::thread_rng();\n        for _ in 0..100 {\n            let level = select_enemy_level(1, \u0026mut rng);\n            assert!(level \u003e= 1 \u0026\u0026 level \u003c= 5);\n        }\n    }\n}\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-30T09:41:30.65505+11:00","updated_at":"2025-12-30T10:53:06.480485+11:00","closed_at":"2025-12-30T10:53:06.480485+11:00","dependencies":[{"issue_id":"dt-survivor-wvj","depends_on_id":"dt-survivor-3l7","type":"blocks","created_at":"2025-12-30T09:45:06.88562+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-wvj","depends_on_id":"dt-survivor-ahu","type":"blocks","created_at":"2025-12-30T09:45:06.961203+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-wvj","depends_on_id":"dt-survivor-aiy","type":"parent-child","created_at":"2025-12-30T09:45:19.128273+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-xir","title":"Implement Acid Rain Spell (Poison)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Acid Rain\n- **Element**: Poison\n- **Behavior**: Toxic droplets fall over a wide area. Large target area with random droplets falling from above. Each droplet damages and poisons enemies it hits.\n\n## ECS Implementation\n\n### Components\n- `AcidRainZone { center: Vec2, radius: f32, duration: Timer, droplet_rate: f32, droplet_timer: Timer }` - The area where acid rain falls\n- `AcidDroplet { damage: f32, poison_duration: f32, poison_damage: f32 }` - Individual falling droplets\n\n### Systems\n- `spawn_acid_rain_zone` - Creates rain zone at target location\n- `acid_rain_spawn_droplets` - Spawns droplets at random positions within zone\n- `acid_droplet_fall` - Handles droplet falling animation/movement\n- `acid_droplet_impact` - Damages and poisons enemies on droplet hit\n- `cleanup_acid_rain` - Despawns zone and droplets when duration expires\n\n### File Location\n`src/spells/poison/acid_rain.rs`\n\n## Visual Design\n- Zone indicator: Faint green circular boundary on ground\n- Droplets: Green/yellow glowing drops falling from above\n- Impact: Small splash effect with poison particles\n- Poison element uses green/toxic colors, drip particle effects\n\n## Acceptance Criteria\n- [ ] Rain zone spawns at target location with large radius\n- [ ] Droplets spawn randomly within zone at configured rate\n- [ ] Droplets fall from above and impact ground level\n- [ ] Enemies hit by droplets take direct damage\n- [ ] Enemies hit by droplets receive poison DOT\n- [ ] Zone and all droplets despawn after duration\n- [ ] Droplet density is configurable\n\n## Required Tests\n- `test_acid_rain_zone_spawns` - Verify zone creation\n- `test_acid_rain_spawns_droplets` - Verify droplet spawning\n- `test_acid_rain_droplet_random_positions` - Verify random distribution\n- `test_acid_droplet_damages_enemy` - Verify direct damage on hit\n- `test_acid_droplet_applies_poison` - Verify poison DOT application\n- `test_acid_rain_respects_radius` - Verify droplets stay in zone\n- `test_acid_rain_despawns_after_duration` - Verify cleanup\n- `test_acid_rain_droplet_rate` - Verify spawn timing","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:13:07.622969+11:00","updated_at":"2026-01-02T04:57:15.71236+11:00","closed_at":"2026-01-02T04:57:15.71236+11:00","dependencies":[{"issue_id":"dt-survivor-xir","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:13:13.674872+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-xp9","title":"Create CombatPlugin","description":"Create src/combat/plugin.rs with CombatPlugin that registers events, systems with run_if(in_state(GameState::InGame)). Add to main.rs plugin list.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T17:40:28.836415+11:00","updated_at":"2025-12-25T18:09:47.843379+11:00","closed_at":"2025-12-25T18:09:47.843379+11:00","dependencies":[{"issue_id":"dt-survivor-xp9","depends_on_id":"dt-survivor-whr","type":"blocks","created_at":"2025-12-25T17:40:45.37134+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-xp9","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:40:45.93232+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-y2f","title":"Create Health, Damage, Hitbox components","description":"Create reusable combat components in src/combat/components.rs: Health { current: f32, max: f32 } with take_damage/is_dead methods, Damage(f32) for projectiles, Hitbox(f32) for collision radius, Invincibility(Timer) for damage immunity frames. Include unit tests.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T17:40:28.501006+11:00","updated_at":"2025-12-25T17:57:55.248747+11:00","closed_at":"2025-12-25T17:57:55.248747+11:00","dependencies":[{"issue_id":"dt-survivor-y2f","depends_on_id":"dt-survivor-1a7","type":"blocks","created_at":"2025-12-25T17:40:45.036797+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-y2f","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:40:45.696396+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-y3m","title":"Implement Chain Lightning Spell (Lightning)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Chain Lightning\n- **Element**: Lightning\n- **Behavior**: Lightning arcs between multiple nearby enemies. Hits initial target, then jumps to 3-5 nearby enemies. Damage reduces with each jump (80% of previous).\n\n## ECS Implementation\n\n### Components\n```rust\n#[derive(Component)]\npub struct ChainLightningBolt {\n    pub jumps_remaining: u8,\n    pub current_damage: f32,\n    pub jump_range: f32,\n    pub damage_decay: f32,  // 0.8 = 80% of previous\n}\n\n#[derive(Component)]\npub struct ChainLightningVisual {\n    pub segments: Vec\u003c(Vec3, Vec3)\u003e,  // Start/end pairs for visual arcs\n}\n```\n\n### Systems\n- `spawn_chain_lightning` - Create initial bolt toward target\n- `chain_lightning_jump` - Find next target and create arc segment\n- `chain_lightning_collision` - Detect hits and trigger jumps\n- `chain_lightning_visual` - Render electric arc effects\n- `chain_lightning_cleanup` - Despawn when no jumps remaining\n\n### File Location\n`src/spells/lightning/chain_lightning.rs`\n\n## Visual Design\n- Yellow/electric blue primary colors\n- Crackling jagged line between targets\n- Bright flash on each hit\n- Secondary sparks along arc path\n- Each jump slightly dimmer than previous\n\n## Acceptance Criteria\n- [ ] Initial bolt fires toward nearest enemy or cursor direction\n- [ ] On hit, automatically finds next nearest enemy within jump_range\n- [ ] Jumps up to 3-5 times (configurable)\n- [ ] Each jump deals 80% of previous hit's damage\n- [ ] Cannot jump to already-hit enemies in same chain\n- [ ] Visual arc connects all hit targets\n- [ ] Proper cleanup when chain ends or no valid targets\n\n## Required Tests\n- [ ] Test initial bolt spawns with correct components\n- [ ] Test jump targeting finds nearest unvisited enemy\n- [ ] Test damage decay applies correctly per jump (100 -\u003e 80 -\u003e 64 -\u003e 51.2)\n- [ ] Test chain stops when no enemies in range\n- [ ] Test chain stops when jumps_remaining reaches 0\n- [ ] Test already-hit enemies are excluded from targeting\n- [ ] Test visual segments update with each jump\n- [ ] Test cleanup removes all chain components","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:10:25.532668+11:00","updated_at":"2026-01-02T00:55:17.983446+11:00","closed_at":"2026-01-02T00:55:17.983446+11:00","dependencies":[{"issue_id":"dt-survivor-y3m","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:10:30.951954+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-z7l","title":"Update collision detection systems to use XZ plane","description":"# Task: Collision Detection XZ Conversion\n\n## Context\nDT Survivor is migrating from 2D to 3D. Collision detection between entities uses `.truncate()` to get XY positions for distance checks. All collision systems must be updated to use XZ coordinates instead.\n\n## Current Implementation\n**Player-Enemy Collision** (`src/game/systems.rs`):\n```rust\nlet player_pos = player_transform.translation.truncate();\nlet enemy_pos = enemy_transform.translation.truncate();\nlet distance = player_pos.distance(enemy_pos);\n```\n\n**Bullet-Enemy Collision** (`src/bullets/systems.rs`):\nSimilar pattern using `.truncate()` for XY extraction.\n\n**Loot Pickup** (`src/loot/systems.rs`):\nUses `.truncate()` for pickup radius checks.\n\n**Laser Hit Detection** (`src/laser/systems.rs`):\nLine-circle intersection on XY plane.\n\n## Required Changes\n\n### 1. Create Position Extraction Helper\nUse the `from_xz` function from movement module or create locally:\n```rust\nfn get_xz(translation: Vec3) -\u003e Vec2 {\n    Vec2::new(translation.x, translation.z)\n}\n```\n\n### 2. Update Player-Enemy Collision\n```rust\n// Before\nlet player_pos = player_transform.translation.truncate();\nlet enemy_pos = enemy_transform.translation.truncate();\n\n// After\nlet player_pos = Vec2::new(player_transform.translation.x, player_transform.translation.z);\nlet enemy_pos = Vec2::new(enemy_transform.translation.x, enemy_transform.translation.z);\n```\n\n### 3. Update Bullet-Enemy Collision\n```rust\nfn check_bullet_enemy_collision(\n    bullet_query: Query\u003c(Entity, \u0026Transform), With\u003cBullet\u003e\u003e,\n    enemy_query: Query\u003c(Entity, \u0026Transform), With\u003cEnemy\u003e\u003e,\n    // ...\n) {\n    for (bullet_entity, bullet_transform) in bullet_query.iter() {\n        let bullet_pos = Vec2::new(\n            bullet_transform.translation.x,\n            bullet_transform.translation.z,\n        );\n        \n        for (enemy_entity, enemy_transform) in enemy_query.iter() {\n            let enemy_pos = Vec2::new(\n                enemy_transform.translation.x,\n                enemy_transform.translation.z,\n            );\n            \n            if bullet_pos.distance(enemy_pos) \u003c COLLISION_RADIUS {\n                // Handle collision\n            }\n        }\n    }\n}\n```\n\n### 4. Update Loot Pickup Detection\n```rust\nlet loot_pos = Vec2::new(loot_transform.translation.x, loot_transform.translation.z);\nlet player_pos = Vec2::new(player_transform.translation.x, player_transform.translation.z);\nlet distance = loot_pos.distance(player_pos);\nif distance \u003c player.pickup_radius {\n    // Pickup\n}\n```\n\n### 5. Update Laser Hit Detection\nLaser line segment and enemy circle intersection on XZ plane:\n```rust\n// Laser start and end points\nlet start = Vec2::new(laser_start.x, laser_start.z);\nlet end = Vec2::new(laser_end.x, laser_end.z);\nlet enemy_center = Vec2::new(enemy_pos.x, enemy_pos.z);\n// Line-circle intersection math remains the same\n```\n\n### 6. Update Rocket/Explosion Collision\nSimilar XZ extraction for rocket impacts and explosion radius checks.\n\n## Files to Update\n- `src/game/systems.rs` - Player-enemy collision\n- `src/bullets/systems.rs` - Bullet-enemy collision\n- `src/loot/systems.rs` - Pickup detection\n- `src/laser/systems.rs` - Laser hit detection\n- `src/rocket_launcher/systems.rs` - Rocket/explosion collision\n\n## Testing Requirements\n- Unit test: Player-enemy collision detects correctly on XZ\n- Unit test: Bullet-enemy collision works on XZ plane\n- Unit test: Loot pickup detects within radius on XZ\n- Unit test: Laser hit detection works on XZ plane\n- Unit test: Explosion radius checks work on XZ\n- Unit test: Distance calculations ignore Y axis\n- Update all existing collision tests\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] All `.truncate()` calls replaced with XZ extraction\n- [ ] Player-enemy collision works in 3D\n- [ ] Bullet-enemy collision works in 3D\n- [ ] Loot pickup detection works in 3D\n- [ ] Laser hit detection works in 3D\n- [ ] Explosion damage works in 3D\n- [ ] Collision radii unchanged\n- [ ] All collision tests updated and passing\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:49:19.194458+11:00","updated_at":"2025-12-28T10:35:37.622788+11:00","closed_at":"2025-12-28T10:35:37.622788+11:00","dependencies":[{"issue_id":"dt-survivor-z7l","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.767041+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-z7l","depends_on_id":"dt-survivor-4i1","type":"blocks","created_at":"2025-12-28T09:50:38.199674+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-z7l","depends_on_id":"dt-survivor-0ql","type":"blocks","created_at":"2025-12-28T09:50:38.268668+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-z7l","depends_on_id":"dt-survivor-a2s","type":"blocks","created_at":"2025-12-28T09:50:38.335113+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-z7l","depends_on_id":"dt-survivor-b67","type":"blocks","created_at":"2025-12-28T09:50:38.400672+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-z9s","title":"Implement Shatter Spell (Frost)","description":"## Context\nPart of the Spells System Refactoring (dt-survivor-jdd). Converting weapons to an element-based spell system with 64 unique spells, 5 active slots, and 30-slot inventory bag.\n\n## Spell Details\n- **Name**: Shatter\n- **Element**: Frost\n- **Behavior**: A projectile that deals bonus damage to slowed or frozen enemies. Synergizes with other Frost spells - deals 2x damage to enemies with SlowedDebuff and 3x damage to enemies with FrozenStatus. Encourages building frost spell combinations.\n\n## ECS Implementation\n\n### Components to Create\n- `ShatterProjectile { base_damage: f32, slow_multiplier: f32, frozen_multiplier: f32 }` - The projectile with damage modifiers\n- Reuses existing: `SlowedDebuff`, `FrozenStatus` (from other frost spells)\n\n### Systems Needed\n- `spawn_shatter` - Creates projectile toward target direction\n- `update_shatter_movement` - Moves projectile at normal speed\n- `shatter_enemy_collision` - Checks target debuffs and calculates bonus damage\n- `calculate_shatter_damage` - Applies multipliers based on enemy status\n- `cleanup_shatter` - Despawns after collision or max range\n\n### File Location\n`src/spells/frost/shatter.rs`\n\n## Visual Design\n- Jagged, crystalline ice projectile in ice blue/cyan\n- Cracked/fractured ice texture suggesting it will shatter on impact\n- On-hit: massive ice shatter explosion effect\n- Bonus damage hit shows larger/more dramatic shatter particles\n\n## Acceptance Criteria\n- [ ] Shatter fires as a projectile toward target direction\n- [ ] Base damage is dealt to normal enemies\n- [ ] 2x damage multiplier applied to enemies with SlowedDebuff\n- [ ] 3x damage multiplier applied to enemies with FrozenStatus\n- [ ] Frozen multiplier takes priority over Slowed (not additive)\n- [ ] Projectile despawns on hit or at max range\n- [ ] Visual feedback differs based on bonus damage applied\n\n## Required Tests\n- [ ] Test shatter spawns with correct base_damage and multipliers\n- [ ] Test shatter moves toward target direction correctly\n- [ ] Test enemy without debuffs takes base damage\n- [ ] Test enemy with SlowedDebuff takes 2x damage\n- [ ] Test enemy with FrozenStatus takes 3x damage\n- [ ] Test enemy with both debuffs takes 3x damage (frozen priority)\n- [ ] Test shatter despawns on enemy collision\n- [ ] Test shatter despawns at max range if no collision","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T21:13:46.410013+11:00","updated_at":"2026-01-02T05:11:01.601093+11:00","closed_at":"2026-01-02T05:11:01.601093+11:00","dependencies":[{"issue_id":"dt-survivor-z9s","depends_on_id":"dt-survivor-jdd","type":"parent-child","created_at":"2026-01-01T21:13:52.437686+11:00","created_by":"daemon"}]}
