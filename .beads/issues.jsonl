{"id":"dt-survivor-0as","title":"Track per-level statistics (time, kills, XP)","description":"Track gameplay statistics for each game level to display on the level complete screen.\n\n## Context\nThe GameLevel resource in dt-survivor-ahu tracks total kills and kills_this_level. This task adds comprehensive per-level statistics tracking including time taken and XP gained.\n\n## Implementation\n\n### Resource Definition (src/game/resources.rs)\n```rust\n/// Statistics for the current level\n#[derive(Resource, Debug, Default)]\npub struct LevelStats {\n    /// Time elapsed in current level (seconds)\n    pub time_elapsed: f32,\n    /// Enemies killed in current level\n    pub enemies_killed: u32,\n    /// XP gained in current level\n    pub xp_gained: u32,\n    /// Timestamp when level started\n    pub level_start_time: f32,\n}\n\nimpl LevelStats {\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Reset stats for a new level\n    pub fn reset(\u0026mut self, current_time: f32) {\n        self.time_elapsed = 0.0;\n        self.enemies_killed = 0;\n        self.xp_gained = 0;\n        self.level_start_time = current_time;\n    }\n\n    /// Record an enemy kill\n    pub fn record_kill(\u0026mut self) {\n        self.enemies_killed += 1;\n    }\n\n    /// Record XP gained\n    pub fn record_xp(\u0026mut self, amount: u32) {\n        self.xp_gained += amount;\n    }\n\n    /// Update elapsed time\n    pub fn update_time(\u0026mut self, current_time: f32) {\n        self.time_elapsed = current_time - self.level_start_time;\n    }\n\n    /// Format time as MM:SS\n    pub fn formatted_time(\u0026self) -\u003e String {\n        let minutes = (self.time_elapsed / 60.0) as u32;\n        let seconds = (self.time_elapsed % 60.0) as u32;\n        format!(\"{:02}:{:02}\", minutes, seconds)\n    }\n}\n```\n\n### System Implementation (src/game/systems.rs)\n```rust\n/// Update level time tracking\npub fn update_level_time_system(\n    time: Res\u003cTime\u003e,\n    mut level_stats: ResMut\u003cLevelStats\u003e,\n) {\n    level_stats.time_elapsed += time.delta_secs();\n}\n\n/// Track enemy kills for level stats\npub fn track_level_kills_system(\n    mut death_events: MessageReader\u003cEnemyDeathEvent\u003e,\n    mut level_stats: ResMut\u003cLevelStats\u003e,\n) {\n    for _ in death_events.read() {\n        level_stats.record_kill();\n    }\n}\n\n/// Track XP gained for level stats\npub fn track_level_xp_system(\n    mut effect_events: MessageReader\u003cItemEffectEvent\u003e,\n    orb_query: Query\u003c\u0026ExperienceOrb\u003e,\n    mut level_stats: ResMut\u003cLevelStats\u003e,\n) {\n    for event in effect_events.read() {\n        if let ItemData::Experience = event.item_data {\n            if let Ok(orb) = orb_query.get(event.source_entity) {\n                level_stats.record_xp(orb.value);\n            }\n        }\n    }\n}\n\n/// Reset level stats when starting a new level\npub fn reset_level_stats_system(\n    mut level_stats: ResMut\u003cLevelStats\u003e,\n    time: Res\u003cTime\u003e,\n) {\n    level_stats.reset(time.elapsed_secs());\n}\n```\n\n### Plugin Registration (src/game/plugin.rs)\n```rust\napp\n    .init_resource::\u003cLevelStats\u003e()\n    .add_systems(OnEnter(GameState::InGame), reset_level_stats_system)\n    .add_systems(\n        Update,\n        (\n            update_level_time_system,\n            track_level_kills_system,\n            track_level_xp_system,\n        )\n            .in_set(GameSet::Effects)\n            .run_if(in_state(GameState::InGame)),\n    );\n```\n\n## ECS Pattern\n```rust\n// Query level stats for display\nfn display_stats(level_stats: Res\u003cLevelStats\u003e) {\n    println!(\"Time: {}\", level_stats.formatted_time());\n    println!(\"Kills: {}\", level_stats.enemies_killed);\n    println!(\"XP: {}\", level_stats.xp_gained);\n}\n```\n\n## Acceptance Criteria\n- [ ] LevelStats resource tracks time_elapsed, enemies_killed, xp_gained\n- [ ] Time updates every frame during InGame state\n- [ ] Kills increment on EnemyDeathEvent\n- [ ] XP increments on experience orb collection\n- [ ] Stats reset when entering new level\n- [ ] formatted_time() returns MM:SS format\n- [ ] Unit tests for LevelStats methods\n- [ ] Unit tests for reset behavior\n\n## Test Requirements\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn level_stats_starts_at_zero() {\n        let stats = LevelStats::new();\n        assert_eq!(stats.time_elapsed, 0.0);\n        assert_eq!(stats.enemies_killed, 0);\n        assert_eq!(stats.xp_gained, 0);\n    }\n\n    #[test]\n    fn level_stats_records_kills() {\n        let mut stats = LevelStats::new();\n        stats.record_kill();\n        stats.record_kill();\n        assert_eq!(stats.enemies_killed, 2);\n    }\n\n    #[test]\n    fn level_stats_records_xp() {\n        let mut stats = LevelStats::new();\n        stats.record_xp(50);\n        stats.record_xp(25);\n        assert_eq!(stats.xp_gained, 75);\n    }\n\n    #[test]\n    fn level_stats_formats_time_correctly() {\n        let mut stats = LevelStats::new();\n        stats.time_elapsed = 125.0; // 2:05\n        assert_eq!(stats.formatted_time(), \"02:05\");\n    }\n\n    #[test]\n    fn level_stats_resets_correctly() {\n        let mut stats = LevelStats::new();\n        stats.enemies_killed = 10;\n        stats.xp_gained = 500;\n        stats.time_elapsed = 60.0;\n        stats.reset(100.0);\n        assert_eq!(stats.enemies_killed, 0);\n        assert_eq!(stats.xp_gained, 0);\n        assert_eq!(stats.time_elapsed, 0.0);\n        assert_eq!(stats.level_start_time, 100.0);\n    }\n}\n```","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-30T10:34:05.337308+11:00","updated_at":"2025-12-30T10:34:05.337308+11:00","dependencies":[{"issue_id":"dt-survivor-0as","depends_on_id":"dt-survivor-aiy","type":"blocks","created_at":"2025-12-30T10:35:04.69698+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-0as","depends_on_id":"dt-survivor-ahu","type":"blocks","created_at":"2025-12-30T10:35:04.772049+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-0ql","title":"Convert player and rock spawning from Sprite to Mesh3d cubes","description":"# Task: Player and Rock 3D Spawning\n\n## Context\nDT Survivor is migrating from 2D to 3D. The player and decorative rocks currently use `Sprite::from_color()` and need to be converted to 3D cube meshes. This task depends on GameMeshes/GameMaterials resources being available.\n\n## Current Implementation\n**Player** (`src/game/systems.rs:43-56`):\n```rust\ncommands.spawn((\n    Sprite::from_color(Color::srgb(0.0, 1.0, 0.0), Vec2::new(20.0, 20.0)),\n    Transform::from_translation(Vec3::new(0.0, 0.0, 1.0)),\n    Player { speed: 200.0, regen_rate: 1.0, pickup_radius: 50.0 },\n    Health::new(100.0),\n    PlayerExperience { current: 0, level: 1 },\n));\n```\n\n**Rocks** (`src/game/systems.rs:60-68`):\n```rust\ncommands.spawn((\n    Sprite::from_color(Color::srgb(0.5, 0.5, 0.5), Vec2::new(size, size)),\n    Transform::from_translation(Vec3::new(x, y, 0.0)),\n    Rock,\n));\n```\n\n## Required Changes\n\n### 1. Update Player Spawning\n```rust\ncommands.spawn((\n    Mesh3d(game_meshes.player.clone()),\n    MeshMaterial3d(game_materials.player.clone()),\n    Transform::from_translation(Vec3::new(0.0, 0.5, 0.0)), // Y=0.5 sits on ground\n    Player { speed: 200.0, regen_rate: 1.0, pickup_radius: 50.0 },\n    Health::new(100.0),\n    PlayerExperience { current: 0, level: 1 },\n));\n```\n\n### 2. Update Rock Spawning\n```rust\nfor _ in 0..15 {\n    let x = rng.gen_range(-40.0..40.0);  // Adjusted for 3D scale\n    let z = rng.gen_range(-30.0..30.0);  // Note: Y becomes Z\n    commands.spawn((\n        Mesh3d(game_meshes.rock.clone()),\n        MeshMaterial3d(game_materials.rock.clone()),\n        Transform::from_translation(Vec3::new(x, 0.25, z)), // Y=0.25 (half height)\n        Rock,\n    ));\n}\n```\n\n### 3. Update System Signature\nAdd resource parameters to access shared meshes/materials:\n```rust\npub fn setup_game(\n    mut commands: Commands,\n    camera_query: Query\u003cEntity, With\u003cCamera\u003e\u003e,\n    game_meshes: Res\u003cGameMeshes\u003e,\n    game_materials: Res\u003cGameMaterials\u003e,\n) { ... }\n```\n\n## Testing Requirements\n- Unit test: Player spawns with Mesh3d component\n- Unit test: Player spawns with MeshMaterial3d component\n- Unit test: Player transform Y position is 0.5 (sitting on ground)\n- Unit test: Rocks spawn with Mesh3d component\n- Unit test: Rocks spawn on XZ plane (Y=0.25)\n- Unit test: Rocks no longer use Z for layering\n- Update existing player spawn tests for 3D components\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] Player renders as green 3D cube\n- [ ] Player positioned at Y=0.5 (half cube height above ground)\n- [ ] Rocks render as grey 3D cubes\n- [ ] Rocks positioned on XZ plane with appropriate Y offset\n- [ ] Rock spawn range adjusted for 3D world scale\n- [ ] No Sprite components remain in player/rock spawning\n- [ ] All existing player tests updated and passing\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:46:31.034521+11:00","updated_at":"2025-12-28T10:07:49.036083+11:00","closed_at":"2025-12-28T10:07:49.036083+11:00","dependencies":[{"issue_id":"dt-survivor-0ql","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.307103+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-0ql","depends_on_id":"dt-survivor-ggr","type":"blocks","created_at":"2025-12-28T09:50:35.29717+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-1a7","title":"Create combat module structure","description":"Create src/combat/ module with mod.rs, components.rs, events.rs, systems.rs, plugin.rs. This is the foundation for unified combat handling. Files: src/combat/mod.rs (with re-exports), src/lib.rs (add pub mod combat).","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T17:40:28.385295+11:00","updated_at":"2025-12-25T17:55:30.171884+11:00","closed_at":"2025-12-25T17:55:30.171884+11:00","dependencies":[{"issue_id":"dt-survivor-1a7","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:40:45.617448+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-1ac","title":"Whisper 3D conversion blocked - document requirements","description":"The whisper module 3D conversion (dt-survivor-rfz) requires extensive changes:\n\n1. Remove bevy_lit 2D dependencies (PointLight2d -\u003e PointLight)\n2. Convert Mesh2d/MeshMaterial2d to Mesh3d/MeshMaterial3d\n3. Replace custom additive materials with StandardMaterial+emissive\n4. Convert XY coordinates to XZ for ground plane\n5. Update bevy_hanabi particle axes (Z-\u003eY)\n6. Update ~1800 lines of code and tests\n\nThis task should be done after other 3D conversions are complete to have working patterns to follow.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-28T10:40:41.14733+11:00","updated_at":"2025-12-28T10:41:47.946497+11:00","closed_at":"2025-12-28T10:41:47.946497+11:00","dependencies":[{"issue_id":"dt-survivor-1ac","depends_on_id":"dt-survivor-rfz","type":"discovered-from","created_at":"2025-12-28T10:40:41.148443+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-1j2","title":"Create movement systems","description":"Create src/movement/systems.rs with: apply_velocity (updates Transform from Velocity), apply_knockback (applies and decays knockback). Move player_movement from game/systems.rs, enemy_movement_system from enemies/systems.rs. Include tests.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T17:41:29.59513+11:00","updated_at":"2025-12-25T19:26:55.753582+11:00","closed_at":"2025-12-25T19:26:55.753582+11:00","dependencies":[{"issue_id":"dt-survivor-1j2","depends_on_id":"dt-survivor-e9f","type":"blocks","created_at":"2025-12-25T17:41:45.262226+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-1j2","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:41:45.958906+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-1qz","title":"Implement XP orb levels with value scaling and colors","description":"Add Level component to XP orbs with value scaling based on level. Higher level enemies drop higher level XP orbs.\n\n## Context\nCurrent XP orbs in src/loot/systems.rs spawn with ItemData::Experience and random value (5-15 XP). The ExperienceOrb component in src/experience/components.rs has a value field. Loot spawning reacts to EnemyDeathEvent.\n\n## Implementation\n\n### Updated Loot Drop System (src/loot/systems.rs)\n```rust\n/// XP value scaling by level\npub fn xp_value_for_level(level: u8) -\u003e u32 {\n    match level {\n        1 =\u003e 5,    // Common: 5 XP\n        2 =\u003e 15,   // Uncommon: 15 XP\n        3 =\u003e 35,   // Rare: 35 XP\n        4 =\u003e 75,   // Epic: 75 XP\n        _ =\u003e 150,  // Legendary: 150 XP\n    }\n}\n\n/// Determine XP orb level based on enemy level\nfn select_xp_level(enemy_level: u8, rng: \u0026mut impl Rng) -\u003e u8 {\n    // Higher enemy levels have better chance of dropping higher level orbs\n    // Enemy level acts as minimum possible orb level with chance for better\n    let base_level = enemy_level;\n    \n    // Roll for potential upgrade (20% chance per level above base, up to level 5)\n    let mut orb_level = base_level;\n    while orb_level \u003c 5 \u0026\u0026 rng.gen_bool(0.2) {\n        orb_level += 1;\n    }\n    orb_level\n}\n\npub fn loot_drop_system(\n    mut commands: Commands,\n    mut death_events: MessageReader\u003cEnemyDeathEvent\u003e,\n    enemy_query: Query\u003c\u0026Level, With\u003cEnemy\u003e\u003e,\n    xp_materials: Res\u003cXpOrbMaterials\u003e,\n    // ... other params ...\n) {\n    for event in death_events.read() {\n        let enemy_level = enemy_query.get(event.entity)\n            .map(|l| l.value())\n            .unwrap_or(1);\n        \n        // Spawn XP orbs\n        let orb_count = rng.gen_range(1..=3);\n        for i in 0..orb_count {\n            let orb_level = select_xp_level(enemy_level, \u0026mut rng);\n            let xp_value = xp_value_for_level(orb_level);\n            \n            commands.spawn((\n                DroppedItem {\n                    item_data: ItemData::Experience,\n                    // ... other fields ...\n                },\n                ExperienceOrb {\n                    value: xp_value,\n                    velocity: Vec2::ZERO,\n                },\n                Level::new(orb_level),\n                Mesh3d(game_meshes.xp_orb.clone()),\n                MeshMaterial3d(xp_materials.for_level(orb_level)),\n                // ... transform, etc ...\n            ));\n        }\n    }\n}\n```\n\n### XP Orb Materials Resource\n```rust\n/// Materials for each XP orb rarity level\n#[derive(Resource)]\npub struct XpOrbMaterials {\n    pub common: Handle\u003cStandardMaterial\u003e,      // Grey\n    pub uncommon: Handle\u003cStandardMaterial\u003e,    // Green\n    pub rare: Handle\u003cStandardMaterial\u003e,        // Blue\n    pub epic: Handle\u003cStandardMaterial\u003e,        // Purple\n    pub legendary: Handle\u003cStandardMaterial\u003e,   // Gold with emissive\n}\n\nimpl XpOrbMaterials {\n    pub fn new(materials: \u0026mut Assets\u003cStandardMaterial\u003e) -\u003e Self {\n        Self {\n            common: materials.add(StandardMaterial {\n                base_color: Color::srgb(0.6, 0.6, 0.6),\n                emissive: LinearRgba::new(0.6, 0.6, 0.6, 0.0) * 0.5,\n                ..default()\n            }),\n            uncommon: materials.add(StandardMaterial {\n                base_color: Color::srgb(0.0, 0.8, 0.2),\n                emissive: LinearRgba::new(0.0, 0.8, 0.2, 0.0) * 0.5,\n                ..default()\n            }),\n            rare: materials.add(StandardMaterial {\n                base_color: Color::srgb(0.2, 0.4, 1.0),\n                emissive: LinearRgba::new(0.2, 0.4, 1.0, 0.0) * 1.0,\n                ..default()\n            }),\n            epic: materials.add(StandardMaterial {\n                base_color: Color::srgb(0.6, 0.2, 0.8),\n                emissive: LinearRgba::new(0.6, 0.2, 0.8, 0.0) * 1.5,\n                ..default()\n            }),\n            legendary: materials.add(StandardMaterial {\n                base_color: Color::srgb(1.0, 0.84, 0.0),\n                emissive: LinearRgba::new(1.0, 0.84, 0.0, 0.0) * 3.0,\n                ..default()\n            }),\n        }\n    }\n\n    pub fn for_level(\u0026self, level: u8) -\u003e Handle\u003cStandardMaterial\u003e {\n        match level {\n            1 =\u003e self.common.clone(),\n            2 =\u003e self.uncommon.clone(),\n            3 =\u003e self.rare.clone(),\n            4 =\u003e self.epic.clone(),\n            _ =\u003e self.legendary.clone(),\n        }\n    }\n}\n```\n\n### Update Experience Orb Collection (src/experience/systems.rs)\n```rust\npub fn experience_orb_collection_system(\n    // ... existing params ...\n) {\n    for event in effect_events.read() {\n        if let ItemData::Experience = event.item_data {\n            // Value already set on ExperienceOrb component\n            // No changes needed to collection logic\n        }\n    }\n}\n```\n\n## XP Value Table\n| Level | Rarity    | XP Value | Enemy Level Drop Chance |\n|-------|-----------|----------|-------------------------|\n| 1     | Common    | 5        | All enemies             |\n| 2     | Uncommon  | 15       | Level 2+ enemies        |\n| 3     | Rare      | 35       | Level 3+ enemies        |\n| 4     | Epic      | 75       | Level 4+ enemies        |\n| 5     | Legendary | 150      | Level 5 enemies (+luck) |\n\n## ECS Pattern\n```rust\n// Query for XP orbs by level\nfn process_xp_orbs(\n    query: Query\u003c(\u0026Level, \u0026ExperienceOrb, \u0026Transform)\u003e,\n) {\n    for (level, orb, transform) in query.iter() {\n        // Level determines visual, orb.value determines XP gained\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] XP orbs spawn with Level component (1-5)\n- [ ] XP value scales with level (5, 15, 35, 75, 150)\n- [ ] Higher level enemies drop higher level orbs\n- [ ] XpOrbMaterials resource created with 5 distinct colors\n- [ ] Each orb level has appropriate emissive glow\n- [ ] Legendary orbs have strongest glow effect\n- [ ] Unit tests for xp_value_for_level function\n- [ ] Unit tests for select_xp_level probability\n\n## Test Requirements\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn xp_value_increases_with_level() {\n        assert_eq!(xp_value_for_level(1), 5);\n        assert_eq!(xp_value_for_level(2), 15);\n        assert_eq!(xp_value_for_level(5), 150);\n    }\n\n    #[test]\n    fn select_xp_level_respects_enemy_level_minimum() {\n        let mut rng = rand::thread_rng();\n        for _ in 0..100 {\n            let orb_level = select_xp_level(3, \u0026mut rng);\n            assert!(orb_level \u003e= 3); // Can't drop below enemy level\n        }\n    }\n}\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-30T09:42:58.202254+11:00","updated_at":"2025-12-30T11:10:03.131021+11:00","closed_at":"2025-12-30T11:10:03.131021+11:00","dependencies":[{"issue_id":"dt-survivor-1qz","depends_on_id":"dt-survivor-3l7","type":"blocks","created_at":"2025-12-30T09:45:07.190069+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-1qz","depends_on_id":"dt-survivor-wvj","type":"blocks","created_at":"2025-12-30T09:45:07.26487+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-1qz","depends_on_id":"dt-survivor-aiy","type":"parent-child","created_at":"2025-12-30T09:45:19.340073+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-1wg","title":"Create DamageEvent and DeathEvent","description":"Create combat events in src/combat/events.rs: DamageEvent { target: Entity, amount: f32, source: Option\u003cEntity\u003e }, DeathEvent { entity: Entity, position: Vec3, entity_type: EntityType }. Move existing EnemyDeathEvent logic to use these unified events.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T17:40:28.612206+11:00","updated_at":"2025-12-25T17:58:22.468784+11:00","closed_at":"2025-12-25T17:58:22.468784+11:00","dependencies":[{"issue_id":"dt-survivor-1wg","depends_on_id":"dt-survivor-1a7","type":"blocks","created_at":"2025-12-25T17:40:45.118858+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-1wg","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:40:45.776952+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-3l7","title":"Create reusable Level component","description":"Create a generic Level component that can be attached to any entity requiring level tracking. This is the foundational building block for all progression systems.\n\n## Context\nCurrently the codebase uses composable components (Health, Damage, Speed, Velocity) that can be attached to multiple entity types. The Level component follows this pattern.\n\n## Implementation\n\n### Component Definition (src/game/components.rs or new src/level/components.rs)\n```rust\nuse bevy::prelude::*;\n\n/// Rarity tiers for game entities, matching the standard RPG color scheme\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]\npub enum Rarity {\n    #[default]\n    Common,    // Level 1 - Grey\n    Uncommon,  // Level 2 - Green\n    Rare,      // Level 3 - Blue\n    Epic,      // Level 4 - Purple\n    Legendary, // Level 5 - Gold\n}\n\nimpl Rarity {\n    pub fn from_level(level: u8) -\u003e Self {\n        match level {\n            1 =\u003e Rarity::Common,\n            2 =\u003e Rarity::Uncommon,\n            3 =\u003e Rarity::Rare,\n            4 =\u003e Rarity::Epic,\n            5.. =\u003e Rarity::Legendary,\n            _ =\u003e Rarity::Common,\n        }\n    }\n\n    pub fn color(\u0026self) -\u003e Color {\n        match self {\n            Rarity::Common =\u003e Color::srgb(0.6, 0.6, 0.6),     // Grey\n            Rarity::Uncommon =\u003e Color::srgb(0.0, 0.8, 0.2),  // Green\n            Rarity::Rare =\u003e Color::srgb(0.2, 0.4, 1.0),      // Blue\n            Rarity::Epic =\u003e Color::srgb(0.6, 0.2, 0.8),      // Purple\n            Rarity::Legendary =\u003e Color::srgb(1.0, 0.84, 0.0), // Gold\n        }\n    }\n}\n\n/// Level component for entities that have progression levels\n#[derive(Component, Debug, Clone, Copy, Default)]\npub struct Level(pub u8);\n\nimpl Level {\n    pub fn new(level: u8) -\u003e Self {\n        Self(level.max(1).min(5)) // Clamp between 1-5\n    }\n\n    pub fn value(\u0026self) -\u003e u8 {\n        self.0\n    }\n\n    pub fn rarity(\u0026self) -\u003e Rarity {\n        Rarity::from_level(self.0)\n    }\n\n    pub fn color(\u0026self) -\u003e Color {\n        self.rarity().color()\n    }\n}\n```\n\n### Prelude Export (src/prelude.rs)\nAdd Level and Rarity to prelude for easy access across modules.\n\n### ECS Usage Pattern\n```rust\n// Attach to entities at spawn time\ncommands.spawn((\n    Enemy::default(),\n    Health::new(10.0 * level as f32),\n    Level::new(level),\n    CheckDeath,\n));\n\n// Query entities by level\nfn scale_by_level(query: Query\u003c(\u0026Level, \u0026mut Health), With\u003cEnemy\u003e\u003e) {\n    for (level, mut health) in query.iter_mut() {\n        // Systems can use level.value() or level.rarity()\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] Level component clamps values between 1-5\n- [ ] Rarity enum maps levels to color scheme\n- [ ] Level and Rarity exported via prelude\n- [ ] Unit tests for Level::new clamping behavior\n- [ ] Unit tests for Rarity::from_level mapping\n- [ ] Unit tests for color() returning correct RGB values\n\n## Test Requirements\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn level_clamps_to_valid_range() {\n        assert_eq!(Level::new(0).value(), 1);\n        assert_eq!(Level::new(1).value(), 1);\n        assert_eq!(Level::new(5).value(), 5);\n        assert_eq!(Level::new(10).value(), 5);\n    }\n\n    #[test]\n    fn rarity_from_level_maps_correctly() {\n        assert_eq!(Rarity::from_level(1), Rarity::Common);\n        assert_eq!(Rarity::from_level(2), Rarity::Uncommon);\n        assert_eq!(Rarity::from_level(3), Rarity::Rare);\n        assert_eq!(Rarity::from_level(4), Rarity::Epic);\n        assert_eq!(Rarity::from_level(5), Rarity::Legendary);\n    }\n}\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-30T09:40:29.79888+11:00","updated_at":"2025-12-30T10:39:20.330029+11:00","closed_at":"2025-12-30T10:39:20.330029+11:00","dependencies":[{"issue_id":"dt-survivor-3l7","depends_on_id":"dt-survivor-aiy","type":"parent-child","created_at":"2025-12-30T09:45:18.982918+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-3z7","title":"Create MovementPlugin","description":"Create src/movement/plugin.rs with MovementPlugin that registers systems with run_if(in_state(GameState::InGame)).in_set(GameSet::Movement). Update game/plugin.rs to delegate movement systems.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T17:41:29.704911+11:00","updated_at":"2025-12-25T19:29:18.168215+11:00","closed_at":"2025-12-25T19:29:18.168215+11:00","dependencies":[{"issue_id":"dt-survivor-3z7","depends_on_id":"dt-survivor-1j2","type":"blocks","created_at":"2025-12-25T17:41:45.36079+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-3z7","depends_on_id":"dt-survivor-7gg","type":"blocks","created_at":"2025-12-25T17:41:45.449523+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-3z7","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:41:46.047496+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-45y","title":"Run full test suite and fix regressions","description":"After all refactoring is complete, run cargo test to verify all tests pass. Run cargo clippy to fix any warnings. Ensure 90% code coverage is maintained. Fix any regressions introduced during refactoring.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T17:42:02.902028+11:00","updated_at":"2025-12-25T20:11:20.85134+11:00","closed_at":"2025-12-25T20:11:20.85134+11:00","dependencies":[{"issue_id":"dt-survivor-45y","depends_on_id":"dt-survivor-f77","type":"blocks","created_at":"2025-12-25T17:42:20.284677+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-45y","depends_on_id":"dt-survivor-70v","type":"blocks","created_at":"2025-12-25T17:42:20.363162+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-45y","depends_on_id":"dt-survivor-7gg","type":"blocks","created_at":"2025-12-25T17:42:20.446812+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-45y","depends_on_id":"dt-survivor-3z7","type":"blocks","created_at":"2025-12-25T17:42:20.531606+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-45y","depends_on_id":"dt-survivor-cch","type":"blocks","created_at":"2025-12-25T17:42:20.60702+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-45y","depends_on_id":"dt-survivor-8hu","type":"blocks","created_at":"2025-12-25T17:42:20.683525+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-45y","depends_on_id":"dt-survivor-6x9","type":"blocks","created_at":"2025-12-25T17:42:20.766376+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-45y","depends_on_id":"dt-survivor-8s7","type":"blocks","created_at":"2025-12-25T17:42:20.842823+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-45y","depends_on_id":"dt-survivor-ubg","type":"blocks","created_at":"2025-12-25T17:42:20.92369+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-45y","depends_on_id":"dt-survivor-7m0","type":"blocks","created_at":"2025-12-25T17:42:21.009282+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-45y","depends_on_id":"dt-survivor-d0t","type":"blocks","created_at":"2025-12-25T17:42:21.093144+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-45y","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:42:21.497406+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-4i1","title":"Update movement systems from XY to XZ plane","description":"# Task: Movement System XYâ†’XZ Conversion\n\n## Context\nDT Survivor is migrating from 2D to 3D. All movement currently operates on the XY plane with Z used for layering. Movement must be converted to XZ plane with Y as the up axis (Bevy's default 3D coordinate system).\n\n## Current Implementation\n**Velocity Application** (`src/movement/systems.rs:10-15`):\n```rust\npub fn apply_velocity(mut query: Query\u003c(\u0026mut Transform, \u0026Velocity)\u003e, time: Res\u003cTime\u003e) {\n    for (mut transform, velocity) in query.iter_mut() {\n        let movement = velocity.value() * time.delta_secs();\n        transform.translation += movement.extend(0.0); // XY plane\n    }\n}\n```\n\n**Knockback** (`src/movement/systems.rs:19-37`): Uses Vec2 direction applied to XY\n\n**Enemy Movement** (`src/movement/systems.rs:84-100`):\n```rust\nlet direction = (player_pos - enemy_pos).normalize();\ntransform.translation += Vec3::new(direction.x, direction.y, 0.0) * speed * dt;\n```\n\n## Required Changes\n\n### 1. Create XZ Helper Function\nAdd to `src/movement/components.rs` or a new `utils.rs`:\n```rust\n/// Convert 2D vector to 3D XZ plane movement (Y=0)\npub fn to_xz(v: Vec2) -\u003e Vec3 {\n    Vec3::new(v.x, 0.0, v.y)\n}\n\n/// Extract XZ coordinates from 3D position as Vec2\npub fn from_xz(v: Vec3) -\u003e Vec2 {\n    Vec2::new(v.x, v.z)\n}\n```\n\n### 2. Update apply_velocity System\n```rust\npub fn apply_velocity(mut query: Query\u003c(\u0026mut Transform, \u0026Velocity)\u003e, time: Res\u003cTime\u003e) {\n    for (mut transform, velocity) in query.iter_mut() {\n        let movement = velocity.value() * time.delta_secs();\n        transform.translation += to_xz(movement); // XZ plane\n    }\n}\n```\n\n### 3. Update apply_knockback System\n```rust\n// Before\ntransform.translation += direction.extend(0.0) * force * dt;\n\n// After\ntransform.translation += to_xz(direction * force * dt);\n```\n\n### 4. Update enemy_movement_system\n```rust\npub fn enemy_movement_system(\n    mut query: Query\u003c(\u0026mut Transform, \u0026Enemy)\u003e,\n    player_position: Res\u003cPlayerPosition\u003e,\n    time: Res\u003cTime\u003e,\n) {\n    let player_pos = player_position.0; // Already Vec2, represents XZ\n    for (mut transform, enemy) in query.iter_mut() {\n        let enemy_pos = from_xz(transform.translation);\n        let direction = (player_pos - enemy_pos).normalize_or_zero();\n        transform.translation += to_xz(direction * enemy.speed * time.delta_secs());\n    }\n}\n```\n\n### 5. Update PlayerPosition Resource\nThe `PlayerPosition` resource stores `Vec2`. Ensure it represents XZ coordinates:\n```rust\n// When updating PlayerPosition\nplayer_position.0 = Vec2::new(player_transform.translation.x, player_transform.translation.z);\n```\n\n## Testing Requirements\n- Unit test: to_xz converts Vec2 to Vec3 with Y=0\n- Unit test: from_xz extracts X and Z as Vec2\n- Unit test: apply_velocity moves entities on XZ plane\n- Unit test: Entity Y position unchanged after velocity application\n- Unit test: apply_knockback works on XZ plane\n- Unit test: enemy_movement_system moves toward player on XZ\n- Unit test: PlayerPosition updated correctly\n- Update all existing movement tests\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] to_xz and from_xz helper functions implemented\n- [ ] apply_velocity system uses XZ plane\n- [ ] apply_knockback system uses XZ plane\n- [ ] enemy_movement_system chases player on XZ plane\n- [ ] Entity Y positions unchanged by movement systems\n- [ ] PlayerPosition resource stores XZ coordinates\n- [ ] All movement tests updated and passing\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:49:17.486913+11:00","updated_at":"2025-12-28T10:04:41.014515+11:00","closed_at":"2025-12-28T10:04:41.014515+11:00","dependencies":[{"issue_id":"dt-survivor-4i1","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.567746+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-4i1","depends_on_id":"dt-survivor-nq8","type":"blocks","created_at":"2025-12-28T09:50:36.792265+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-4w1","title":"Fix failing tests in bullets and game modules","description":"Six tests are currently failing: test_bullet_collision_detection, test_bullet_collision_no_collision (panic in run_main), and four tests in game::systems::tests related to player-enemy collision damage (test_player_enemy_collision_immediate_damage, test_player_enemy_collision_damage_cooldown, test_player_death_on_zero_health, test_damage_timer_reset_when_not_touching). These failures appear to be pre-existing issues with the collision/damage systems.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-25T18:04:53.402234+11:00","updated_at":"2025-12-25T18:17:15.454951+11:00","closed_at":"2025-12-25T18:17:15.454951+11:00"}
{"id":"dt-survivor-6q4","title":"Create movement module structure","description":"Create src/movement/ module with mod.rs, components.rs, systems.rs, plugin.rs. This consolidates movement logic from game and enemies modules. Add pub mod movement to lib.rs and movement_plugin to main.rs.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T17:41:29.367885+11:00","updated_at":"2025-12-25T19:11:47.207461+11:00","closed_at":"2025-12-25T19:11:47.207461+11:00","dependencies":[{"issue_id":"dt-survivor-6q4","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:41:45.790851+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-6x9","title":"Centralize event registration","description":"Fix event registration redundancy. EnemyDeathEvent currently registered in game/plugin.rs, enemy_death/plugin.rs, and laser tests. Centralize: combat/plugin.rs owns DamageEvent/DeathEvent, game/plugin.rs owns collision events, loot/plugin.rs owns pickup events. Remove duplicates.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T17:41:30.051186+11:00","updated_at":"2025-12-25T19:46:30.827015+11:00","closed_at":"2025-12-25T19:46:30.827015+11:00","dependencies":[{"issue_id":"dt-survivor-6x9","depends_on_id":"dt-survivor-xp9","type":"blocks","created_at":"2025-12-25T17:41:45.611306+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-6x9","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:41:46.311655+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-6zt","title":"Implement enemy damage flash effect","description":"Add a white flash visual effect when enemies take damage, providing clear feedback that damage was dealt.\n\n## Context\nThe codebase already has a screen tint system for player damage (ScreenTintEffect). A similar pattern can be used for enemy damage flash. The combat system uses DamageEvent and apply_damage_system in src/combat/systems.rs.\n\n## Implementation\n\n### Component Definition (src/combat/components.rs)\n```rust\n/// Visual flash effect when entity takes damage\n#[derive(Component)]\npub struct DamageFlash {\n    /// Timer for flash duration\n    pub timer: Timer,\n    /// Original material handle to restore\n    pub original_material: Handle\u003cStandardMaterial\u003e,\n}\n\nimpl DamageFlash {\n    pub fn new(original_material: Handle\u003cStandardMaterial\u003e, duration: f32) -\u003e Self {\n        Self {\n            timer: Timer::from_seconds(duration, TimerMode::Once),\n            original_material,\n        }\n    }\n}\n```\n\n### Flash Material Resource (src/game/resources.rs)\n```rust\n/// Shared material for damage flash effect\n#[derive(Resource)]\npub struct DamageFlashMaterial(pub Handle\u003cStandardMaterial\u003e);\n\n// Create in setup_game_assets\nfn setup_game_assets(\n    mut commands: Commands,\n    mut materials: ResMut\u003cAssets\u003cStandardMaterial\u003e\u003e,\n) {\n    let flash_material = materials.add(StandardMaterial {\n        base_color: Color::WHITE,\n        emissive: LinearRgba::WHITE * 3.0,\n        ..default()\n    });\n    commands.insert_resource(DamageFlashMaterial(flash_material));\n}\n```\n\n### System Implementation (src/combat/systems.rs)\n```rust\n/// Apply flash effect when damage is dealt to enemies\npub fn apply_damage_flash_system(\n    mut commands: Commands,\n    mut damage_events: MessageReader\u003cDamageEvent\u003e,\n    enemy_query: Query\u003c(Entity, \u0026MeshMaterial3d\u003cStandardMaterial\u003e), (With\u003cEnemy\u003e, Without\u003cDamageFlash\u003e)\u003e,\n    flash_material: Res\u003cDamageFlashMaterial\u003e,\n) {\n    for event in damage_events.read() {\n        if let Ok((entity, current_material)) = enemy_query.get(event.target) {\n            // Store original and apply flash\n            commands.entity(entity).insert((\n                DamageFlash::new(current_material.0.clone(), 0.1),\n                MeshMaterial3d(flash_material.0.clone()),\n            ));\n        }\n    }\n}\n\n/// Update flash timers and restore original materials\npub fn update_damage_flash_system(\n    mut commands: Commands,\n    time: Res\u003cTime\u003e,\n    mut query: Query\u003c(Entity, \u0026mut DamageFlash, \u0026mut MeshMaterial3d\u003cStandardMaterial\u003e)\u003e,\n) {\n    for (entity, mut flash, mut material) in query.iter_mut() {\n        flash.timer.tick(time.delta());\n        \n        if flash.timer.finished() {\n            // Restore original material and remove flash component\n            material.0 = flash.original_material.clone();\n            commands.entity(entity).remove::\u003cDamageFlash\u003e();\n        }\n    }\n}\n```\n\n### System Registration (src/combat/plugin.rs)\n```rust\napp.add_systems(\n    Update,\n    (\n        apply_damage_flash_system,\n        update_damage_flash_system,\n    )\n        .chain()\n        .in_set(GameSet::Effects)\n        .run_if(in_state(GameState::InGame)),\n);\n```\n\n## ECS Pattern\n- DamageFlash is a marker+data component that opts entities into the flash system\n- Systems react to DamageEvent (event-driven)\n- Component stores state (original material) for cleanup\n- Material reference swapping for visual effect\n\n## Visual Behavior\n1. Enemy takes damage (DamageEvent fired)\n2. apply_damage_flash_system replaces material with white emissive\n3. update_damage_flash_system ticks timer\n4. After 0.1 seconds, original material restored\n5. Flash can re-trigger on subsequent damage\n\n## Acceptance Criteria\n- [ ] DamageFlash component stores original material and timer\n- [ ] DamageFlashMaterial resource created with white emissive material\n- [ ] Enemies flash white for 0.1 seconds when taking damage\n- [ ] Original material correctly restored after flash\n- [ ] Flash can trigger multiple times on same enemy\n- [ ] No flash applied to entities without Enemy component\n- [ ] Unit tests for DamageFlash timer behavior\n\n## Test Requirements\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn damage_flash_timer_starts_correctly() {\n        let flash = DamageFlash::new(Handle::default(), 0.1);\n        assert!(!flash.timer.finished());\n        assert_eq!(flash.timer.duration().as_secs_f32(), 0.1);\n    }\n}\n```","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-30T09:42:24.837742+11:00","updated_at":"2025-12-30T11:22:21.287471+11:00","closed_at":"2025-12-30T11:22:21.287471+11:00","dependencies":[{"issue_id":"dt-survivor-6zt","depends_on_id":"dt-survivor-wvj","type":"blocks","created_at":"2025-12-30T09:45:07.110029+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-6zt","depends_on_id":"dt-survivor-aiy","type":"parent-child","created_at":"2025-12-30T09:45:19.266457+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-70v","title":"Extract Player health to Health component","description":"Refactor src/player/components.rs: remove health, max_health from Player struct. Modify player spawn to attach separate Health component. Update player_health_regeneration_system and damage systems to use Health component. Keeps regen_rate in Player.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T17:40:29.062224+11:00","updated_at":"2025-12-25T18:52:17.946578+11:00","closed_at":"2025-12-25T18:52:17.946578+11:00","dependencies":[{"issue_id":"dt-survivor-70v","depends_on_id":"dt-survivor-xp9","type":"blocks","created_at":"2025-12-25T17:40:45.536817+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-70v","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:40:46.097014+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-78g","title":"Fix failing integration tests in main.rs due to missing ActivePowerups resource","description":"Eight integration tests in main.rs are failing because the ActivePowerups resource is not initialized. Tests failing: test_weapon_firing_spawns_bullets, test_scoring_integration_full_flow, test_scoring_integration_multiple_enemies, test_scoring_integration_score_persistence, test_weapon_equipped_to_player, test_weapon_slots_ui_created, test_no_blank_screen_during_transitions, test_camera_reuse_across_state_transitions. The system donny_tango_survivor::loot::systems::apply_item_effects requires ResMut\u003cActivePowerups\u003e but the resource doesn't exist in the test app context.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-25T18:17:08.650091+11:00","updated_at":"2025-12-25T18:20:50.690287+11:00","closed_at":"2025-12-25T18:20:50.690287+11:00","dependencies":[{"issue_id":"dt-survivor-78g","depends_on_id":"dt-survivor-4w1","type":"discovered-from","created_at":"2025-12-25T18:17:08.652038+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-7gg","title":"Configure SystemSet ordering in plugin","description":"Update src/game/plugin.rs to configure set ordering: app.configure_sets(Update, (GameSet::Input, GameSet::Movement, GameSet::Combat, GameSet::Spawning, GameSet::Effects, GameSet::Cleanup).chain()). Assign existing systems to appropriate sets using .in_set().","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T17:41:02.078328+11:00","updated_at":"2025-12-25T19:03:36.681675+11:00","closed_at":"2025-12-25T19:03:36.681675+11:00","dependencies":[{"issue_id":"dt-survivor-7gg","depends_on_id":"dt-survivor-bem","type":"blocks","created_at":"2025-12-25T17:41:10.264016+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-7gg","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:41:10.503212+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-7m0","title":"Use WeaponType enum in UI components","description":"Update src/ui/components.rs: change WeaponIcon { weapon_type: String } to WeaponIcon { weapon_type: WeaponType }. Same for WeaponLevelDisplay. Update UI systems to use enum matching instead of string comparison. Improves type safety.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-25T17:42:02.620929+11:00","updated_at":"2025-12-25T20:06:53.533998+11:00","closed_at":"2025-12-25T20:06:53.533998+11:00","dependencies":[{"issue_id":"dt-survivor-7m0","depends_on_id":"dt-survivor-cch","type":"blocks","created_at":"2025-12-25T17:42:20.034756+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-7m0","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:42:21.337279+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-8af","title":"Debug test_weapon_equipped_to_player failure after whisper 3D conversion","description":"When converting whisper module to 3D, the main.rs integration test test_weapon_equipped_to_player fails with 'Should have no weapon entities until Whisper is collected' (left: 1, right: 0). The failure is caused by changes in systems.rs but the exact cause was not identified. Need to investigate what in the whisper systems changes causes a Weapon entity to be spawned during game initialization.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-28T11:01:11.085495+11:00","updated_at":"2025-12-28T11:16:37.74246+11:00","closed_at":"2025-12-28T11:16:37.74246+11:00","dependencies":[{"issue_id":"dt-survivor-8af","depends_on_id":"dt-survivor-rfz","type":"blocks","created_at":"2025-12-28T11:01:11.086002+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-8hu","title":"Complete loot module migration","description":"Remove legacy code from loot module: delete LootItem component, remove loot_spawning_system, loot_attraction_system, loot_movement_system. Keep new ECS-based systems: detect_pickup_collisions, update_item_attraction, apply_item_effects. Update loot/plugin.rs registrations.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T17:41:29.937241+11:00","updated_at":"2025-12-25T19:42:41.321373+11:00","closed_at":"2025-12-25T19:42:41.321373+11:00","dependencies":[{"issue_id":"dt-survivor-8hu","depends_on_id":"dt-survivor-f77","type":"blocks","created_at":"2025-12-25T17:41:45.704476+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-8hu","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:41:46.214775+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-8i6","title":"Convert rocket launcher and explosions to 3D","description":"# Task: Rocket Launcher 3D Conversion\n\n## Context\nDT Survivor is migrating from 2D to 3D. The rocket launcher fires rockets that explode on impact, both rendered as sprites. These need to be converted to 3D geometry.\n\n## Current Implementation\n**Rocket Spawning** (`src/rocket_launcher/systems.rs`):\n- Rockets use `Sprite::from_color()` with color-changing animation\n- Size: 12x6 pixels (elongated for rocket shape)\n- Direction-based rotation\n- Velocity on XY plane\n\n**Explosion Effect**:\n- Expanding circle sprite\n- Red/orange color\n- Damages enemies within radius\n\n## Required Changes\n\n### 1. Replace Rocket Sprite with 3D Mesh\n```rust\n// Before\ncommands.spawn((\n    Sprite::from_color(color, Vec2::new(12.0, 6.0)),\n    Transform { rotation, translation, .. },\n    Rocket { ... },\n));\n\n// After\ncommands.spawn((\n    Mesh3d(meshes.add(Cuboid::new(0.3, 0.15, 0.6))), // Elongated cube\n    MeshMaterial3d(materials.add(StandardMaterial {\n        base_color: Color::srgb(1.0, 0.5, 0.0), // Orange\n        emissive: LinearRgba::rgb(1.0, 0.3, 0.0),\n        ..default()\n    })),\n    Transform {\n        translation: Vec3::new(player_pos.x, 0.5, player_pos.z),\n        rotation: rotation_y,\n        ..default()\n    },\n    Rocket { direction, speed, lifetime },\n));\n```\n\n### 2. Update Rocket Movement\nConvert from XY to XZ plane:\n```rust\n// Before\ntransform.translation += rocket.direction.extend(0.0) * speed * dt;\n\n// After\nlet movement = rocket.direction * speed * dt;\ntransform.translation += Vec3::new(movement.x, 0.0, movement.y);\n```\n\n### 3. Update Rocket Rotation\nRotate around Y axis to face direction of travel:\n```rust\nlet angle = rocket.direction.y.atan2(rocket.direction.x);\ntransform.rotation = Quat::from_rotation_y(-angle + std::f32::consts::FRAC_PI_2);\n```\n\n### 4. Replace Explosion Sprite with 3D Effect\nOption A: Expanding sphere mesh\n```rust\ncommands.spawn((\n    Mesh3d(meshes.add(Sphere::new(0.1))),\n    MeshMaterial3d(materials.add(StandardMaterial {\n        base_color: Color::srgba(1.0, 0.3, 0.0, 0.8),\n        emissive: LinearRgba::rgb(2.0, 0.5, 0.0),\n        alpha_mode: AlphaMode::Blend,\n        ..default()\n    })),\n    Transform::from_translation(explosion_pos),\n    Explosion { radius: 0.0, max_radius: 3.0, expansion_rate: 10.0 },\n));\n```\n\nOption B: Particle burst (more dramatic)\n```rust\n// Use bevy_hanabi for explosion particles\n// Orange/red burst expanding outward\n```\n\n### 5. Update Explosion Expansion\n```rust\nfn expand_explosions(\n    mut query: Query\u003c(\u0026mut Transform, \u0026mut Explosion)\u003e,\n    time: Res\u003cTime\u003e,\n) {\n    for (mut transform, mut explosion) in query.iter_mut() {\n        explosion.radius += explosion.expansion_rate * time.delta_secs();\n        let scale = explosion.radius / explosion.max_radius;\n        transform.scale = Vec3::splat(explosion.max_radius * scale);\n        \n        if explosion.radius \u003e= explosion.max_radius {\n            // Despawn or fade out\n        }\n    }\n}\n```\n\n### 6. Update Rocket Targeting\nDirection calculation to nearest enemy:\n```rust\nlet rocket_xz = Vec2::new(rocket_pos.x, rocket_pos.z);\nlet enemy_xz = Vec2::new(enemy_pos.x, enemy_pos.z);\nlet direction = (enemy_xz - rocket_xz).normalize();\n```\n\n## Testing Requirements\n- Unit test: Rocket spawns with Mesh3d component\n- Unit test: Rocket movement on XZ plane\n- Unit test: Rocket rotation faces movement direction\n- Unit test: Explosion spawns on rocket impact\n- Unit test: Explosion expands correctly\n- Unit test: Explosion damages enemies in radius\n- Unit test: Explosion radius check uses XZ coordinates\n- Update existing rocket tests for 3D\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] Rockets render as 3D elongated cubes\n- [ ] Rockets move on XZ plane\n- [ ] Rockets rotate to face direction\n- [ ] Explosions render as 3D spheres or particles\n- [ ] Explosion expansion works in 3D\n- [ ] Explosion damage radius works on XZ plane\n- [ ] No Sprite components in rocket/explosion\n- [ ] All rocket tests updated and passing\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:49:22.269968+11:00","updated_at":"2025-12-28T10:44:36.700489+11:00","closed_at":"2025-12-28T10:44:36.700489+11:00","dependencies":[{"issue_id":"dt-survivor-8i6","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.964123+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-8i6","depends_on_id":"dt-survivor-ggr","type":"blocks","created_at":"2025-12-28T09:50:35.626564+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-8s7","title":"Add GameOverEvent","description":"Create GameOverEvent in src/game/events.rs with final_score: u32, survival_time: f32. Update player_death_system to fire event before state transition. UI and audio systems can listen for this event. Decouples game over handling from direct state manipulation.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-25T17:42:02.391996+11:00","updated_at":"2025-12-25T19:53:22.892474+11:00","closed_at":"2025-12-25T19:53:22.892474+11:00","dependencies":[{"issue_id":"dt-survivor-8s7","depends_on_id":"dt-survivor-1wg","type":"blocks","created_at":"2025-12-25T17:42:19.872421+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-8s7","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:42:21.170925+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-a2s","title":"Convert enemy spawning from Sprite to Mesh3d cubes","description":"# Task: Enemy 3D Spawning\n\n## Context\nDT Survivor is migrating from 2D to 3D. Enemies currently spawn as red sprites and need to be converted to 3D cube meshes. Spawn positions must be converted from XY plane to XZ plane.\n\n## Current Implementation\n**Enemy Spawning** (`src/enemies/systems.rs:11-83`):\n```rust\ncommands.spawn((\n    Sprite::from_color(Color::srgb(1.0, 0.0, 0.0), Vec2::new(15.0, 15.0)),\n    Transform::from_translation(Vec3::new(spawn_pos.x, spawn_pos.y, 0.5)),\n    Enemy { speed: 50.0, strength: 10.0 },\n    Health::new(10.0),\n    CheckDeath,\n));\n```\n\nSpawn position is calculated at 600+ units from player using angle/distance on XY plane.\n\n## Required Changes\n\n### 1. Update Enemy Spawn Position Calculation\nConvert from XY to XZ plane:\n```rust\n// Before\nlet spawn_pos = Vec2::new(\n    player_pos.x + angle.cos() * distance,\n    player_pos.y + angle.sin() * distance,\n);\n\n// After\nlet spawn_x = player_pos.x + angle.cos() * distance;\nlet spawn_z = player_pos.y + angle.sin() * distance; // Y becomes Z in 3D\nlet spawn_pos = Vec3::new(spawn_x, 0.375, spawn_z); // Y=0.375 (half of 0.75 cube)\n```\n\n### 2. Update Enemy Spawning\n```rust\ncommands.spawn((\n    Mesh3d(game_meshes.enemy.clone()),\n    MeshMaterial3d(game_materials.enemy.clone()),\n    Transform::from_translation(spawn_pos),\n    Enemy { speed: 50.0, strength: 10.0 },\n    Health::new(10.0),\n    CheckDeath,\n));\n```\n\n### 3. Update System Signature\n```rust\npub fn spawn_enemy(\n    mut commands: Commands,\n    time: Res\u003cTime\u003e,\n    mut spawn_timer: ResMut\u003cEnemySpawnTimer\u003e,\n    player_position: Res\u003cPlayerPosition\u003e,\n    game_meshes: Res\u003cGameMeshes\u003e,\n    game_materials: Res\u003cGameMaterials\u003e,\n) { ... }\n```\n\n### 4. Adjust Spawn Distance for 3D Scale\nThe spawn distance (600 units) may need adjustment for the new 3D scale. Consider reducing to ~60 units if world scale changes.\n\n## Testing Requirements\n- Unit test: Enemy spawns with Mesh3d component\n- Unit test: Enemy spawns with MeshMaterial3d component\n- Unit test: Enemy transform Y position is 0.375 (half cube height)\n- Unit test: Enemy spawn position is on XZ plane (not XY)\n- Unit test: Spawn distance from player is correct\n- Unit test: Spawn angle distribution is uniform around player\n- Update existing enemy spawn tests for 3D coordinates\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] Enemies render as red 3D cubes\n- [ ] Enemies spawn on XZ plane at appropriate Y height\n- [ ] Spawn positions calculated correctly in 3D space\n- [ ] Enemy speed and strength unchanged\n- [ ] Health and CheckDeath components still attached\n- [ ] No Sprite components in enemy spawning\n- [ ] All existing enemy tests updated and passing\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:46:32.257852+11:00","updated_at":"2025-12-28T10:09:40.364142+11:00","closed_at":"2025-12-28T10:09:40.364142+11:00","dependencies":[{"issue_id":"dt-survivor-a2s","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.371959+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-a2s","depends_on_id":"dt-survivor-ggr","type":"blocks","created_at":"2025-12-28T09:50:35.36709+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-ahu","title":"Implement Game Level resource and kill tracking","description":"Create a GameLevel resource to track the current game level and enemy kill count. The game level increases as players kill enemies. When a level is completed, the game transitions to the LevelComplete state.\n\n## Context\nThe current codebase has EnemySpawnState resource in src/enemies/systems.rs that tracks spawn rate progression. The GameLevel resource will work alongside this to drive overall game progression.\n\n## Implementation\n\n### Resource Definition (src/game/resources.rs)\n```rust\n/// Configuration for game level progression\n#[derive(Debug, Clone)]\npub struct LevelConfig {\n    /// Base number of kills needed to advance from level 1\n    pub base_kills: u32,\n    /// Multiplier applied each level (kills_needed = base_kills * multiplier^(level-1))\n    pub kill_multiplier: f32,\n}\n\nimpl Default for LevelConfig {\n    fn default() -\u003e Self {\n        Self {\n            base_kills: 10,\n            kill_multiplier: 1.5,\n        }\n    }\n}\n\n/// Tracks game level progression\n#[derive(Resource, Debug, Default)]\npub struct GameLevel {\n    /// Current game level (starts at 1)\n    pub level: u32,\n    /// Number of enemies killed in current level\n    pub kills_this_level: u32,\n    /// Total enemies killed this game\n    pub total_kills: u32,\n    /// Configuration for progression\n    pub config: LevelConfig,\n}\n\nimpl GameLevel {\n    pub fn new() -\u003e Self {\n        Self {\n            level: 1,\n            kills_this_level: 0,\n            total_kills: 0,\n            config: LevelConfig::default(),\n        }\n    }\n\n    /// Calculate kills needed to advance from current level\n    pub fn kills_to_advance(\u0026self) -\u003e u32 {\n        let multiplier = self.config.kill_multiplier.powi(self.level as i32 - 1);\n        (self.config.base_kills as f32 * multiplier).ceil() as u32\n    }\n\n    /// Register a kill and return true if level advanced\n    pub fn register_kill(\u0026mut self) -\u003e bool {\n        self.kills_this_level += 1;\n        self.total_kills += 1;\n        \n        if self.kills_this_level \u003e= self.kills_to_advance() {\n            self.level += 1;\n            self.kills_this_level = 0;\n            true\n        } else {\n            false\n        }\n    }\n\n    /// Progress percentage toward next level (0.0 - 1.0)\n    pub fn progress(\u0026self) -\u003e f32 {\n        self.kills_this_level as f32 / self.kills_to_advance() as f32\n    }\n}\n```\n\n### Event Definition (src/game/events.rs)\n```rust\n/// Fired when the game advances to a new level\n#[derive(Message, Debug)]\npub struct GameLevelUpEvent {\n    pub new_level: u32,\n}\n```\n\n### System Implementation (src/game/systems.rs)\n```rust\n/// Tracks enemy kills, advances game level, and triggers level complete state\npub fn track_enemy_kills_system(\n    mut death_events: MessageReader\u003cEnemyDeathEvent\u003e,\n    mut game_level: ResMut\u003cGameLevel\u003e,\n    mut level_up_writer: MessageWriter\u003cGameLevelUpEvent\u003e,\n    mut next_state: ResMut\u003cNextState\u003cGameState\u003e\u003e,\n) {\n    for _ in death_events.read() {\n        if game_level.register_kill() {\n            level_up_writer.write(GameLevelUpEvent {\n                new_level: game_level.level,\n            });\n            // Transition to level complete screen\n            next_state.set(GameState::LevelComplete);\n        }\n    }\n}\n\n/// Reset game level on game start\npub fn reset_game_level(mut game_level: ResMut\u003cGameLevel\u003e) {\n    *game_level = GameLevel::new();\n}\n```\n\n### Plugin Registration (src/game/plugin.rs)\n```rust\napp\n    .init_resource::\u003cGameLevel\u003e()\n    .add_message::\u003cGameLevelUpEvent\u003e()\n    .add_systems(OnEnter(GameState::InGame), reset_game_level)\n    .add_systems(\n        Update,\n        track_enemy_kills_system\n            .in_set(GameSet::Effects)\n            .run_if(in_state(GameState::InGame)),\n    );\n```\n\n## Progression Example\nWith default config (base_kills=10, multiplier=1.5):\n- Level 1 â†’ 2: 10 kills\n- Level 2 â†’ 3: 15 kills (10 * 1.5)\n- Level 3 â†’ 4: 23 kills (10 * 1.5^2)\n- Level 4 â†’ 5: 34 kills (10 * 1.5^3)\n\n## ECS Pattern\n```rust\n// Track kills via event-driven architecture\nfn track_kills(\n    mut death_events: MessageReader\u003cEnemyDeathEvent\u003e,\n    mut game_level: ResMut\u003cGameLevel\u003e,\n    mut next_state: ResMut\u003cNextState\u003cGameState\u003e\u003e,\n) {\n    for _ in death_events.read() {\n        if game_level.register_kill() {\n            next_state.set(GameState::LevelComplete);\n        }\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] GameLevel resource tracks current level, kills this level, total kills\n- [ ] kills_to_advance() returns correct threshold based on level\n- [ ] register_kill() increments counters and returns true on level up\n- [ ] GameLevelUpEvent fired when level advances\n- [ ] GameState transitions to LevelComplete when level advances\n- [ ] GameLevel resets on game start (not when returning from LevelComplete)\n- [ ] Unit tests for kill tracking and level advancement\n- [ ] Unit tests for progression formula\n\n## Test Requirements\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn game_level_starts_at_one() {\n        let level = GameLevel::new();\n        assert_eq!(level.level, 1);\n        assert_eq!(level.kills_this_level, 0);\n    }\n\n    #[test]\n    fn kills_to_advance_increases_with_level() {\n        let mut level = GameLevel::new();\n        let kills_1 = level.kills_to_advance();\n        level.level = 2;\n        let kills_2 = level.kills_to_advance();\n        assert!(kills_2 \u003e kills_1);\n    }\n\n    #[test]\n    fn register_kill_advances_level_at_threshold() {\n        let mut level = GameLevel::new();\n        let threshold = level.kills_to_advance();\n        for _ in 0..threshold - 1 {\n            assert!(!level.register_kill());\n        }\n        assert!(level.register_kill()); // Should advance\n        assert_eq!(level.level, 2);\n        assert_eq!(level.kills_this_level, 0);\n    }\n\n    #[test]\n    fn progress_returns_correct_percentage() {\n        let mut level = GameLevel::new();\n        level.kills_this_level = 5;\n        // With base_kills=10, progress should be 0.5\n        assert!((level.progress() - 0.5).abs() \u003c 0.01);\n    }\n}\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-30T09:40:58.239174+11:00","updated_at":"2025-12-30T10:47:32.578764+11:00","closed_at":"2025-12-30T10:47:32.578764+11:00","dependencies":[{"issue_id":"dt-survivor-ahu","depends_on_id":"dt-survivor-3l7","type":"blocks","created_at":"2025-12-30T09:45:06.809673+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-ahu","depends_on_id":"dt-survivor-aiy","type":"parent-child","created_at":"2025-12-30T09:45:19.055926+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-aiy","title":"Game Progression System","description":"Implement a complete game progression system including game levels, enemy levels (1-5), XP orb levels (1-5), player leveling, and weapon damage scaling. This epic coordinates all progression mechanics that make the game increasingly challenging over time.\n\n## Overview\nThe game should progress through levels, with enemies, XP orbs, and the player all having level mechanics. Higher game levels spawn stronger enemies, which drop better XP orbs, allowing players to level up and deal more damage.\n\n## Key Requirements\n- Game level progression based on enemy kills\n- Enemy levels 1-5 with HP/damage scaling and visual differentiation\n- XP orb levels 1-5 with value scaling and color coding\n- Player leveling with increasing XP requirements\n- Weapon damage scaling with level\n\n## ECS Pattern: Level Component\nA reusable Level component should be created and attached to entities that need level tracking. Systems operate on entities with the Level component.\n\n## Color Scheme (for enemies and XP orbs)\n- Level 1: Grey (common)\n- Level 2: Green (uncommon)\n- Level 3: Blue (rare)\n- Level 4: Purple (epic)\n- Level 5: Gold (legendary)","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-30T09:40:04.73001+11:00","updated_at":"2025-12-30T09:40:04.73001+11:00"}
{"id":"dt-survivor-b35","title":"Implement Level Complete screen with overlay and continue flow","description":"Create the level complete screen that appears when a game level is completed, showing stats and allowing the player to continue.\n\n## Context\nWhen GameLevelUpEvent fires (from dt-survivor-ahu), the game should pause and display a level complete screen. The LevelStats resource (dt-survivor-0as) provides the statistics to display.\n\n## Game State Addition (src/states.rs)\n```rust\n#[derive(States, Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]\npub enum GameState {\n    #[default]\n    MainMenu,\n    InGame,\n    LevelComplete,  // NEW: Pause state for level complete screen\n    Paused,\n    GameOver,\n}\n```\n\n## Implementation\n\n### Components (src/ui/components.rs)\n```rust\n/// Root marker for level complete UI\n#[derive(Component)]\npub struct LevelCompleteScreen;\n\n/// The black overlay that animates opacity\n#[derive(Component)]\npub struct LevelCompleteOverlay {\n    pub target_opacity: f32,\n    pub current_opacity: f32,\n    pub animation_speed: f32,\n}\n\nimpl Default for LevelCompleteOverlay {\n    fn default() -\u003e Self {\n        Self {\n            target_opacity: 0.85,\n            current_opacity: 0.0,\n            animation_speed: 2.0, // Fully opaque in ~0.5 seconds\n        }\n    }\n}\n\n/// Marker for the continue button\n#[derive(Component)]\npub struct ContinueButton;\n\n/// Marker for level complete stats text\n#[derive(Component)]\npub struct LevelCompleteStatsText;\n```\n\n### Level Complete UI Setup (src/ui/systems.rs)\n```rust\npub fn setup_level_complete_screen(\n    mut commands: Commands,\n    asset_server: Res\u003cAssetServer\u003e,\n    game_level: Res\u003cGameLevel\u003e,\n    level_stats: Res\u003cLevelStats\u003e,\n) {\n    // Root container for entire level complete UI\n    commands.spawn((\n        Node {\n            width: Val::Percent(100.0),\n            height: Val::Percent(100.0),\n            position_type: PositionType::Absolute,\n            flex_direction: FlexDirection::Column,\n            align_items: AlignItems::Center,\n            justify_content: JustifyContent::Center,\n            ..default()\n        },\n        LevelCompleteScreen,\n    )).with_children(|parent| {\n        // Black overlay background (animates opacity)\n        parent.spawn((\n            Node {\n                width: Val::Percent(100.0),\n                height: Val::Percent(100.0),\n                position_type: PositionType::Absolute,\n                ..default()\n            },\n            BackgroundColor(Color::srgba(0.0, 0.0, 0.0, 0.0)),\n            LevelCompleteOverlay::default(),\n        ));\n\n        // Content container (centered)\n        parent.spawn((\n            Node {\n                flex_direction: FlexDirection::Column,\n                align_items: AlignItems::Center,\n                row_gap: Val::Px(20.0),\n                padding: UiRect::all(Val::Px(40.0)),\n                ..default()\n            },\n            ZIndex(1), // Above overlay\n        )).with_children(|content| {\n            // \"Level X Complete\" title\n            content.spawn((\n                Text::new(format!(\"Level {} Complete!\", game_level.level - 1)),\n                TextFont {\n                    font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\n                    font_size: 48.0,\n                    ..default()\n                },\n                TextColor(Color::srgb(1.0, 0.84, 0.0)), // Gold\n            ));\n\n            // Stats container\n            content.spawn((\n                Node {\n                    flex_direction: FlexDirection::Column,\n                    align_items: AlignItems::Start,\n                    row_gap: Val::Px(10.0),\n                    margin: UiRect::vertical(Val::Px(20.0)),\n                    ..default()\n                },\n            )).with_children(|stats| {\n                // Time taken\n                stats.spawn((\n                    Text::new(format!(\"Time: {}\", level_stats.formatted_time())),\n                    TextFont {\n                        font: asset_server.load(\"fonts/FiraSans-Regular.ttf\"),\n                        font_size: 24.0,\n                        ..default()\n                    },\n                    TextColor(Color::WHITE),\n                ));\n\n                // Enemies killed\n                stats.spawn((\n                    Text::new(format!(\"Enemies Killed: {}\", level_stats.enemies_killed)),\n                    TextFont {\n                        font: asset_server.load(\"fonts/FiraSans-Regular.ttf\"),\n                        font_size: 24.0,\n                        ..default()\n                    },\n                    TextColor(Color::WHITE),\n                ));\n\n                // XP gained\n                stats.spawn((\n                    Text::new(format!(\"XP Gained: {}\", level_stats.xp_gained)),\n                    TextFont {\n                        font: asset_server.load(\"fonts/FiraSans-Regular.ttf\"),\n                        font_size: 24.0,\n                        ..default()\n                    },\n                    TextColor(Color::WHITE),\n                ));\n            });\n\n            // Continue button\n            content.spawn((\n                Node {\n                    padding: UiRect::axes(Val::Px(40.0), Val::Px(15.0)),\n                    margin: UiRect::top(Val::Px(20.0)),\n                    ..default()\n                },\n                BackgroundColor(Color::srgb(0.2, 0.6, 0.2)),\n                Button,\n                ContinueButton,\n            )).with_children(|btn| {\n                btn.spawn((\n                    Text::new(\"Continue\"),\n                    TextFont {\n                        font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\n                        font_size: 28.0,\n                        ..default()\n                    },\n                    TextColor(Color::WHITE),\n                ));\n            });\n        });\n    });\n}\n```\n\n### Overlay Animation System\n```rust\npub fn animate_level_complete_overlay(\n    time: Res\u003cTime\u003e,\n    mut query: Query\u003c(\u0026mut LevelCompleteOverlay, \u0026mut BackgroundColor)\u003e,\n) {\n    for (mut overlay, mut bg_color) in query.iter_mut() {\n        if overlay.current_opacity \u003c overlay.target_opacity {\n            overlay.current_opacity += time.delta_secs() * overlay.animation_speed;\n            overlay.current_opacity = overlay.current_opacity.min(overlay.target_opacity);\n            bg_color.0 = Color::srgba(0.0, 0.0, 0.0, overlay.current_opacity);\n        }\n    }\n}\n```\n\n### Continue Button Handler\n```rust\npub fn handle_continue_button(\n    mut interaction_query: Query\u003c\n        (\u0026Interaction, \u0026mut BackgroundColor),\n        (Changed\u003cInteraction\u003e, With\u003cContinueButton\u003e),\n    \u003e,\n    mut next_state: ResMut\u003cNextState\u003cGameState\u003e\u003e,\n    mut commands: Commands,\n    enemies_query: Query\u003cEntity, With\u003cEnemy\u003e\u003e,\n    loot_query: Query\u003cEntity, With\u003cDroppedItem\u003e\u003e,\n    mut level_stats: ResMut\u003cLevelStats\u003e,\n    time: Res\u003cTime\u003e,\n) {\n    for (interaction, mut bg_color) in interaction_query.iter_mut() {\n        match *interaction {\n            Interaction::Pressed =\u003e {\n                // Despawn all enemies\n                for entity in enemies_query.iter() {\n                    commands.entity(entity).despawn_recursive();\n                }\n                \n                // Despawn all loot\n                for entity in loot_query.iter() {\n                    commands.entity(entity).despawn_recursive();\n                }\n                \n                // Reset level stats for new level\n                level_stats.reset(time.elapsed_secs());\n                \n                // Return to game\n                next_state.set(GameState::InGame);\n            }\n            Interaction::Hovered =\u003e {\n                bg_color.0 = Color::srgb(0.3, 0.7, 0.3);\n            }\n            Interaction::None =\u003e {\n                bg_color.0 = Color::srgb(0.2, 0.6, 0.2);\n            }\n        }\n    }\n}\n```\n\n### Play Level Complete Sound\n```rust\npub fn play_level_complete_sound(\n    mut commands: Commands,\n    asset_server: Res\u003cAssetServer\u003e,\n) {\n    commands.spawn((\n        AudioPlayer::new(asset_server.load(\"sounds/790472__organizedlaziness__level-completed.wav\")),\n        PlaybackSettings::DESPAWN,\n    ));\n}\n```\n\n### Trigger Level Complete State (modify track_enemy_kills_system in dt-survivor-ahu)\n```rust\npub fn track_enemy_kills_system(\n    mut death_events: MessageReader\u003cEnemyDeathEvent\u003e,\n    mut game_level: ResMut\u003cGameLevel\u003e,\n    mut level_up_writer: MessageWriter\u003cGameLevelUpEvent\u003e,\n    mut next_state: ResMut\u003cNextState\u003cGameState\u003e\u003e,\n) {\n    for _ in death_events.read() {\n        if game_level.register_kill() {\n            level_up_writer.write(GameLevelUpEvent {\n                new_level: game_level.level,\n            });\n            // Transition to level complete screen\n            next_state.set(GameState::LevelComplete);\n        }\n    }\n}\n```\n\n### Cleanup Level Complete UI\n```rust\npub fn cleanup_level_complete_screen(\n    mut commands: Commands,\n    query: Query\u003cEntity, With\u003cLevelCompleteScreen\u003e\u003e,\n) {\n    for entity in query.iter() {\n        commands.entity(entity).despawn_recursive();\n    }\n}\n```\n\n### Plugin Registration\n```rust\napp\n    .add_systems(OnEnter(GameState::LevelComplete), (\n        setup_level_complete_screen,\n        play_level_complete_sound,\n    ))\n    .add_systems(\n        Update,\n        (\n            animate_level_complete_overlay,\n            handle_continue_button,\n        ).run_if(in_state(GameState::LevelComplete)),\n    )\n    .add_systems(OnExit(GameState::LevelComplete), cleanup_level_complete_screen);\n```\n\n## State Preservation\nWhen continuing to next level, the following are preserved:\n- Player entity (position reset to center)\n- Player level and XP (PlayerExperience component)\n- Weapon levels (Weapon components)\n- Whisper state (WhisperState resource)\n\nThe following are despawned/reset:\n- All Enemy entities\n- All DroppedItem entities (loot, XP orbs)\n- LevelStats (reset for new level tracking)\n\n## Sound File\n- Path: assets/sounds/790472__organizedlaziness__level-completed.wav\n- Played once when entering LevelComplete state\n\n## ECS Pattern\n```rust\n// Marker components for UI cleanup\n#[derive(Component)]\npub struct LevelCompleteScreen;\n\n// Query all level complete UI for cleanup\nfn cleanup(mut commands: Commands, query: Query\u003cEntity, With\u003cLevelCompleteScreen\u003e\u003e) {\n    for entity in query.iter() {\n        commands.entity(entity).despawn_recursive();\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] GameState::LevelComplete added to states enum\n- [ ] Black overlay animates from transparent to 0.85 opacity\n- [ ] \"Level X Complete!\" text displayed in gold\n- [ ] Stats displayed: time (MM:SS), enemies killed, XP gained\n- [ ] Continue button visible and interactive\n- [ ] Button hover state changes color\n- [ ] Clicking Continue despawns all enemies\n- [ ] Clicking Continue despawns all loot/XP orbs\n- [ ] Level stats reset when continuing\n- [ ] Level complete sound plays on state enter\n- [ ] Player/weapon levels preserved across levels\n- [ ] Whisper state preserved across levels\n- [ ] UI cleaned up when exiting LevelComplete state\n- [ ] Game pauses (no enemy spawning/movement) during LevelComplete\n\n## Test Requirements\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn level_complete_overlay_animates_correctly() {\n        let mut overlay = LevelCompleteOverlay::default();\n        assert_eq!(overlay.current_opacity, 0.0);\n        \n        // Simulate animation\n        let delta = 0.25; // quarter second\n        overlay.current_opacity += delta * overlay.animation_speed;\n        overlay.current_opacity = overlay.current_opacity.min(overlay.target_opacity);\n        \n        assert!(overlay.current_opacity \u003e 0.0);\n        assert!(overlay.current_opacity \u003c= overlay.target_opacity);\n    }\n\n    #[test]\n    fn level_complete_overlay_caps_at_target() {\n        let mut overlay = LevelCompleteOverlay::default();\n        overlay.current_opacity = 0.8;\n        \n        // Large delta should cap at target\n        let delta = 1.0;\n        overlay.current_opacity += delta * overlay.animation_speed;\n        overlay.current_opacity = overlay.current_opacity.min(overlay.target_opacity);\n        \n        assert_eq!(overlay.current_opacity, overlay.target_opacity);\n    }\n}\n```","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-30T10:34:53.440285+11:00","updated_at":"2025-12-30T10:34:53.440285+11:00","dependencies":[{"issue_id":"dt-survivor-b35","depends_on_id":"dt-survivor-aiy","type":"blocks","created_at":"2025-12-30T10:35:04.843152+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-b35","depends_on_id":"dt-survivor-ahu","type":"blocks","created_at":"2025-12-30T10:35:04.919669+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-b35","depends_on_id":"dt-survivor-0as","type":"blocks","created_at":"2025-12-30T10:35:04.99316+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-b67","title":"Convert bullet spawning from Sprite to Mesh3d cubes","description":"# Task: Bullet 3D Spawning\n\n## Context\nDT Survivor is migrating from 2D to 3D. Bullets (projectiles) currently spawn as yellow sprites and need to be converted to 3D cube meshes. Bullet direction is stored as Vec2 and used for XY movement - this needs to work with XZ plane instead.\n\n## Current Implementation\n**Bullet Spawning** (`src/bullets/systems.rs:24-106`):\n```rust\ncommands.spawn((\n    Sprite::from_color(Color::srgb(1.0, 1.0, 0.0), Vec2::new(8.0, 8.0)),\n    Transform::from_translation(player_transform.translation + Vec3::new(0.0, 0.0, 0.1)),\n    Bullet {\n        direction: direction,  // Vec2\n        speed: 200.0,\n        lifetime: Timer::from_seconds(15.0, TimerMode::Once),\n    },\n));\n```\n\n**Bullet Movement** (`src/bullets/systems.rs:108-116`):\n```rust\nlet movement = bullet.direction * bullet.speed * time.delta_secs();\ntransform.translation += movement.extend(0.0); // XY movement\n```\n\n## Required Changes\n\n### 1. Update Bullet Spawning\n```rust\ncommands.spawn((\n    Mesh3d(game_meshes.bullet.clone()),\n    MeshMaterial3d(game_materials.bullet.clone()),\n    Transform::from_translation(Vec3::new(\n        player_transform.translation.x,\n        0.5, // Same height as player center\n        player_transform.translation.z,\n    )),\n    Bullet {\n        direction: direction,  // Still Vec2, but represents XZ\n        speed: 200.0,\n        lifetime: Timer::from_seconds(15.0, TimerMode::Once),\n    },\n));\n```\n\n### 2. Update Bullet Movement System\n```rust\npub fn bullet_movement_system(\n    mut query: Query\u003c(\u0026mut Transform, \u0026Bullet)\u003e,\n    time: Res\u003cTime\u003e,\n) {\n    for (mut transform, bullet) in query.iter_mut() {\n        let movement = bullet.direction * bullet.speed * time.delta_secs();\n        // Convert Vec2 to XZ plane movement\n        transform.translation += Vec3::new(movement.x, 0.0, movement.y);\n    }\n}\n```\n\n### 3. Update Direction Calculation\nWhen calculating direction to nearest enemy:\n```rust\n// Before\nlet direction = (enemy_pos.truncate() - player_pos.truncate()).normalize();\n\n// After\nlet enemy_xz = Vec2::new(enemy_pos.x, enemy_pos.z);\nlet player_xz = Vec2::new(player_pos.x, player_pos.z);\nlet direction = (enemy_xz - player_xz).normalize();\n```\n\n### 4. Update Collision Detection\nBullet-enemy collision in `check_bullet_enemy_collision`:\n```rust\n// Before\nlet bullet_pos = bullet_transform.translation.truncate();\nlet enemy_pos = enemy_transform.translation.truncate();\n\n// After\nlet bullet_pos = Vec2::new(bullet_transform.translation.x, bullet_transform.translation.z);\nlet enemy_pos = Vec2::new(enemy_transform.translation.x, enemy_transform.translation.z);\n```\n\n## Testing Requirements\n- Unit test: Bullet spawns with Mesh3d component\n- Unit test: Bullet spawns at player XZ position with correct Y height\n- Unit test: Bullet direction Vec2 represents XZ plane correctly\n- Unit test: Bullet movement applies to X and Z axes (not X and Y)\n- Unit test: Bullet-enemy collision detection works on XZ plane\n- Unit test: Bullet spread pattern works in 3D\n- Update existing bullet tests for 3D coordinates\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] Bullets render as yellow 3D cubes (small, 0.3 size)\n- [ ] Bullets spawn at player's XZ position\n- [ ] Bullets move on XZ plane (Y stays constant)\n- [ ] Bullet direction targets enemies correctly in 3D\n- [ ] Bullet-enemy collisions detected on XZ plane\n- [ ] Bullet spread pattern functional\n- [ ] Bullet lifetime and despawning unchanged\n- [ ] No Sprite components in bullet spawning\n- [ ] All existing bullet tests updated and passing\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:46:32.415016+11:00","updated_at":"2025-12-28T10:16:30.709385+11:00","closed_at":"2025-12-28T10:16:30.709385+11:00","dependencies":[{"issue_id":"dt-survivor-b67","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.438418+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-b67","depends_on_id":"dt-survivor-ggr","type":"blocks","created_at":"2025-12-28T09:50:35.433042+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-bem","title":"Create GameSet SystemSets","description":"Add SystemSets for explicit system ordering in src/game/sets.rs (or systems.rs): GameSet enum with Input, Movement, Combat, Spawning, Effects, Cleanup variants. Derive SystemSet, Debug, Clone, PartialEq, Eq, Hash. Export from game module.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T17:41:01.959314+11:00","updated_at":"2025-12-25T18:56:32.52717+11:00","closed_at":"2025-12-25T18:56:32.52717+11:00","dependencies":[{"issue_id":"dt-survivor-bem","depends_on_id":"dt-survivor-xp9","type":"blocks","created_at":"2025-12-25T17:41:10.341444+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-bem","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:41:10.420985+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-c8q","title":"Add UI display for game level and progression","description":"Create UI elements to display the current game level, kill progress, and player level/XP progress.\n\n## Context\nCurrent UI in src/ui/systems.rs displays score, survival time, and player health. The UI uses Bevy's UI system with Text components. This task adds displays for game level and player progression.\n\n## Implementation\n\n### UI Components (src/ui/components.rs)\n```rust\n/// Marker for game level display UI element\n#[derive(Component)]\npub struct GameLevelDisplay;\n\n/// Marker for kill progress display\n#[derive(Component)]\npub struct KillProgressDisplay;\n\n/// Marker for player level display\n#[derive(Component)]\npub struct PlayerLevelDisplay;\n\n/// Marker for XP progress bar\n#[derive(Component)]\npub struct XpProgressBar;\n\n/// Marker for XP progress bar fill\n#[derive(Component)]\npub struct XpProgressBarFill;\n```\n\n### UI Setup System (src/ui/systems.rs)\n```rust\npub fn setup_progression_ui(\n    mut commands: Commands,\n    asset_server: Res\u003cAssetServer\u003e,\n) {\n    // Game Level Display (top-center)\n    commands.spawn((\n        Text::new(\"Game Level: 1\"),\n        TextFont {\n            font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\n            font_size: 24.0,\n            ..default()\n        },\n        TextColor(Color::WHITE),\n        Node {\n            position_type: PositionType::Absolute,\n            top: Val::Px(10.0),\n            left: Val::Percent(50.0),\n            ..default()\n        },\n        GameLevelDisplay,\n    ));\n\n    // Kill Progress (below game level)\n    commands.spawn((\n        Text::new(\"Kills: 0/10\"),\n        TextFont {\n            font: asset_server.load(\"fonts/FiraSans-Regular.ttf\"),\n            font_size: 16.0,\n            ..default()\n        },\n        TextColor(Color::srgba(1.0, 1.0, 1.0, 0.7)),\n        Node {\n            position_type: PositionType::Absolute,\n            top: Val::Px(40.0),\n            left: Val::Percent(50.0),\n            ..default()\n        },\n        KillProgressDisplay,\n    ));\n\n    // Player Level (top-left, below health)\n    commands.spawn((\n        Text::new(\"Player Lv: 1\"),\n        TextFont {\n            font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\n            font_size: 20.0,\n            ..default()\n        },\n        TextColor(Color::srgb(0.8, 0.8, 1.0)),\n        Node {\n            position_type: PositionType::Absolute,\n            top: Val::Px(70.0),\n            left: Val::Px(10.0),\n            ..default()\n        },\n        PlayerLevelDisplay,\n    ));\n\n    // XP Progress Bar Container\n    commands.spawn((\n        Node {\n            position_type: PositionType::Absolute,\n            top: Val::Px(95.0),\n            left: Val::Px(10.0),\n            width: Val::Px(150.0),\n            height: Val::Px(8.0),\n            ..default()\n        },\n        BackgroundColor(Color::srgba(0.2, 0.2, 0.2, 0.8)),\n        XpProgressBar,\n    )).with_children(|parent| {\n        // XP Progress Bar Fill\n        parent.spawn((\n            Node {\n                width: Val::Percent(0.0),\n                height: Val::Percent(100.0),\n                ..default()\n            },\n            BackgroundColor(Color::srgb(0.4, 0.8, 1.0)),\n            XpProgressBarFill,\n        ));\n    });\n}\n```\n\n### UI Update Systems\n```rust\n/// Update game level display\npub fn update_game_level_display(\n    game_level: Res\u003cGameLevel\u003e,\n    mut query: Query\u003c\u0026mut Text, With\u003cGameLevelDisplay\u003e\u003e,\n) {\n    if game_level.is_changed() {\n        for mut text in query.iter_mut() {\n            text.0 = format\\!(\"Game Level: {}\", game_level.level);\n        }\n    }\n}\n\n/// Update kill progress display\npub fn update_kill_progress_display(\n    game_level: Res\u003cGameLevel\u003e,\n    mut query: Query\u003c\u0026mut Text, With\u003cKillProgressDisplay\u003e\u003e,\n) {\n    if game_level.is_changed() {\n        for mut text in query.iter_mut() {\n            text.0 = format\\!(\n                \"Kills: {}/{}\", \n                game_level.kills_this_level, \n                game_level.kills_to_advance()\n            );\n        }\n    }\n}\n\n/// Update player level display\npub fn update_player_level_display(\n    player_query: Query\u003c\u0026PlayerExperience, (With\u003cPlayer\u003e, Changed\u003cPlayerExperience\u003e)\u003e,\n    mut text_query: Query\u003c\u0026mut Text, With\u003cPlayerLevelDisplay\u003e\u003e,\n) {\n    if let Ok(exp) = player_query.get_single() {\n        for mut text in text_query.iter_mut() {\n            text.0 = format\\!(\"Player Lv: {}\", exp.level);\n        }\n    }\n}\n\n/// Update XP progress bar\npub fn update_xp_progress_bar(\n    player_query: Query\u003c\u0026PlayerExperience, (With\u003cPlayer\u003e, Changed\u003cPlayerExperience\u003e)\u003e,\n    mut bar_query: Query\u003c\u0026mut Node, With\u003cXpProgressBarFill\u003e\u003e,\n) {\n    if let Ok(exp) = player_query.get_single() {\n        for mut node in bar_query.iter_mut() {\n            node.width = Val::Percent(exp.progress() * 100.0);\n        }\n    }\n}\n```\n\n### Plugin Registration\n```rust\napp\n    .add_systems(OnEnter(GameState::InGame), setup_progression_ui)\n    .add_systems(\n        Update,\n        (\n            update_game_level_display,\n            update_kill_progress_display,\n            update_player_level_display,\n            update_xp_progress_bar,\n        )\n            .run_if(in_state(GameState::InGame)),\n    );\n```\n\n## UI Layout\n```\n+------------------------------------------+\n|  HP: 100/100      Game Level: 3          |\n|  Player Lv: 5     Kills: 15/23           |\n|  [=======   ] XP                         |\n|                                          |\n|                                          |\n|              (Game Area)                 |\n|                                          |\n|                                   Score: |\n|                                   Time:  |\n+------------------------------------------+\n```\n\n## ECS Pattern\nUI elements use marker components for efficient querying:\n```rust\n// Only update changed elements\nfn update_display(\n    resource: Res\u003cSomeResource\u003e,\n    mut query: Query\u003c\u0026mut Text, With\u003cSomeMarker\u003e\u003e,\n) {\n    if resource.is_changed() {\n        // Update UI\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] Game level displayed prominently (top-center)\n- [ ] Kill progress shown as \"X/Y kills\"\n- [ ] Player level displayed (top-left area)\n- [ ] XP progress bar shows fill percentage\n- [ ] UI updates only when relevant data changes (efficiency)\n- [ ] UI elements cleaned up on game exit\n- [ ] Text is legible against game background\n- [ ] Visual test: UI elements don't overlap\n\n## Test Requirements\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // UI tests typically require visual inspection\n    // But we can test component marker existence\n    \n    #[test]\n    fn ui_markers_are_unique() {\n        // Compile-time test - markers are distinct types\n        let _game: GameLevelDisplay = GameLevelDisplay;\n        let _player: PlayerLevelDisplay = PlayerLevelDisplay;\n        // If this compiles, markers are distinct\n    }\n}\n```","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-30T09:44:49.137335+11:00","updated_at":"2025-12-30T11:34:47.467474+11:00","closed_at":"2025-12-30T11:34:47.467474+11:00","dependencies":[{"issue_id":"dt-survivor-c8q","depends_on_id":"dt-survivor-ahu","type":"blocks","created_at":"2025-12-30T09:45:07.983629+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-c8q","depends_on_id":"dt-survivor-cp8","type":"blocks","created_at":"2025-12-30T09:45:08.071808+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-c8q","depends_on_id":"dt-survivor-aiy","type":"parent-child","created_at":"2025-12-30T09:45:19.558843+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-cch","title":"Populate weapon plugin with systems","description":"Move weapon systems from src/game/plugin.rs to src/weapon/plugin.rs: weapon_firing_system, weapon_follow_player_system. Update game/plugin.rs to add WeaponPlugin as sub-plugin. Currently weapon/plugin.rs is an empty stub.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T17:41:29.82361+11:00","updated_at":"2025-12-25T19:32:50.913061+11:00","closed_at":"2025-12-25T19:32:50.913061+11:00","dependencies":[{"issue_id":"dt-survivor-cch","depends_on_id":"dt-survivor-7gg","type":"blocks","created_at":"2025-12-25T17:41:45.529638+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-cch","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:41:46.130346+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-cp8","title":"Implement Player leveling with increasing XP requirements","description":"Enhance the player leveling system so that leveling up requires increasing amounts of XP. XP resets on level up.\n\n## Context\nCurrent implementation in src/experience/components.rs has PlayerExperience with current and level fields. The experience_orb_collection_system in src/experience/systems.rs adds XP when orbs are collected. This task enhances the leveling mechanics.\n\n## Implementation\n\n### Updated PlayerExperience Component (src/experience/components.rs)\n```rust\n/// Configuration for player XP requirements\n#[derive(Debug, Clone)]\npub struct ExperienceConfig {\n    /// Base XP needed for level 2\n    pub base_xp: u32,\n    /// Multiplier per level (xp_needed = base_xp * multiplier^(level-1))\n    pub xp_multiplier: f32,\n}\n\nimpl Default for ExperienceConfig {\n    fn default() -\u003e Self {\n        Self {\n            base_xp: 100,\n            xp_multiplier: 1.5,\n        }\n    }\n}\n\n/// Tracks player experience and level\n#[derive(Component, Debug, Default)]\npub struct PlayerExperience {\n    /// Current XP in this level\n    pub current: u32,\n    /// Current player level (starts at 1)\n    pub level: u32,\n    /// Total XP ever gained (for stats)\n    pub total_xp: u32,\n    /// Configuration\n    pub config: ExperienceConfig,\n}\n\nimpl PlayerExperience {\n    pub fn new() -\u003e Self {\n        Self {\n            current: 0,\n            level: 1,\n            total_xp: 0,\n            config: ExperienceConfig::default(),\n        }\n    }\n\n    /// XP needed to advance from current level\n    pub fn xp_to_next_level(\u0026self) -\u003e u32 {\n        let multiplier = self.config.xp_multiplier.powi(self.level as i32 - 1);\n        (self.config.base_xp as f32 * multiplier).ceil() as u32\n    }\n\n    /// Add XP and return number of levels gained\n    pub fn add_xp(\u0026mut self, amount: u32) -\u003e u32 {\n        self.current += amount;\n        self.total_xp += amount;\n        \n        let mut levels_gained = 0;\n        while self.current \u003e= self.xp_to_next_level() {\n            self.current -= self.xp_to_next_level();\n            self.level += 1;\n            levels_gained += 1;\n        }\n        levels_gained\n    }\n\n    /// Progress percentage toward next level (0.0 - 1.0)\n    pub fn progress(\u0026self) -\u003e f32 {\n        self.current as f32 / self.xp_to_next_level() as f32\n    }\n}\n```\n\n### Event Definition (src/experience/events.rs or components.rs)\n```rust\n/// Fired when player gains a level\n#[derive(Message, Debug)]\npub struct PlayerLevelUpEvent {\n    pub new_level: u32,\n    pub levels_gained: u32,\n}\n```\n\n### Updated Experience Collection System (src/experience/systems.rs)\n```rust\npub fn experience_orb_collection_system(\n    mut effect_events: MessageReader\u003cItemEffectEvent\u003e,\n    orb_query: Query\u003c\u0026ExperienceOrb\u003e,\n    mut player_query: Query\u003c\u0026mut PlayerExperience, With\u003cPlayer\u003e\u003e,\n    mut level_up_writer: MessageWriter\u003cPlayerLevelUpEvent\u003e,\n) {\n    for event in effect_events.read() {\n        if let ItemData::Experience = event.item_data {\n            if let Ok(orb) = orb_query.get(event.source_entity) {\n                if let Ok(mut exp) = player_query.get_single_mut() {\n                    let levels_gained = exp.add_xp(orb.value);\n                    \n                    if levels_gained \u003e 0 {\n                        level_up_writer.write(PlayerLevelUpEvent {\n                            new_level: exp.level,\n                            levels_gained,\n                        });\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n### Level Up Visual Effect (optional system)\n```rust\npub fn player_level_up_effect_system(\n    mut level_up_events: MessageReader\u003cPlayerLevelUpEvent\u003e,\n    mut screen_tint: ResMut\u003cScreenTintEffect\u003e,\n) {\n    for event in level_up_events.read() {\n        // Gold screen flash for level up\n        screen_tint.set_color(Color::srgb(1.0, 0.84, 0.0), 0.3);\n    }\n}\n```\n\n### Reset on Game Start\n```rust\npub fn reset_player_experience(\n    mut player_query: Query\u003c\u0026mut PlayerExperience, With\u003cPlayer\u003e\u003e,\n) {\n    if let Ok(mut exp) = player_query.get_single_mut() {\n        *exp = PlayerExperience::new();\n    }\n}\n```\n\n## XP Requirements Table\nWith default config (base_xp=100, multiplier=1.5):\n| Level | XP to Next Level | Cumulative XP |\n|-------|------------------|---------------|\n| 1     | 100              | 0             |\n| 2     | 150              | 100           |\n| 3     | 225              | 250           |\n| 4     | 338              | 475           |\n| 5     | 506              | 813           |\n| 10    | 2,562            | 5,075         |\n\n## ECS Pattern\n```rust\n// Query player experience\nfn show_player_xp(\n    query: Query\u003c\u0026PlayerExperience, With\u003cPlayer\u003e\u003e,\n) {\n    if let Ok(exp) = query.get_single() {\n        println!(\"Level {} - {}/{} XP ({:.0}%)\", \n            exp.level, \n            exp.current, \n            exp.xp_to_next_level(),\n            exp.progress() * 100.0\n        );\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] PlayerExperience tracks current XP, level, and total XP\n- [ ] xp_to_next_level() returns correct threshold with multiplier\n- [ ] add_xp() handles level-ups correctly, including multiple at once\n- [ ] XP resets to remainder after level up (not zero)\n- [ ] PlayerLevelUpEvent fired on level up\n- [ ] Unit tests for XP threshold calculations\n- [ ] Unit tests for add_xp level-up behavior\n- [ ] Unit tests for progress percentage\n\n## Test Requirements\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn player_experience_starts_at_level_one() {\n        let exp = PlayerExperience::new();\n        assert_eq!(exp.level, 1);\n        assert_eq!(exp.current, 0);\n    }\n\n    #[test]\n    fn xp_to_next_level_increases_each_level() {\n        let mut exp = PlayerExperience::new();\n        let xp_1 = exp.xp_to_next_level();\n        exp.level = 2;\n        let xp_2 = exp.xp_to_next_level();\n        assert!(xp_2 \u003e xp_1);\n    }\n\n    #[test]\n    fn add_xp_levels_up_and_keeps_remainder() {\n        let mut exp = PlayerExperience::new();\n        let threshold = exp.xp_to_next_level();\n        let levels = exp.add_xp(threshold + 10);\n        assert_eq!(levels, 1);\n        assert_eq!(exp.level, 2);\n        assert_eq!(exp.current, 10);\n    }\n\n    #[test]\n    fn add_xp_handles_multiple_level_ups() {\n        let mut exp = PlayerExperience::new();\n        let levels = exp.add_xp(1000); // Should gain multiple levels\n        assert!(levels \u003e 1);\n        assert!(exp.level \u003e 2);\n    }\n\n    #[test]\n    fn progress_returns_correct_percentage() {\n        let mut exp = PlayerExperience::new();\n        exp.current = 50;\n        // With base_xp=100, progress should be 0.5\n        assert!((exp.progress() - 0.5).abs() \u003c 0.01);\n    }\n}\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-30T09:43:44.1818+11:00","updated_at":"2025-12-30T11:15:02.073432+11:00","closed_at":"2025-12-30T11:15:02.073432+11:00","dependencies":[{"issue_id":"dt-survivor-cp8","depends_on_id":"dt-survivor-3l7","type":"blocks","created_at":"2025-12-30T09:45:07.33636+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-cp8","depends_on_id":"dt-survivor-1qz","type":"blocks","created_at":"2025-12-30T09:45:07.638986+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-cp8","depends_on_id":"dt-survivor-aiy","type":"parent-child","created_at":"2025-12-30T09:45:19.413958+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-cq2","title":"Add bevy_lit and bevy_hanabi dependencies for Whisper visual effects","description":"Add the following dependencies to Cargo.toml for advanced Whisper visual effects:\n- bevy_lit 0.9 for 2D lighting (PointLight2d)\n- bevy_hanabi 0.17 for GPU particle effects\n\nThese are needed to implement the full lightning ball visual effect for Whisper.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-26T09:17:14.884699+11:00","updated_at":"2025-12-26T09:19:21.840097+11:00","closed_at":"2025-12-26T09:19:21.840097+11:00"}
{"id":"dt-survivor-d0t","title":"Expand prelude.rs with new modules","description":"Update src/prelude.rs to include commonly used types from new modules: pub use crate::combat::*; pub use crate::movement::*; pub use crate::weapon::WeaponType;. Keeps imports convenient across codebase.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-25T17:42:02.74856+11:00","updated_at":"2025-12-25T20:09:58.443274+11:00","closed_at":"2025-12-25T20:09:58.443274+11:00","dependencies":[{"issue_id":"dt-survivor-d0t","depends_on_id":"dt-survivor-xp9","type":"blocks","created_at":"2025-12-25T17:42:20.114365+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-d0t","depends_on_id":"dt-survivor-3z7","type":"blocks","created_at":"2025-12-25T17:42:20.201006+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-d0t","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:42:21.416994+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-e2t","title":"Final integration testing and cleanup for 3D migration","description":"# Task: 3D Migration Integration Testing\n\n## Context\nThis is the final task in the 2D to 3D migration. After all individual components have been converted, this task verifies the complete system works together and cleans up any remaining 2D artifacts.\n\n## Prerequisites\nAll other migration tasks must be complete:\n- Camera and lighting infrastructure\n- Shared mesh/material resources\n- All entity spawning (player, enemies, bullets, loot)\n- Movement systems XZ conversion\n- Camera follow system\n- Mouse input ray casting\n- Collision detection\n- Whisper particle replacement\n- Laser 3D conversion\n- Rocket/explosion 3D conversion\n\n## Required Changes\n\n### 1. Remove All 2D Dependencies\nVerify no remaining usage of:\n- `Sprite` or `SpriteBundle`\n- `Camera2d` or `Camera2dBundle`\n- `Mesh2d` or `MeshMaterial2d`\n- `Material2d` trait implementations\n- `viewport_to_world_2d`\n- `.truncate()` for XY extraction (should be XZ)\n- `.extend(0.0)` for XY movement (should be XZ)\n\n### 2. Update Cargo.toml\nRemove unused 2D dependencies if applicable:\n- `bevy_lit` (2D lighting - already removed from plugin)\n- Any 2D-specific feature flags\n\n### 3. Clean Up Shader Files\nIf Whisper 2D shaders are no longer used, remove:\n- `assets/shaders/additive_textured.wgsl`\n- `assets/shaders/additive_color.wgsl`\n\nOr keep them marked as deprecated if they might be ported to 3D later.\n\n### 4. Integration Tests\n\n**Full Game Loop Test**:\n```rust\n#[test]\nfn test_game_runs_in_3d() {\n    let mut app = App::new();\n    // Add all plugins\n    // Verify game starts without panic\n    // Verify camera is Camera3d\n    // Verify entities have Mesh3d components\n}\n```\n\n**Gameplay Integration Tests**:\n- Player can move in 3D world\n- Enemies spawn and chase player\n- Bullets fire and hit enemies\n- Loot drops and can be picked up\n- All weapons function (pistol, laser, rocket, whisper)\n- Camera follows player correctly\n- Collisions detected properly\n\n### 5. Visual Verification Checklist\nRun the game and verify:\n- [ ] Ground plane visible\n- [ ] Player cube visible and controllable\n- [ ] Enemies spawn as red cubes around player\n- [ ] Bullets fire as yellow cubes toward enemies\n- [ ] Loot drops when enemies die\n- [ ] Laser beam renders correctly\n- [ ] Rockets fire and explode\n- [ ] Whisper particles visible\n- [ ] Camera maintains isometric angle\n- [ ] Lighting illuminates scene properly\n- [ ] HDR bloom still functional\n\n### 6. Performance Verification\n- [ ] Frame rate acceptable (\u003e30 FPS minimum)\n- [ ] No memory leaks from mesh/material creation\n- [ ] Entity count manageable\n\n### 7. Code Cleanup\n- Remove any TODO comments from migration\n- Ensure all tests pass: `make test`\n- Ensure linting passes: `make lint`\n- Update CLAUDE.md if any patterns changed\n\n## Testing Requirements\n- All existing tests pass after migration\n- Integration test for complete game loop\n- Each weapon system verified functional\n- Collision systems verified\n- Camera system verified\n- 90% code coverage maintained\n\n## Acceptance Criteria\n- [ ] No 2D components remain in codebase\n- [ ] Game runs without crashes\n- [ ] All gameplay systems functional in 3D\n- [ ] Visual appearance acceptable (cubes visible, lit, positioned)\n- [ ] Performance acceptable\n- [ ] All tests pass\n- [ ] No linting warnings\n- [ ] Code coverage \u003e= 90%\n- [ ] `make check \u0026\u0026 make lint \u0026\u0026 make test` all pass","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:50:00.104469+11:00","updated_at":"2025-12-28T11:24:20.612675+11:00","closed_at":"2025-12-28T11:24:20.612675+11:00","dependencies":[{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:34.028625+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-nq8","type":"blocks","created_at":"2025-12-28T09:50:39.848344+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-ggr","type":"blocks","created_at":"2025-12-28T09:50:39.912395+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-0ql","type":"blocks","created_at":"2025-12-28T09:50:39.976026+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-a2s","type":"blocks","created_at":"2025-12-28T09:50:40.041274+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-b67","type":"blocks","created_at":"2025-12-28T09:50:40.108377+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-umn","type":"blocks","created_at":"2025-12-28T09:50:40.172856+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-4i1","type":"blocks","created_at":"2025-12-28T09:50:40.240437+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-ryh","type":"blocks","created_at":"2025-12-28T09:50:40.306979+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-qy4","type":"blocks","created_at":"2025-12-28T09:50:40.372771+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-z7l","type":"blocks","created_at":"2025-12-28T09:50:40.438933+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-rfz","type":"blocks","created_at":"2025-12-28T09:50:40.507864+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-e43","type":"blocks","created_at":"2025-12-28T09:50:40.574685+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e2t","depends_on_id":"dt-survivor-8i6","type":"blocks","created_at":"2025-12-28T09:50:40.642763+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-e43","title":"Convert laser weapon rendering to 3D","description":"# Task: Laser Weapon 3D Conversion\n\n## Context\nDT Survivor is migrating from 2D to 3D. The laser weapon renders as a stretched sprite beam and needs to be converted to 3D geometry (stretched cube or cylinder).\n\n## Current Implementation\n**Laser Spawning** (`src/laser/systems.rs`):\n- Uses `Sprite::from_color()` with cyan color\n- Stretched in one dimension for beam effect\n- Rotated to point from player toward enemies\n- Transform positioned between player and target\n\n## Required Changes\n\n### 1. Replace Sprite with 3D Mesh\n```rust\n// Before\ncommands.spawn((\n    Sprite::from_color(Color::srgb(0.0, 1.0, 1.0), Vec2::new(width, length)),\n    Transform { ... },\n    Laser { ... },\n));\n\n// After\ncommands.spawn((\n    Mesh3d(meshes.add(Cuboid::new(0.1, 0.1, length))), // Thin, long cube\n    MeshMaterial3d(materials.add(StandardMaterial {\n        base_color: Color::srgb(0.0, 1.0, 1.0),\n        emissive: LinearRgba::rgb(0.0, 1.0, 1.0), // Glowing effect\n        ..default()\n    })),\n    Transform {\n        translation: midpoint,\n        rotation: rotation_to_target,\n        ..default()\n    },\n    Laser { ... },\n));\n```\n\n### 2. Update Laser Position Calculation\nConvert from XY to XZ:\n```rust\n// Before\nlet player_pos = player_transform.translation.truncate();\nlet target_pos = enemy_transform.translation.truncate();\nlet midpoint = (player_pos + target_pos) / 2.0;\n\n// After\nlet player_xz = Vec2::new(player_transform.translation.x, player_transform.translation.z);\nlet target_xz = Vec2::new(enemy_transform.translation.x, enemy_transform.translation.z);\nlet midpoint_xz = (player_xz + target_xz) / 2.0;\nlet midpoint = Vec3::new(midpoint_xz.x, 0.5, midpoint_xz.y); // Y at entity height\n```\n\n### 3. Update Laser Rotation\nFor 3D, rotation should be around Y axis to point toward target on XZ plane:\n```rust\nlet direction = (target_xz - player_xz).normalize();\nlet angle = direction.y.atan2(direction.x);\nlet rotation = Quat::from_rotation_y(-angle + std::f32::consts::FRAC_PI_2);\n```\n\n### 4. Update Laser Hit Detection\nAlready covered in collision detection task, but ensure laser line segment uses XZ coordinates.\n\n### 5. Add Emissive Material for Glow\nUse emissive property of StandardMaterial for laser glow effect:\n```rust\nStandardMaterial {\n    base_color: Color::srgb(0.0, 1.0, 1.0),\n    emissive: LinearRgba::rgb(0.0, 2.0, 2.0), // HDR glow\n    unlit: true, // Don't apply lighting\n    ..default()\n}\n```\n\n## Testing Requirements\n- Unit test: Laser spawns with Mesh3d component\n- Unit test: Laser mesh is elongated cube/beam shape\n- Unit test: Laser positioned between player and target\n- Unit test: Laser rotation points toward target on XZ plane\n- Unit test: Laser Y position at entity height\n- Unit test: Laser material has emissive glow\n- Update existing laser tests for 3D\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] Laser renders as 3D beam (stretched cube)\n- [ ] Laser positioned correctly between player and enemy\n- [ ] Laser rotates to point at target on XZ plane\n- [ ] Laser has emissive/glowing appearance\n- [ ] Laser damage system unchanged\n- [ ] No Sprite components in laser\n- [ ] All laser tests updated and passing\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:49:22.09061+11:00","updated_at":"2025-12-28T10:35:44.834103+11:00","closed_at":"2025-12-28T10:35:44.834103+11:00","dependencies":[{"issue_id":"dt-survivor-e43","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.89797+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e43","depends_on_id":"dt-survivor-ggr","type":"blocks","created_at":"2025-12-28T09:50:35.562324+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-e9f","title":"Create Velocity and Speed components","description":"Create movement components in src/movement/components.rs: Velocity(Vec2), Speed(f32), Knockback { direction: Vec2, force: f32, duration: Timer }. These are reusable for player, enemies, and projectiles. Include tests.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T17:41:29.475915+11:00","updated_at":"2025-12-25T19:18:06.400837+11:00","closed_at":"2025-12-25T19:18:06.400837+11:00","dependencies":[{"issue_id":"dt-survivor-e9f","depends_on_id":"dt-survivor-6q4","type":"blocks","created_at":"2025-12-25T17:41:45.165143+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-e9f","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:41:45.874979+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-f77","title":"Add Health component to enemies","description":"Modify src/enemies/systems.rs to spawn enemies with Health component. Update src/bullets/systems.rs and src/laser/systems.rs to use DamageEvent instead of instant despawn. Enemies should now take damage and die when health reaches 0. Enables multi-hit enemies and boss fights.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T17:40:28.947115+11:00","updated_at":"2025-12-25T18:33:28.201304+11:00","closed_at":"2025-12-25T18:33:28.201304+11:00","dependencies":[{"issue_id":"dt-survivor-f77","depends_on_id":"dt-survivor-xp9","type":"blocks","created_at":"2025-12-25T17:40:45.450648+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-f77","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:40:46.014939+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-ggr","title":"Create GameMeshes and GameMaterials resources for 3D entity rendering","description":"# Task: Shared 3D Asset Resources\n\n## Context\nDT Survivor is migrating from 2D sprites to 3D cubes. To efficiently render many entities (player, enemies, bullets, loot), we need shared mesh and material handles that can be cloned rather than recreating assets for each entity.\n\n## Current Implementation\n- Entities use `Sprite::from_color()` which creates inline sprite data\n- No shared mesh/material resources exist\n- Each entity spawns with its own sprite configuration\n\n## Required Changes\n\n### 1. Create Resource Structs (src/game/resources.rs)\n```rust\n#[derive(Resource)]\npub struct GameMeshes {\n    pub player: Handle\u003cMesh\u003e,      // 1.0 x 1.0 x 1.0 cube\n    pub enemy: Handle\u003cMesh\u003e,       // 0.75 x 0.75 x 0.75 cube\n    pub bullet: Handle\u003cMesh\u003e,      // 0.3 x 0.3 x 0.3 cube\n    pub loot_small: Handle\u003cMesh\u003e,  // 0.4 x 0.4 x 0.4 cube (XP orbs)\n    pub loot_large: Handle\u003cMesh\u003e,  // 0.6 x 0.6 x 0.6 cube (weapons)\n    pub rock: Handle\u003cMesh\u003e,        // 1.0 x 0.5 x 1.0 cube (flat)\n}\n\n#[derive(Resource)]\npub struct GameMaterials {\n    pub player: Handle\u003cStandardMaterial\u003e,      // Green, slight emissive\n    pub enemy: Handle\u003cStandardMaterial\u003e,       // Red\n    pub bullet: Handle\u003cStandardMaterial\u003e,      // Yellow, emissive\n    pub xp_orb: Handle\u003cStandardMaterial\u003e,      // Light grey\n    pub health_pack: Handle\u003cStandardMaterial\u003e, // Green\n    pub weapon_pistol: Handle\u003cStandardMaterial\u003e,  // Yellow\n    pub weapon_laser: Handle\u003cStandardMaterial\u003e,   // Blue\n    pub weapon_rocket: Handle\u003cStandardMaterial\u003e,  // Orange\n    pub rock: Handle\u003cStandardMaterial\u003e,        // Grey\n}\n```\n\n### 2. Create Setup System\n```rust\npub fn setup_game_assets(\n    mut commands: Commands,\n    mut meshes: ResMut\u003cAssets\u003cMesh\u003e\u003e,\n    mut materials: ResMut\u003cAssets\u003cStandardMaterial\u003e\u003e,\n) {\n    commands.insert_resource(GameMeshes {\n        player: meshes.add(Cuboid::new(1.0, 1.0, 1.0)),\n        enemy: meshes.add(Cuboid::new(0.75, 0.75, 0.75)),\n        // ... etc\n    });\n    \n    commands.insert_resource(GameMaterials {\n        player: materials.add(StandardMaterial {\n            base_color: Color::srgb(0.0, 1.0, 0.0),\n            emissive: LinearRgba::rgb(0.0, 0.2, 0.0),\n            ..default()\n        }),\n        // ... etc\n    });\n}\n```\n\n### 3. Register in Plugin\n- Add `setup_game_assets` to run in `OnEnter(GameState::InGame)` or `Startup`\n- Ensure it runs before entity spawning systems\n\n## Testing Requirements\n- Unit test: GameMeshes resource contains valid handles after setup\n- Unit test: GameMaterials resource contains valid handles after setup\n- Unit test: All mesh sizes match expected dimensions\n- Unit test: All material colors match expected values\n- Unit test: Resources are available after entering InGame state\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] GameMeshes resource defined with all entity mesh handles\n- [ ] GameMaterials resource defined with all entity material handles\n- [ ] setup_game_assets system creates and inserts both resources\n- [ ] Meshes use appropriate sizes for visual hierarchy (player \u003e enemy \u003e bullet)\n- [ ] Materials use distinguishable colors matching current 2D colors\n- [ ] Resources exported from game module for other modules to use\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:46:28.687202+11:00","updated_at":"2025-12-28T10:01:44.269706+11:00","closed_at":"2025-12-28T10:01:44.269706+11:00","dependencies":[{"issue_id":"dt-survivor-ggr","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.241775+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-gtg","title":"Migrate game from 2D to 3D isometric view","description":"# Epic: 2D to 3D Migration\n\nConvert DT Survivor from 2D sprites to 3D isometric/3/4 view with:\n- Orthographic 3D camera at ~30-45Â° angle\n- Ground plane (XZ) with Y as up axis\n- Cubes replacing sprites for all entities\n- DirectionalLight + PointLight (follows player)\n- bevy_hanabi particles replacing Whisper 2D materials\n\n## Coordinate System Change\n- **Current**: XY ground plane, Z for layer ordering\n- **Target**: XZ ground plane, Y for height (Bevy default, compatible with Blender \"+Y Up\" export)\n\n## Key Files Affected\n- src/main.rs - Remove Lighting2dPlugin\n- src/game/systems.rs - Camera, lighting, entity spawning\n- src/movement/systems.rs - XYâ†’XZ conversion\n- src/player/systems.rs - Camera follow\n- src/enemies/systems.rs, bullets/systems.rs, loot/systems.rs - Cube spawning\n- src/whisper/* - Replace Material2d with particles\n\n## Testing Strategy\nEach subtask must maintain 90% code coverage. All existing tests must be updated to use 3D coordinates (XZ plane). Integration tests should verify visual rendering in 3D.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-28T09:44:21.363951+11:00","updated_at":"2025-12-28T11:24:38.447974+11:00","closed_at":"2025-12-28T11:24:38.447974+11:00"}
{"id":"dt-survivor-jf7","title":"Verify and document weapon damage scaling with levels","description":"Verify the existing weapon level damage scaling system works correctly and document the scaling formula for consistency with other progression systems.\n\n## Context\nWeapons already have levels 1-10 in src/weapon/components.rs. The Weapon component has a calculate_damage() method that scales damage: `base_damage * level * 1.25`. This task verifies this system works correctly and adds comprehensive tests.\n\n## Current Implementation (src/weapon/components.rs)\n```rust\n#[derive(Component, Debug, Clone)]\npub struct Weapon {\n    pub weapon_type: WeaponType,\n    pub level: u32,\n    pub fire_rate: f32,\n    pub base_damage: f32,\n    pub last_fired: f32,\n}\n\nimpl Weapon {\n    /// Calculate actual damage based on level\n    pub fn calculate_damage(\u0026self) -\u003e f32 {\n        self.base_damage * self.level as f32 * 1.25\n    }\n}\n```\n\n## Verification Tasks\n\n### 1. Confirm damage is applied during combat\nTrace the damage flow from weapon firing through to enemy health reduction:\n- weapon_firing_system â†’ spawn projectile with Damage component\n- bullet_collision_detection â†’ fires BulletEnemyCollisionEvent\n- bullet_collision_effects â†’ applies damage via DamageEvent\n- apply_damage_system â†’ reduces enemy Health\n\n### 2. Verify damage scaling formula\n| Level | Base 10 Damage | Calculated |\n|-------|----------------|------------|\n| 1     | 10.0           | 12.5       |\n| 2     | 10.0           | 25.0       |\n| 5     | 10.0           | 62.5       |\n| 10    | 10.0           | 125.0      |\n\n### 3. Add comprehensive tests\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn weapon_damage_scales_with_level() {\n        let weapon = Weapon {\n            weapon_type: WeaponType::Pistol { bullet_count: 1, spread_angle: 0.0 },\n            level: 1,\n            fire_rate: 1.0,\n            base_damage: 10.0,\n            last_fired: 0.0,\n        };\n        assert_eq!(weapon.calculate_damage(), 12.5);\n        \n        let weapon_5 = Weapon { level: 5, ..weapon.clone() };\n        assert_eq!(weapon_5.calculate_damage(), 62.5);\n        \n        let weapon_10 = Weapon { level: 10, ..weapon };\n        assert_eq!(weapon_10.calculate_damage(), 125.0);\n    }\n\n    #[test]\n    fn weapon_damage_increases_linearly_with_level() {\n        let base_weapon = Weapon {\n            weapon_type: WeaponType::Laser,\n            level: 1,\n            fire_rate: 0.5,\n            base_damage: 20.0,\n            last_fired: 0.0,\n        };\n        \n        let damage_1 = base_weapon.calculate_damage();\n        let weapon_2 = Weapon { level: 2, ..base_weapon.clone() };\n        let damage_2 = weapon_2.calculate_damage();\n        \n        // Damage should double when level doubles\n        assert!((damage_2 / damage_1 - 2.0).abs() \u003c 0.01);\n    }\n}\n```\n\n## Integration with Enemy Levels\nWith enemy levels having scaled HP, weapon effectiveness remains consistent:\n- Level 1 enemy (10 HP) vs Level 1 weapon (12.5 damage) = 1 hit kill\n- Level 3 enemy (40 HP) vs Level 1 weapon (12.5 damage) = 4 hit kill\n- Level 3 enemy (40 HP) vs Level 3 weapon (37.5 damage) = 2 hit kill\n- Level 5 enemy (70 HP) vs Level 10 weapon (125 damage) = 1 hit kill\n\nThis creates satisfying progression where leveling weapons makes higher-tier enemies manageable.\n\n## ECS Pattern\n```rust\n// Weapons are queried and damage calculated at fire time\nfn fire_weapon_system(\n    weapon_query: Query\u003c\u0026Weapon, With\u003cEquippedWeapon\u003e\u003e,\n) {\n    for weapon in weapon_query.iter() {\n        let damage = weapon.calculate_damage();\n        // Spawn projectile with Damage(damage)\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] Verify calculate_damage() formula is correct\n- [ ] Verify projectiles spawn with correct Damage component value\n- [ ] Verify damage is correctly applied to enemy Health\n- [ ] Unit tests for weapon damage calculation at all levels 1-10\n- [ ] Document damage formula in code comments\n- [ ] Integration test: weapon damage reduces enemy health correctly\n\n## Test Requirements\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn all_weapon_types_scale_damage_correctly() {\n        let weapon_types = vec![\n            WeaponType::Pistol { bullet_count: 1, spread_angle: 0.0 },\n            WeaponType::Laser,\n            WeaponType::RocketLauncher,\n        ];\n        \n        for weapon_type in weapon_types {\n            let weapon = Weapon {\n                weapon_type,\n                level: 5,\n                fire_rate: 1.0,\n                base_damage: 10.0,\n                last_fired: 0.0,\n            };\n            // 10 * 5 * 1.25 = 62.5\n            assert_eq!(weapon.calculate_damage(), 62.5);\n        }\n    }\n}\n```","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-30T09:44:14.787909+11:00","updated_at":"2025-12-30T11:28:00.41371+11:00","closed_at":"2025-12-30T11:28:00.41371+11:00","dependencies":[{"issue_id":"dt-survivor-jf7","depends_on_id":"dt-survivor-3l7","type":"blocks","created_at":"2025-12-30T09:45:07.868765+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-jf7","depends_on_id":"dt-survivor-aiy","type":"parent-child","created_at":"2025-12-30T09:45:19.486434+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-nq8","title":"Replace Camera2d with orthographic Camera3d and add 3D lighting","description":"# Task: Core 3D Infrastructure\n\n## Context\nDT Survivor is being migrated from 2D to 3D isometric view. This task sets up the foundational 3D rendering infrastructure: camera with orthographic projection at isometric angle, and 3D lighting to replace the 2D lighting system.\n\n## Current Implementation\n- `src/game/systems.rs:19-39`: Camera2d with HDR, Bloom, Lighting2dSettings, AmbientLight2d\n- `src/main.rs`: Registers `Lighting2dPlugin` from bevy_lit\n\n## Required Changes\n\n### 1. Remove 2D Lighting Plugin (src/main.rs)\n- Remove `use bevy_lit::prelude::*` import\n- Remove `.add_plugins(Lighting2dPlugin)` registration\n\n### 2. Replace Camera (src/game/systems.rs)\nReplace Camera2d setup with:\n```rust\ncommands.spawn((\n    Camera3d::default(),\n    Projection::Orthographic(OrthographicProjection {\n        scaling_mode: ScalingMode::FixedVertical { viewport_height: 20.0 },\n        ..default()\n    }),\n    Hdr,\n    Tonemapping::TonyMcMapface,\n    Bloom { intensity: 0.3, ..default() },\n    Transform::from_xyz(0.0, 20.0, 15.0).looking_at(Vec3::ZERO, Vec3::Y),\n));\n```\n\n### 3. Add 3D Lighting\n```rust\n// Directional light (sun)\ncommands.spawn((\n    DirectionalLight {\n        illuminance: 10000.0,\n        shadows_enabled: true,\n        ..default()\n    },\n    Transform::from_rotation(Quat::from_euler(EulerRot::XYZ, -0.8, 0.4, 0.0)),\n));\n\n// Ambient light resource\ncommands.insert_resource(AmbientLight {\n    color: Color::WHITE,\n    brightness: 200.0,\n});\n```\n\n### 4. Add Ground Plane\n```rust\ncommands.spawn((\n    Mesh3d(meshes.add(Plane3d::new(Vec3::Y, Vec2::new(100.0, 100.0)))),\n    MeshMaterial3d(materials.add(StandardMaterial {\n        base_color: Color::srgb(0.2, 0.2, 0.3),\n        ..default()\n    })),\n    Transform::from_translation(Vec3::ZERO),\n));\n```\n\n## Testing Requirements\n- Unit test: Verify camera spawns with correct projection type\n- Unit test: Verify camera transform position and rotation\n- Unit test: Verify DirectionalLight spawns with shadows enabled\n- Unit test: Verify AmbientLight resource is inserted\n- Unit test: Verify ground plane mesh spawns at Y=0\n- Integration test: Game starts without panic after changes\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] Lighting2dPlugin removed from main.rs\n- [ ] Camera2d replaced with Camera3d + orthographic projection\n- [ ] Camera positioned for isometric view (~30-45Â° angle)\n- [ ] DirectionalLight provides main scene illumination\n- [ ] AmbientLight provides base illumination\n- [ ] Ground plane visible as flat surface at Y=0\n- [ ] HDR and Bloom effects still functional\n- [ ] All existing camera tests updated for 3D\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:46:26.845484+11:00","updated_at":"2025-12-28T10:07:33.77432+11:00","closed_at":"2025-12-28T10:07:33.77432+11:00","dependencies":[{"issue_id":"dt-survivor-nq8","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.173058+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-o1l","title":"Implement advanced Whisper visual effects (lighting, particles, bloom)","description":"Implement the full visual effects for Whisper lightning ball:\n\n1. Camera Setup:\n   - Add Lighting2dSettings to camera for bevy_lit\n   - Enable Bevy bloom effect\n\n2. PointLight2d:\n   - Add cyan/white PointLight2d to WhisperCompanion\n   - Configure: intensity 4.0, outer_radius 240.0, falloff 2.0\n\n3. Hanabi GPU Particles:\n   - Create spark effect: 120 particles/sec, 0.35s lifetime\n   - Velocity: 180px/s outward sphere\n   - Size: 4px â†’ 0px over lifetime\n   - Color: Cyan/white\n\n4. Enhanced arc effects:\n   - Replace simple sprites with more dynamic bolt patterns\n   - Add glow/bloom to arc sprites","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-26T09:17:16.185782+11:00","updated_at":"2025-12-26T09:34:46.888549+11:00","closed_at":"2025-12-26T09:34:46.888549+11:00","dependencies":[{"issue_id":"dt-survivor-o1l","depends_on_id":"dt-survivor-cq2","type":"blocks","created_at":"2025-12-26T09:17:28.652257+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-p1n","title":"Add enemy visual differentiation by level (color and size)","description":"Make enemies visually distinct based on their level with different colors and sizes.\n\n## Context\nCurrent enemies use a red color (Color::srgb(1.0, 0.0, 0.0)) and fixed size (0.75 cube). The GameMaterials resource in src/game/systems.rs centralizes materials. Enemies spawn with Mesh3d and MeshMaterial3d components.\n\n## Implementation\n\n### Level-Based Materials (src/game/resources.rs or systems.rs)\n```rust\n/// Materials for each enemy rarity level\npub struct EnemyLevelMaterials {\n    pub common: Handle\u003cStandardMaterial\u003e,      // Grey\n    pub uncommon: Handle\u003cStandardMaterial\u003e,    // Green\n    pub rare: Handle\u003cStandardMaterial\u003e,        // Blue\n    pub epic: Handle\u003cStandardMaterial\u003e,        // Purple\n    pub legendary: Handle\u003cStandardMaterial\u003e,   // Gold with emissive\n}\n\nimpl EnemyLevelMaterials {\n    pub fn new(materials: \u0026mut Assets\u003cStandardMaterial\u003e) -\u003e Self {\n        Self {\n            common: materials.add(StandardMaterial {\n                base_color: Color::srgb(0.6, 0.6, 0.6),\n                ..default()\n            }),\n            uncommon: materials.add(StandardMaterial {\n                base_color: Color::srgb(0.0, 0.8, 0.2),\n                ..default()\n            }),\n            rare: materials.add(StandardMaterial {\n                base_color: Color::srgb(0.2, 0.4, 1.0),\n                ..default()\n            }),\n            epic: materials.add(StandardMaterial {\n                base_color: Color::srgb(0.6, 0.2, 0.8),\n                ..default()\n            }),\n            legendary: materials.add(StandardMaterial {\n                base_color: Color::srgb(1.0, 0.84, 0.0),\n                emissive: LinearRgba::new(1.0, 0.84, 0.0, 0.0) * 2.0,\n                ..default()\n            }),\n        }\n    }\n\n    pub fn for_level(\u0026self, level: u8) -\u003e Handle\u003cStandardMaterial\u003e {\n        match level {\n            1 =\u003e self.common.clone(),\n            2 =\u003e self.uncommon.clone(),\n            3 =\u003e self.rare.clone(),\n            4 =\u003e self.epic.clone(),\n            _ =\u003e self.legendary.clone(),\n        }\n    }\n}\n```\n\n### Level-Based Size Scaling\n```rust\n/// Calculate enemy scale based on level\npub fn enemy_scale_for_level(level: u8) -\u003e f32 {\n    // Base scale is 0.75, increase by 15% per level above 1\n    let base_scale = 0.75;\n    let scale_per_level = 0.15;\n    base_scale + (level.saturating_sub(1) as f32 * scale_per_level)\n}\n\n// Size progression:\n// Level 1: 0.75 (base)\n// Level 2: 0.90\n// Level 3: 1.05\n// Level 4: 1.20\n// Level 5: 1.35\n```\n\n### Enemy Spawning Update (src/enemies/systems.rs)\n```rust\npub fn spawn_enemies_system(\n    // ... existing params ...\n    enemy_materials: Res\u003cEnemyLevelMaterials\u003e,\n) {\n    let enemy_level = select_enemy_level(game_level.level, \u0026mut rng);\n    let scale = enemy_scale_for_level(enemy_level);\n    \n    commands.spawn((\n        Enemy { /* ... */ },\n        Level::new(enemy_level),\n        Mesh3d(game_meshes.enemy.clone()),\n        MeshMaterial3d(enemy_materials.for_level(enemy_level)),\n        Transform::from_translation(spawn_pos)\n            .with_scale(Vec3::splat(scale)),\n        // ... other components ...\n    ));\n}\n```\n\n### Resource Registration (src/game/plugin.rs)\n```rust\n// In setup_game_assets system\nfn setup_game_assets(\n    mut commands: Commands,\n    mut materials: ResMut\u003cAssets\u003cStandardMaterial\u003e\u003e,\n    // ...\n) {\n    commands.insert_resource(EnemyLevelMaterials::new(\u0026mut materials));\n}\n```\n\n## Color Scheme Reference\n| Level | Rarity    | Color                  | RGB               |\n|-------|-----------|------------------------|-------------------|\n| 1     | Common    | Grey                   | (0.6, 0.6, 0.6)   |\n| 2     | Uncommon  | Green                  | (0.0, 0.8, 0.2)   |\n| 3     | Rare      | Blue                   | (0.2, 0.4, 1.0)   |\n| 4     | Epic      | Purple                 | (0.6, 0.2, 0.8)   |\n| 5     | Legendary | Gold (emissive glow)   | (1.0, 0.84, 0.0)  |\n\n## Acceptance Criteria\n- [ ] EnemyLevelMaterials resource created with 5 materials\n- [ ] Enemies spawn with correct material based on level\n- [ ] Enemies spawn with correct scale based on level (0.75 to 1.35)\n- [ ] Legendary enemies have emissive glow effect\n- [ ] Materials cached in resource (not created per spawn)\n- [ ] Unit tests for enemy_scale_for_level function\n- [ ] Visual inspection confirms distinct enemy appearances\n\n## Test Requirements\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn enemy_scale_increases_with_level() {\n        let scale_1 = enemy_scale_for_level(1);\n        let scale_5 = enemy_scale_for_level(5);\n        assert!(scale_5 \u003e scale_1);\n        assert_eq!(scale_1, 0.75);\n    }\n\n    #[test]\n    fn enemy_scale_is_reasonable() {\n        for level in 1..=5 {\n            let scale = enemy_scale_for_level(level);\n            assert!(scale \u003e= 0.75 \u0026\u0026 scale \u003c= 1.5);\n        }\n    }\n}\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-30T09:42:01.51049+11:00","updated_at":"2025-12-30T11:00:02.857155+11:00","closed_at":"2025-12-30T11:00:02.857155+11:00","dependencies":[{"issue_id":"dt-survivor-p1n","depends_on_id":"dt-survivor-wvj","type":"blocks","created_at":"2025-12-30T09:45:07.037007+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-p1n","depends_on_id":"dt-survivor-aiy","type":"parent-child","created_at":"2025-12-30T09:45:19.197443+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-qy4","title":"Update player mouse input to use 3D ray casting","description":"# Task: Player Input 3D Ray Casting\n\n## Context\nDT Survivor is migrating from 2D to 3D. Player movement is controlled by clicking on the screen. Currently, cursor position is converted to 2D world coordinates using `viewport_to_world_2d`. For 3D, we need to cast a ray from the camera through the cursor and intersect it with the ground plane (Y=0).\n\n## Current Implementation\n**Player Movement** (`src/movement/systems.rs:39-82`):\n```rust\npub fn player_movement(\n    // ... params\n    camera_query: Query\u003c(\u0026Camera, \u0026GlobalTransform)\u003e,\n    // ...\n) {\n    // ... button check ...\n    \n    if let Some(world_pos) = camera.viewport_to_world_2d(camera_transform, cursor_pos) {\n        let direction = (world_pos - player_pos).normalize_or_zero();\n        // ... apply movement\n    }\n}\n```\n\nUses `viewport_to_world_2d` which returns `Option\u003cVec2\u003e` for 2D world position.\n\n## Required Changes\n\n### 1. Replace viewport_to_world_2d with 3D Ray Casting\n```rust\npub fn player_movement(\n    buttons: Res\u003cButtonInput\u003cMouseButton\u003e\u003e,\n    windows: Query\u003c\u0026Window\u003e,\n    camera_query: Query\u003c(\u0026Camera, \u0026GlobalTransform), With\u003cCamera3d\u003e\u003e,\n    mut player_query: Query\u003c(\u0026mut Transform, \u0026Player)\u003e,\n    time: Res\u003cTime\u003e,\n) {\n    if !buttons.pressed(MouseButton::Left) {\n        return;\n    }\n\n    let window = windows.single();\n    let Some(cursor_pos) = window.cursor_position() else { return };\n    \n    let Ok((camera, camera_transform)) = camera_query.get_single() else { return };\n    let Ok((mut player_transform, player)) = player_query.get_single_mut() else { return };\n\n    // Cast ray from camera through cursor\n    let Some(ray) = camera.viewport_to_world(camera_transform, cursor_pos) else { return };\n    \n    // Intersect ray with Y=0 plane (ground)\n    // Ray: origin + direction * t = point\n    // For Y=0: origin.y + direction.y * t = 0\n    // Therefore: t = -origin.y / direction.y\n    if ray.direction.y.abs() \u003c 0.0001 {\n        return; // Ray parallel to ground, no intersection\n    }\n    \n    let t = -ray.origin.y / ray.direction.y;\n    if t \u003c 0.0 {\n        return; // Intersection behind camera\n    }\n    \n    let world_pos = ray.origin + ray.direction * t;\n    let target_xz = Vec2::new(world_pos.x, world_pos.z);\n    let player_xz = Vec2::new(player_transform.translation.x, player_transform.translation.z);\n    \n    let direction = (target_xz - player_xz).normalize_or_zero();\n    \n    // Apply movement on XZ plane\n    let speed = player.speed; // Apply slow modifier if present\n    let movement = direction * speed * time.delta_secs();\n    player_transform.translation += Vec3::new(movement.x, 0.0, movement.y);\n}\n```\n\n### 2. Update Query to Use Camera3d\nChange camera query to filter by `Camera3d` component.\n\n### 3. Handle SlowModifier\nEnsure `SlowModifier` component still works for speed reduction:\n```rust\nlet effective_speed = if let Ok(slow) = slow_query.get(player_entity) {\n    player.speed * slow.multiplier\n} else {\n    player.speed\n};\n```\n\n## Testing Requirements\n- Unit test: Ray casting returns correct world position\n- Unit test: Ray-plane intersection calculates correct XZ point\n- Unit test: Player moves toward cursor world position\n- Unit test: Movement applies to X and Z axes only\n- Unit test: Player Y position unchanged\n- Unit test: Parallel ray (edge case) handled gracefully\n- Unit test: Behind-camera intersection ignored\n- Update existing player movement tests\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] viewport_to_world_2d replaced with 3D ray casting\n- [ ] Ray intersects Y=0 ground plane correctly\n- [ ] Player moves toward click position on XZ plane\n- [ ] Player Y position stays constant\n- [ ] Edge cases handled (parallel ray, behind camera)\n- [ ] SlowModifier still reduces movement speed\n- [ ] Mouse button detection unchanged\n- [ ] All movement tests updated and passing\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:49:18.998883+11:00","updated_at":"2025-12-28T10:26:08.600548+11:00","closed_at":"2025-12-28T10:26:08.600548+11:00","dependencies":[{"issue_id":"dt-survivor-qy4","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.701572+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-qy4","depends_on_id":"dt-survivor-nq8","type":"blocks","created_at":"2025-12-28T09:50:36.726173+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-rfz","title":"Replace Whisper 2D materials with bevy_hanabi particle effects","description":"# Task: Whisper Particle Replacement\n\n## Context\nDT Survivor is migrating from 2D to 3D. The Whisper weapon uses custom 2D materials (`AdditiveTextureMaterial`, `AdditiveColorMaterial`) for glow and lightning effects that are incompatible with 3D rendering. Per user decision, these will be replaced with bevy_hanabi particle effects which already work in 3D.\n\n## Current Implementation\n**2D Materials** (`src/whisper/materials.rs`):\n- `AdditiveTextureMaterial`: Custom Material2d with additive blend shader for glow\n- `AdditiveColorMaterial`: Custom Material2d for solid color lightning bolts\n\n**Plugin Registration** (`src/whisper/plugin.rs:14-17`):\n```rust\n.add_plugins((\n    Material2dPlugin::\u003cAdditiveTextureMaterial\u003e::default(),\n    Material2dPlugin::\u003cAdditiveColorMaterial\u003e::default(),\n))\n```\n\n**2D Mesh Usage** (`src/whisper/systems.rs`):\n- Uses `Mesh2d` and `MeshMaterial2d` for glow textures\n- Uses `PointLight2d` for lighting effects\n\n## Required Changes\n\n### 1. Remove 2D Material Plugin Registration\nIn `src/whisper/plugin.rs`, remove:\n```rust\nMaterial2dPlugin::\u003cAdditiveTextureMaterial\u003e::default(),\nMaterial2dPlugin::\u003cAdditiveColorMaterial\u003e::default(),\n```\n\n### 2. Remove 2D Material Spawning\nRemove or replace entities that use:\n- `Mesh2d` component\n- `MeshMaterial2d\u003cAdditiveTextureMaterial\u003e`\n- `MeshMaterial2d\u003cAdditiveColorMaterial\u003e`\n- `PointLight2d`\n\n### 3. Enhance Particle Effects\nThe existing bevy_hanabi particles should be enhanced to replace the visual effects:\n\n**Glow Effect Replacement**:\n```rust\n// Create a particle burst for glow\nlet mut gradient = Gradient::new();\ngradient.add_key(0.0, Vec4::new(1.0, 0.3, 0.3, 1.0)); // Red glow\ngradient.add_key(1.0, Vec4::new(1.0, 0.1, 0.1, 0.0)); // Fade out\n\n// Spawner with short-lived particles around whisper\nlet spawner = Spawner::rate(50.0.into());\n```\n\n**Lightning Effect Replacement**:\n```rust\n// Quick spark particles for lightning\nlet mut gradient = Gradient::new();\ngradient.add_key(0.0, Vec4::new(1.0, 0.0, 0.0, 1.0)); // Bright red\ngradient.add_key(0.5, Vec4::new(1.0, 0.5, 0.0, 0.8)); // Orange\ngradient.add_key(1.0, Vec4::new(0.5, 0.0, 0.0, 0.0)); // Fade\n\n// Burst spawner for lightning flashes\nlet spawner = Spawner::burst(20.0.into(), 0.1.into());\n```\n\n### 4. Update Particle Axes for 3D\nChange particle spawn circles from XY plane to XZ plane:\n```rust\n// Before (2D)\nlet init_pos = SetPositionCircleModifier {\n    axis: writer.lit(Vec3::Z).expr(), // Circle in XY plane\n    ...\n};\n\n// After (3D)\nlet init_pos = SetPositionCircleModifier {\n    axis: writer.lit(Vec3::Y).expr(), // Circle in XZ plane (ground)\n    ...\n};\n```\n\n### 5. Add 3D PointLight for Glow\nReplace `PointLight2d` with 3D `PointLight`:\n```rust\ncommands.spawn((\n    PointLight {\n        color: Color::srgb(1.0, 0.3, 0.3),\n        intensity: 5000.0,\n        radius: 5.0,\n        ..default()\n    },\n    Transform::from_translation(whisper_position),\n    WhisperLight, // Marker component\n));\n```\n\n### 6. Clean Up Unused Code\n- Remove or deprecate `AdditiveTextureMaterial` and `AdditiveColorMaterial`\n- Remove shader files if no longer needed: `assets/shaders/additive_textured.wgsl`, `additive_color.wgsl`\n- Remove texture loading for 2D glow textures\n\n## Testing Requirements\n- Unit test: Whisper spawns without 2D material components\n- Unit test: Particle effects spawn with correct axis\n- Unit test: PointLight3d follows whisper position\n- Unit test: No Mesh2d components in whisper entities\n- Unit test: Particle gradient colors correct\n- Integration test: Whisper weapon functions without crash\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] Material2dPlugin registrations removed\n- [ ] No Mesh2d or MeshMaterial2d components used\n- [ ] PointLight2d replaced with PointLight (3D)\n- [ ] Particle effects provide visual feedback\n- [ ] Particle spawn axes updated for XZ ground plane\n- [ ] Whisper weapon still functions correctly\n- [ ] No visual artifacts or crashes\n- [ ] All whisper tests updated and passing\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:49:20.713811+11:00","updated_at":"2025-12-28T11:14:26.843123+11:00","closed_at":"2025-12-28T11:14:26.843123+11:00","dependencies":[{"issue_id":"dt-survivor-rfz","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.832154+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-rfz","depends_on_id":"dt-survivor-nq8","type":"blocks","created_at":"2025-12-28T09:50:36.857261+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-rfz","depends_on_id":"dt-survivor-8i6","type":"blocks","created_at":"2025-12-28T10:41:53.848561+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-ryh","title":"Update camera follow system for 3D isometric view","description":"# Task: Camera Follow System Update\n\n## Context\nDT Survivor is migrating from 2D to 3D. The camera currently tracks the player by copying X and Y coordinates. For the 3D isometric view, the camera must maintain a fixed offset and rotation while following the player on the XZ plane.\n\n## Current Implementation\n**Camera Follow** (`src/player/systems.rs:194-209`):\n```rust\npub fn camera_follow_player(\n    player_query: Query\u003c\u0026Transform, With\u003cPlayer\u003e\u003e,\n    mut camera_query: Query\u003c\u0026mut Transform, (With\u003cCamera\u003e, Without\u003cPlayer\u003e)\u003e,\n    mut player_position: ResMut\u003cPlayerPosition\u003e,\n) {\n    if let Ok(player_transform) = player_query.single() {\n        let player_pos = player_transform.translation.truncate();\n        player_position.0 = player_pos;\n\n        for mut camera_transform in camera_query.iter_mut() {\n            camera_transform.translation.x = player_transform.translation.x;\n            camera_transform.translation.y = player_transform.translation.y;\n        }\n    }\n}\n```\n\n## Required Changes\n\n### 1. Update Camera Follow to Maintain Isometric Offset\n```rust\npub fn camera_follow_player(\n    player_query: Query\u003c\u0026Transform, With\u003cPlayer\u003e\u003e,\n    mut camera_query: Query\u003c\u0026mut Transform, (With\u003cCamera3d\u003e, Without\u003cPlayer\u003e)\u003e,\n    mut player_position: ResMut\u003cPlayerPosition\u003e,\n) {\n    if let Ok(player_transform) = player_query.single() {\n        // Update PlayerPosition with XZ coordinates\n        player_position.0 = Vec2::new(\n            player_transform.translation.x,\n            player_transform.translation.z,\n        );\n\n        // Isometric camera offset (matching initial camera setup)\n        let camera_offset = Vec3::new(0.0, 20.0, 15.0);\n        \n        for mut camera_transform in camera_query.iter_mut() {\n            // Maintain offset while following player on XZ plane\n            let target_pos = player_transform.translation + camera_offset;\n            camera_transform.translation = target_pos;\n            // Note: Rotation is fixed (set during camera spawn)\n        }\n    }\n}\n```\n\n### 2. Update Query to Use Camera3d\nChange from `With\u003cCamera\u003e` to `With\u003cCamera3d\u003e` to match new camera type.\n\n### 3. Update PlayerPosition Extraction\nEnsure `PlayerPosition` stores XZ coordinates (X, Z) instead of XY:\n```rust\nplayer_position.0 = Vec2::new(\n    player_transform.translation.x,\n    player_transform.translation.z, // Z instead of Y\n);\n```\n\n### 4. Consider Smooth Following (Optional Enhancement)\nFor smoother camera movement, add interpolation:\n```rust\nlet target_pos = player_transform.translation + camera_offset;\ncamera_transform.translation = camera_transform.translation.lerp(target_pos, 5.0 * time.delta_secs());\n```\n\n## Testing Requirements\n- Unit test: Camera maintains correct offset from player\n- Unit test: Camera offset is Vec3(0, 20, 15)\n- Unit test: Camera follows player movement on XZ plane\n- Unit test: Camera Y position stays at player.y + 20\n- Unit test: Camera rotation unchanged during following\n- Unit test: PlayerPosition updated with XZ coordinates\n- Update existing camera tests for 3D\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] Camera follows player on XZ plane\n- [ ] Camera maintains fixed Y offset above player\n- [ ] Camera maintains fixed Z offset behind player\n- [ ] Camera rotation stays fixed (isometric angle)\n- [ ] PlayerPosition resource updated correctly\n- [ ] Query uses Camera3d component\n- [ ] All camera tests updated and passing\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:49:18.811863+11:00","updated_at":"2025-12-28T10:18:42.251049+11:00","closed_at":"2025-12-28T10:18:42.251049+11:00","dependencies":[{"issue_id":"dt-survivor-ryh","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.635111+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-ryh","depends_on_id":"dt-survivor-nq8","type":"blocks","created_at":"2025-12-28T09:50:36.660028+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-s2u","title":"Refactor codebase to Bevy ECS best practices","description":"Comprehensive refactoring to align the dt-survivor codebase with Bevy ECS best practices. Includes: unified combat module with Health/Damage components, SystemSets for explicit ordering, movement module consolidation, weapon plugin population, loot module cleanup, event registration fixes, and various polish items. See plan at ~/.claude/plans/lovely-napping-starfish.md for full details.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-25T17:40:02.957854+11:00","updated_at":"2025-12-25T20:11:37.36042+11:00","closed_at":"2025-12-25T20:11:37.36042+11:00"}
{"id":"dt-survivor-ubg","title":"Consolidate timer cleanup components","description":"Replace AudioCleanupTimer, ExperienceAudioCleanupTimer, LootAudioCleanupTimer with generic CleanupTimer { timer: Timer, cleanup_type: CleanupType }. Create CleanupType enum with Audio, Experience, Loot variants. Update systems in audio, experience, loot modules.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-25T17:42:02.50933+11:00","updated_at":"2025-12-25T19:57:36.794894+11:00","closed_at":"2025-12-25T19:57:36.794894+11:00","dependencies":[{"issue_id":"dt-survivor-ubg","depends_on_id":"dt-survivor-xp9","type":"blocks","created_at":"2025-12-25T17:42:19.955527+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-ubg","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:42:21.259164+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-umn","title":"Convert loot spawning from Sprite to Mesh3d cubes","description":"# Task: Loot 3D Spawning\n\n## Context\nDT Survivor is migrating from 2D to 3D. Loot items (XP orbs, weapons, health packs, powerups) spawn as colored sprites when enemies die and need to be converted to 3D cubes. Loot attraction physics work on XY plane and must be converted to XZ.\n\n## Current Implementation\n**Loot Spawning** (`src/loot/systems.rs:15-128`):\n```rust\n// Experience orbs\ncommands.spawn((\n    Sprite::from_color(Color::srgb(0.75, 0.75, 0.75), Vec2::new(8.0, 8.0)),\n    Transform::from_translation(Vec3::new(enemy_pos.x + offset_x, enemy_pos.y + offset_y, 0.2)),\n    DroppedItem { pickup_state: PickupState::Idle, item_data: ItemData::Experience { amount }, velocity: Vec2::ZERO },\n));\n\n// Weapon drops\ncommands.spawn((\n    Sprite::from_color(color, Vec2::new(16.0, 16.0)),\n    Transform::from_translation(Vec3::new(enemy_pos.x, enemy_pos.y, 0.5)),\n    DroppedItem { ... },\n));\n```\n\n**Loot Colors by Type**:\n- Pistol: Yellow (1.0, 1.0, 0.0), 16x16\n- Laser: Blue (0.0, 0.0, 1.0), 16x16\n- Rocket: Orange (1.0, 0.5, 0.0), 16x16\n- Health Pack: Green (0.0, 1.0, 0.0), 12x12\n- Experience: Grey (0.75, 0.75, 0.75), 8x8\n\n## Required Changes\n\n### 1. Update Loot Spawn Positions\nConvert from XY to XZ plane:\n```rust\n// Before\nVec3::new(enemy_pos.x + offset_x, enemy_pos.y + offset_y, 0.2)\n\n// After\nVec3::new(enemy_pos.x + offset_x, 0.2, enemy_pos.z + offset_z)\n```\n\n### 2. Update Loot Spawning to Use 3D Meshes\n```rust\n// XP Orb\ncommands.spawn((\n    Mesh3d(game_meshes.loot_small.clone()),\n    MeshMaterial3d(game_materials.xp_orb.clone()),\n    Transform::from_translation(Vec3::new(x, 0.2, z)),\n    DroppedItem { ... },\n));\n\n// Weapon\ncommands.spawn((\n    Mesh3d(game_meshes.loot_large.clone()),\n    MeshMaterial3d(game_materials.weapon_pistol.clone()),\n    Transform::from_translation(Vec3::new(x, 0.3, z)),\n    DroppedItem { ... },\n));\n```\n\n### 3. Update Loot Attraction Physics\nThe loot attraction system uses velocity Vec2 and applies to transform. Update to use XZ:\n```rust\n// Before\ntransform.translation += velocity.extend(0.0) * time.delta_secs();\n\n// After\nlet vel = item.velocity * time.delta_secs();\ntransform.translation += Vec3::new(vel.x, 0.0, vel.y);\n```\n\n### 4. Update Pickup Detection\n```rust\n// Before\nlet loot_pos = loot_transform.translation.truncate();\nlet player_pos = player_transform.translation.truncate();\n\n// After\nlet loot_pos = Vec2::new(loot_transform.translation.x, loot_transform.translation.z);\nlet player_pos = Vec2::new(player_transform.translation.x, player_transform.translation.z);\n```\n\n## Testing Requirements\n- Unit test: XP orbs spawn with Mesh3d component\n- Unit test: Weapon drops spawn with correct material for type\n- Unit test: Loot spawns on XZ plane with correct Y height\n- Unit test: Loot attraction works on XZ plane\n- Unit test: Pickup detection works on XZ plane\n- Unit test: Pickup radius unchanged\n- Update existing loot tests for 3D coordinates\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] XP orbs render as small grey cubes\n- [ ] Weapons render as larger colored cubes (yellow/blue/orange)\n- [ ] Health packs render as green cubes\n- [ ] Loot spawns on XZ plane when enemies die\n- [ ] Loot attraction physics work correctly in 3D\n- [ ] Pickup detection functional on XZ plane\n- [ ] Drop rates unchanged\n- [ ] No Sprite components in loot spawning\n- [ ] All existing loot tests updated and passing\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:46:33.773539+11:00","updated_at":"2025-12-28T10:23:16.809182+11:00","closed_at":"2025-12-28T10:23:16.809182+11:00","dependencies":[{"issue_id":"dt-survivor-umn","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.503453+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-umn","depends_on_id":"dt-survivor-ggr","type":"blocks","created_at":"2025-12-28T09:50:35.497345+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-whr","title":"Create combat systems","description":"Create src/combat/systems.rs with: apply_damage (reads DamageEvent, updates Health, fires DeathEvent), check_death (monitors Health \u003c= 0), handle_invincibility (ticks invincibility timers). Include tests.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T17:40:28.720944+11:00","updated_at":"2025-12-25T18:04:44.3668+11:00","closed_at":"2025-12-25T18:04:44.3668+11:00","dependencies":[{"issue_id":"dt-survivor-whr","depends_on_id":"dt-survivor-y2f","type":"blocks","created_at":"2025-12-25T17:40:45.203649+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-whr","depends_on_id":"dt-survivor-1wg","type":"blocks","created_at":"2025-12-25T17:40:45.294286+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-whr","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:40:45.856432+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-wvj","title":"Implement Enemy Level system with HP and damage scaling","description":"Add Level component to enemies, with HP and damage that scale based on their level. Enemy levels are influenced by the current game level.\n\n## Context\nCurrent enemy spawning is in src/enemies/systems.rs. Enemies currently have:\n- speed: 1.7 units/sec\n- strength: 10.0 (damage to player)\n- Health: 10.0 HP\n\nWith this change, enemies will have levels 1-5, and their stats will scale accordingly.\n\n## Implementation\n\n### Updated Enemy Component (src/enemies/components.rs)\n```rust\n/// Configuration for enemy stat scaling\npub struct EnemyScaling {\n    pub base_health: f32,\n    pub health_per_level: f32,\n    pub base_damage: f32,\n    pub damage_per_level: f32,\n}\n\nimpl Default for EnemyScaling {\n    fn default() -\u003e Self {\n        Self {\n            base_health: 10.0,\n            health_per_level: 15.0,  // Level 5 = 10 + (4 * 15) = 70 HP\n            base_damage: 10.0,\n            damage_per_level: 5.0,   // Level 5 = 10 + (4 * 5) = 30 damage\n        }\n    }\n}\n\nimpl EnemyScaling {\n    pub fn health_for_level(\u0026self, level: u8) -\u003e f32 {\n        self.base_health + (level.saturating_sub(1) as f32 * self.health_per_level)\n    }\n\n    pub fn damage_for_level(\u0026self, level: u8) -\u003e f32 {\n        self.base_damage + (level.saturating_sub(1) as f32 * self.damage_per_level)\n    }\n}\n```\n\n### Enemy Spawning Update (src/enemies/systems.rs)\n```rust\n/// Determine enemy level based on game level with weighted random selection\nfn select_enemy_level(game_level: u32, rng: \u0026mut impl Rng) -\u003e u8 {\n    // Base spawn chances (percentages)\n    // Game level increases chances of higher-tier enemies\n    let level_bonus = (game_level.saturating_sub(1) as f32 * 5.0).min(40.0);\n    \n    let chances = [\n        (1, 100.0 - level_bonus),           // Level 1: starts at 100%, decreases\n        (2, 15.0 + level_bonus * 0.5),      // Level 2: starts at 15%\n        (3, 8.0 + level_bonus * 0.3),       // Level 3: starts at 8%\n        (4, 4.0 + level_bonus * 0.15),      // Level 4: starts at 4%\n        (5, 2.0 + level_bonus * 0.05),      // Level 5: starts at 2%\n    ];\n    \n    let total: f32 = chances.iter().map(|(_, c)| c).sum();\n    let roll = rng.gen_range(0.0..total);\n    \n    let mut cumulative = 0.0;\n    for (level, chance) in chances {\n        cumulative += chance;\n        if roll \u003c cumulative {\n            return level;\n        }\n    }\n    1 // Fallback\n}\n\npub fn spawn_enemies_system(\n    mut commands: Commands,\n    game_meshes: Res\u003cGameMeshes\u003e,\n    // ... existing params ...\n    game_level: Res\u003cGameLevel\u003e,\n) {\n    // ... existing spawn logic ...\n    \n    let enemy_level = select_enemy_level(game_level.level, \u0026mut rng);\n    let scaling = EnemyScaling::default();\n    \n    commands.spawn((\n        Enemy {\n            speed: 1.7,\n            strength: scaling.damage_for_level(enemy_level),\n        },\n        Health::new(scaling.health_for_level(enemy_level)),\n        Level::new(enemy_level),\n        CheckDeath,\n        // ... mesh and transform ...\n    ));\n}\n```\n\n### Spawn Rate Adjustment\nHigher level enemies spawn less frequently. The select_enemy_level function handles this via weighted probabilities.\n\n## Stat Scaling Table\n| Level | HP | Damage | Base Spawn % | At Game Lvl 5 |\n|-------|-----|--------|--------------|---------------|\n| 1     | 10  | 10     | 100%         | 80%           |\n| 2     | 25  | 15     | 15%          | 25%           |\n| 3     | 40  | 20     | 8%           | 14%           |\n| 4     | 55  | 25     | 4%           | 7%            |\n| 5     | 70  | 30     | 2%           | 3%            |\n\n## ECS Pattern\n```rust\n// Entities with Level component can be queried together\nfn process_leveled_enemies(\n    query: Query\u003c(Entity, \u0026Level, \u0026Health, \u0026Enemy)\u003e,\n) {\n    for (entity, level, health, enemy) in query.iter() {\n        // Access level.value() for logic\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] Enemies spawn with Level component (1-5)\n- [ ] Enemy HP scales with level (10, 25, 40, 55, 70)\n- [ ] Enemy damage scales with level (10, 15, 20, 25, 30)\n- [ ] Higher game levels increase chance of higher level enemies\n- [ ] Level 1 enemies are most common, level 5 rarest\n- [ ] Unit tests for EnemyScaling calculations\n- [ ] Unit tests for select_enemy_level probability distribution\n- [ ] Integration test verifying enemy spawns with correct stats\n\n## Test Requirements\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn enemy_scaling_calculates_correct_health() {\n        let scaling = EnemyScaling::default();\n        assert_eq!(scaling.health_for_level(1), 10.0);\n        assert_eq!(scaling.health_for_level(2), 25.0);\n        assert_eq!(scaling.health_for_level(5), 70.0);\n    }\n\n    #[test]\n    fn enemy_scaling_calculates_correct_damage() {\n        let scaling = EnemyScaling::default();\n        assert_eq!(scaling.damage_for_level(1), 10.0);\n        assert_eq!(scaling.damage_for_level(5), 30.0);\n    }\n\n    #[test]\n    fn select_enemy_level_returns_valid_level() {\n        let mut rng = rand::thread_rng();\n        for _ in 0..100 {\n            let level = select_enemy_level(1, \u0026mut rng);\n            assert!(level \u003e= 1 \u0026\u0026 level \u003c= 5);\n        }\n    }\n}\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-30T09:41:30.65505+11:00","updated_at":"2025-12-30T10:53:06.480485+11:00","closed_at":"2025-12-30T10:53:06.480485+11:00","dependencies":[{"issue_id":"dt-survivor-wvj","depends_on_id":"dt-survivor-3l7","type":"blocks","created_at":"2025-12-30T09:45:06.88562+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-wvj","depends_on_id":"dt-survivor-ahu","type":"blocks","created_at":"2025-12-30T09:45:06.961203+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-wvj","depends_on_id":"dt-survivor-aiy","type":"parent-child","created_at":"2025-12-30T09:45:19.128273+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-xp9","title":"Create CombatPlugin","description":"Create src/combat/plugin.rs with CombatPlugin that registers events, systems with run_if(in_state(GameState::InGame)). Add to main.rs plugin list.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T17:40:28.836415+11:00","updated_at":"2025-12-25T18:09:47.843379+11:00","closed_at":"2025-12-25T18:09:47.843379+11:00","dependencies":[{"issue_id":"dt-survivor-xp9","depends_on_id":"dt-survivor-whr","type":"blocks","created_at":"2025-12-25T17:40:45.37134+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-xp9","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:40:45.93232+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-y2f","title":"Create Health, Damage, Hitbox components","description":"Create reusable combat components in src/combat/components.rs: Health { current: f32, max: f32 } with take_damage/is_dead methods, Damage(f32) for projectiles, Hitbox(f32) for collision radius, Invincibility(Timer) for damage immunity frames. Include unit tests.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T17:40:28.501006+11:00","updated_at":"2025-12-25T17:57:55.248747+11:00","closed_at":"2025-12-25T17:57:55.248747+11:00","dependencies":[{"issue_id":"dt-survivor-y2f","depends_on_id":"dt-survivor-1a7","type":"blocks","created_at":"2025-12-25T17:40:45.036797+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-y2f","depends_on_id":"dt-survivor-s2u","type":"parent-child","created_at":"2025-12-25T17:40:45.696396+11:00","created_by":"daemon"}]}
{"id":"dt-survivor-z7l","title":"Update collision detection systems to use XZ plane","description":"# Task: Collision Detection XZ Conversion\n\n## Context\nDT Survivor is migrating from 2D to 3D. Collision detection between entities uses `.truncate()` to get XY positions for distance checks. All collision systems must be updated to use XZ coordinates instead.\n\n## Current Implementation\n**Player-Enemy Collision** (`src/game/systems.rs`):\n```rust\nlet player_pos = player_transform.translation.truncate();\nlet enemy_pos = enemy_transform.translation.truncate();\nlet distance = player_pos.distance(enemy_pos);\n```\n\n**Bullet-Enemy Collision** (`src/bullets/systems.rs`):\nSimilar pattern using `.truncate()` for XY extraction.\n\n**Loot Pickup** (`src/loot/systems.rs`):\nUses `.truncate()` for pickup radius checks.\n\n**Laser Hit Detection** (`src/laser/systems.rs`):\nLine-circle intersection on XY plane.\n\n## Required Changes\n\n### 1. Create Position Extraction Helper\nUse the `from_xz` function from movement module or create locally:\n```rust\nfn get_xz(translation: Vec3) -\u003e Vec2 {\n    Vec2::new(translation.x, translation.z)\n}\n```\n\n### 2. Update Player-Enemy Collision\n```rust\n// Before\nlet player_pos = player_transform.translation.truncate();\nlet enemy_pos = enemy_transform.translation.truncate();\n\n// After\nlet player_pos = Vec2::new(player_transform.translation.x, player_transform.translation.z);\nlet enemy_pos = Vec2::new(enemy_transform.translation.x, enemy_transform.translation.z);\n```\n\n### 3. Update Bullet-Enemy Collision\n```rust\nfn check_bullet_enemy_collision(\n    bullet_query: Query\u003c(Entity, \u0026Transform), With\u003cBullet\u003e\u003e,\n    enemy_query: Query\u003c(Entity, \u0026Transform), With\u003cEnemy\u003e\u003e,\n    // ...\n) {\n    for (bullet_entity, bullet_transform) in bullet_query.iter() {\n        let bullet_pos = Vec2::new(\n            bullet_transform.translation.x,\n            bullet_transform.translation.z,\n        );\n        \n        for (enemy_entity, enemy_transform) in enemy_query.iter() {\n            let enemy_pos = Vec2::new(\n                enemy_transform.translation.x,\n                enemy_transform.translation.z,\n            );\n            \n            if bullet_pos.distance(enemy_pos) \u003c COLLISION_RADIUS {\n                // Handle collision\n            }\n        }\n    }\n}\n```\n\n### 4. Update Loot Pickup Detection\n```rust\nlet loot_pos = Vec2::new(loot_transform.translation.x, loot_transform.translation.z);\nlet player_pos = Vec2::new(player_transform.translation.x, player_transform.translation.z);\nlet distance = loot_pos.distance(player_pos);\nif distance \u003c player.pickup_radius {\n    // Pickup\n}\n```\n\n### 5. Update Laser Hit Detection\nLaser line segment and enemy circle intersection on XZ plane:\n```rust\n// Laser start and end points\nlet start = Vec2::new(laser_start.x, laser_start.z);\nlet end = Vec2::new(laser_end.x, laser_end.z);\nlet enemy_center = Vec2::new(enemy_pos.x, enemy_pos.z);\n// Line-circle intersection math remains the same\n```\n\n### 6. Update Rocket/Explosion Collision\nSimilar XZ extraction for rocket impacts and explosion radius checks.\n\n## Files to Update\n- `src/game/systems.rs` - Player-enemy collision\n- `src/bullets/systems.rs` - Bullet-enemy collision\n- `src/loot/systems.rs` - Pickup detection\n- `src/laser/systems.rs` - Laser hit detection\n- `src/rocket_launcher/systems.rs` - Rocket/explosion collision\n\n## Testing Requirements\n- Unit test: Player-enemy collision detects correctly on XZ\n- Unit test: Bullet-enemy collision works on XZ plane\n- Unit test: Loot pickup detects within radius on XZ\n- Unit test: Laser hit detection works on XZ plane\n- Unit test: Explosion radius checks work on XZ\n- Unit test: Distance calculations ignore Y axis\n- Update all existing collision tests\n- Maintain 90% code coverage\n\n## Acceptance Criteria\n- [ ] All `.truncate()` calls replaced with XZ extraction\n- [ ] Player-enemy collision works in 3D\n- [ ] Bullet-enemy collision works in 3D\n- [ ] Loot pickup detection works in 3D\n- [ ] Laser hit detection works in 3D\n- [ ] Explosion damage works in 3D\n- [ ] Collision radii unchanged\n- [ ] All collision tests updated and passing\n- [ ] `make test` passes with 90%+ coverage\n- [ ] `make lint` passes with no warnings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-28T09:49:19.194458+11:00","updated_at":"2025-12-28T10:35:37.622788+11:00","closed_at":"2025-12-28T10:35:37.622788+11:00","dependencies":[{"issue_id":"dt-survivor-z7l","depends_on_id":"dt-survivor-gtg","type":"parent-child","created_at":"2025-12-28T09:50:33.767041+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-z7l","depends_on_id":"dt-survivor-4i1","type":"blocks","created_at":"2025-12-28T09:50:38.199674+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-z7l","depends_on_id":"dt-survivor-0ql","type":"blocks","created_at":"2025-12-28T09:50:38.268668+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-z7l","depends_on_id":"dt-survivor-a2s","type":"blocks","created_at":"2025-12-28T09:50:38.335113+11:00","created_by":"daemon"},{"issue_id":"dt-survivor-z7l","depends_on_id":"dt-survivor-b67","type":"blocks","created_at":"2025-12-28T09:50:38.400672+11:00","created_by":"daemon"}]}
